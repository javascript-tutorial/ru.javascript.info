<<<<<<< HEAD
Регулярное выражение для числа: `pattern:-?\d+(\.\d+)?`. Мы создали его в предыдущих задачах.
=======
A regexp for a number is: `pattern:-?\d+(\.\d+)?`. We created it in the previous task.
>>>>>>> 51bc6d3cdc16b6eb79cb88820a58c4f037f3bf19

Регулярное выражение для оператора `pattern:[-+*/]`. Дефис `pattern:-` стоит в начале квадратных скобок, потому что в середине этот символ будет означать диапазон, а нам нужен просто символ `-`.

Отметим, что косая черта должна быть экранирована внутри регулярного выражения JavaScript `pattern:/.../`.

Нам необходимо число, оператор и, затем, другие числа. Между ними могут быть необязательные пробелы.

Полное выражение: `pattern:-?\d+(\.\d+)?\s*[-+*/]\s*-?\d+(\.\d+)?`.

<<<<<<< HEAD
Оно состоит из трёх частей, между которыми стоит `pattern:\s*`:
1. `pattern:-?\d+(\.\d+)?` - первое число,
1. `pattern:[-+*/]` - оператор,
1. `pattern:-?\d+(\.\d+)?` - второе число.
=======
It has 3 parts, with `pattern:\s*` between them:
1. `pattern:-?\d+(\.\d+)?` - the first number,
2. `pattern:[-+*/]` - the operator,
3. `pattern:-?\d+(\.\d+)?` - the second number.
>>>>>>> 51bc6d3cdc16b6eb79cb88820a58c4f037f3bf19

Для получения этих частей в виде отдельных элементов массива-результата давайте вставим скобки вокруг каждой из них, получится `pattern:(-?\d+(\.\d+)?)\s*([-+*/])\s*(-?\d+(\.\d+)?)`.

В действии:

```js run
let regexp = /(-?\d+(\.\d+)?)\s*([-+*\/])\s*(-?\d+(\.\d+)?)/;

alert( "1.2 + 12".match(regexp) );
```

Результат `result` включает в себя:

- `result[0] == "1.2 + 12"` (полное совпадение)
- `result[1] == "1.2"` (первая группа `(-?\d+(\.\d+)?)` -- первое число, включая десятичную часть)
- `result[2] == ".2"` (вторая группа `(\.\d+)?` -- первая десятичная часть)
- `result[3] == "+"` (третья группа `([-+*\/])` -- оператор)
- `result[4] == "12"` (четвёртая группа `(-?\d+(\.\d+)?)` -- второе число)
- `result[5] == undefined` (пятая группа `(\.\d+)?` -- вторая десятичная часть отсутствует, поэтому значение `undefined`)

Нам необходимы только числа и оператор без полного совпадения или десятичной части, поэтому давайте "почистим" этот результат.

Первый элемент массива (полное совпадение) можно удалить при помощи сдвига массива `result.shift()`.

Группы, которые содержат десятичную часть (номер 2 и 4) `pattern:(.\d+)` можно убрать из массива, добавив `pattern:?:` в начало: `pattern:(?:\.\d+)?`.

Итоговое решение:

```js run
function parse(expr) {
  let regexp = /(-?\d+(?:\.\d+)?)\s*([-+*\/])\s*(-?\d+(?:\.\d+)?)/;

  let result = expr.match(regexp);

  if (!result) return [];
  result.shift();

  return result;
}

alert( parse("-1.23 * 3.45") );  // -1.23, *, 3.45
```

As an alternative to using the non-capturing `?:`, we could name the groups, like this:

```js run
function parse(expr) {
	let regexp = /(?<a>-?\d+(?:\.\d+)?)\s*(?<operator>[-+*\/])\s*(?<b>-?\d+(?:\.\d+)?)/;

	let result = expr.match(regexp);

	return [result.groups.a, result.groups.operator, result.groups.b];
}

alert( parse("-1.23 * 3.45") );  // -1.23, *, 3.45;
```