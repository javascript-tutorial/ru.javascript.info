# Жадные и ленивые квантификаторы

На первый взгляд квантификаторы очень просты, но на самом деле это не так.

Нужно очень хорошо разбираться, как работает поиск, если планируешь использовать что-то более сложное, чем: `pattern:/\d+/`.

Давайте в качестве примера рассмотрим следующую задачу:

У нас есть текст, в котором нужно заменить все кавычки `"..."` на "ёлочки" `«...»`, которые используются в типографике многих стран.

Например: `"Привет, мир"` должно превратиться в `«Привет, мир»`. Некоторые страны предпочитают другие кавычки, вроде `„Witam, świat!”` (польский) или `「你好，世界」` (китайский), но для нашей задачи давайте выберем `«...»`.

Первое, что нам нужно, это найти строки с кавычками, а затем -- мы можем их заменить.

Регулярное выражение вроде `pattern:/".+"/g` (кавычка, какой-то текст, другая кавычка) может выглядеть хорошим решением, но это не так!

Давайте это проверим:

```js run
let reg = /".+"/g;

let str = 'a "witch" and her "broom" is one';

alert( str.match(reg) ); // "witch" and her "broom"
```

...Как мы видим, регулярное выражение работает не как задумано!

Вместо того, чтобы найти два совпадения `match:"witch"` и `match:"broom"`, было найдено одно:`match:"witch" and her "broom"`. 

Это можно описать, как "жадность -- причина всех зол".

## Жадный поиск

Чтобы найти совпадение, движок регулярного выражения работает по следующему алгоритму:

- Для каждой позиции в строке
    - Искать совпадение на данной позиции
    - Если нет совпадения, переход к следующей позиции

Эти общие слова никак не объясняют, почему регулярное выражение работает неправильно, так что давайте разберём подробно, как работает шаблон `pattern:".+"`.

1. Первый символ шаблона -- это кавычка `pattern:"`.

    Движок регулярного выражения пытается найти его на нулевой позиции исходной строки `subject:a "witch" and her "broom" is one`, но там -- `subject:a`, так что совпадения нет.

    Он продолжает: двигается к следующей позиции исходной строки и пытается найти первый символ шаблона там. И, наконец, находит кавычку на третьей позиции:

    ![](witch_greedy1.png)

2. Кавычка замечена, после чего движок пытается найти совпадение для оставшегося шаблона. Смотрит, удовлетворяет ли остаток строки шаблону `pattern:.+"`.

    В нашем случае следующий символ шаблона: `pattern:.` (точка). Она обозначает "любой символ, кроме новой строки", так что следующая буква строки `match:'w'` подходит.

    ![](witch_greedy2.png)

3. Затем точка повторяется из-за квантификатора `pattern:.+`. Движок регулярного выражения строит совпадение, принимая символы один за другим, пока это возможно.

    ...До каких пор? Точке соответствуют любые символы, так что движок остановится только тогда, когда достигнет конца строки: 

    ![](witch_greedy3.png)

4. Тогда он перестанет повторять `pattern:.+` и попробует найти следующий символ шаблона. Это кавычка `pattern:"`. Но есть проблема: строка закончилась, больше нет символов!

    Движок регулярного выражения понимает, что захватил слишком много `pattern:.+` и начинает *отступать*.

    Другими словами, он сокращает совпадение по квантификатору на один символ:

    ![](witch_greedy4.png)

    Теперь он предполагает, что `pattern:.+` заканчивается за один символ до конца строки и пытается сопоставить остаток шаблона для этой позиции.

    Если бы тут была кавычка, тогда бы работа закончилась, но последний символ -- это `subject:'e'`, так что он не подходит.

5. ...Поэтому движок уменьшает количество повторений `pattern:.+` на ещё один символ:

    ![](witch_greedy5.png)

    Кавычка `pattern:'"'`не соответствует `subject:'n'`.

6. Движок продолжает отступать: он уменьшает количество повторений `pattern:'.'` пока оставшийся шаблон (в нашем случае `pattern:'"'`) не совпадёт:

    ![](witch_greedy6.png)

7. Совпадение найдено.

8. Так что первое совпадение: `match:"witch" and her "broom"`. Дальнейший поиск продолжается с того места, где закончился предыдущий. В оставшейся строке `subject:is one` нет кавычек, так что совпадений больше нет.

Это определённо не то, что мы ожидали. Но так оно работает.

**В жадном режиме (по умолчанию) квантификатор повторяется столько раз, сколько это возможно.**

Движок регулярного выражения пытается получить максимальное количество символов соответствующих `pattern:.+`, а затем сокращает это количество символ за символом.

В нашей задаче мы хотим другого. Для чего и создан ленивый квантификатор.

## Ленивый режим

"Ленивый" режим противоположен "жадному". Он означает: "повторять квантификатор наименьшее количество раз".

Мы можем включить его, вставив знак вопроса `pattern:'?'` после квантификатора, получая `pattern:*?` или `pattern:+?` или даже `pattern:??` для `pattern:'?'`. 

Проясним: обычно знак вопроса `pattern:?` сам по себе является квантификатором (ноль или один), но, если он добавлен *после другого квантификтора (или даже после самого себя)*, он получает другое значение -- он меняет режим совпадения с жадного на ленивый.

Регулярное выражение `pattern:/".+?"/g` работает как задумано, оно находит `match:"witch"` и `match:"broom"`:

```js run
let reg = /".+?"/g;

let str = 'a "witch" and her "broom" is one';

alert( str.match(reg) ); // witch, broom
```

Чтобы лучше понять, что поменялось, давайте рассмотрим процесс поиска шаг за шагом.

1. Первый шаг будет таким же: движок находит начало шаблона `pattern:'"'` на 3-ей позиции:

    ![](witch_greedy1.png)

2. Следующий шаг аналогичен: он найдёт совпадение для точки `pattern:'.'`:

    ![](witch_greedy2.png)

3. А отсюда поиск продолжится по-другому. Из-за того, что у нас включён ленивый режим для `pattern:+?`, движок не будет пытаться найти совпадение для точки ещё раз, оно остановится и попробует найти совпадение для оставшегося шаблона `pattern:'"'` прямо сейчас:

    ![](witch_lazy3.png)

    Если бы на этом месте была кавычка, то поиск бы закончился, но там находится `'i'`, то есть совпадения нет.
4. Тогда движок регулярного выражения увеличит количество повторений для точки и попробует ещё раз:

    ![](witch_lazy4.png)

    Опять неудача. Тогда количество повторений будет увеличено ещё и ещё...
5. ...до тех пор, пока совпадение для оставшегося шаблона не будет найдено:

    ![](witch_lazy5.png)

6. Следующий поиск начнётся с того места, где закончилось текущее совпадение и у нас будет ещё один результат:

    ![](witch_lazy6.png)

В этом примере мы увидели, как ленивый режим работает для `pattern:+?`. Квантификаторы `pattern:+?` и `pattern:??` работают аналогичным образом -- движок регулярного выражения увеличит количество совпадений, только если не сможет найти совпадение для оставшегося шаблона на текущей позиции.

**Ленивый режим включается только для квантификаторов с `?`.**

Остальные квантификаторы остаются жадными.

Например:

```js run
alert( "123 456".match(/\d+ \d+?/g) ); // 123 4
```

1. Шаблон `pattern:\d+` пытается найти столько цифр, сколько возможно (жадный режим), так что он находит `match:123` и останавливается, потому что следующим символом будет пробел `pattern:' '`.
2. Дальше в шаблоне пробел, так что есть совпадение.
3. Затем идёт `pattern:\d+?`. Квантификатор находится в ленивом режиме, так что он находит одну цифру `match:4` и проверяет, есть ли совпадение для оставшегося шаблона с этого места.

    ...Но в шаблоне `pattern:\d+?` больше ничего нет.

    Ленивый режим ничего не повторяет без необходимости. Шаблон закончился, как и поиск. Мы получаем `match:123 4`. 
4. Следующий поиск начинается с символа `5`.

```smart header="Оптимизации"
Современные движки регулярных выражений могут оптимизировать внутренние алгоритмы ради ускорения. Так что их работа может несколько отличаться от описанного алгоритма.

Но нам не нужно этого знать для понимания того, как пишутся и работают регулярные выражения. Оптимизация -- это внутренний процесс, мы его не увидим.

Сложные регулярные выражения трудно оптимизировать, так что поиск может работать и в точности так, как было описано.
```

## Альтернативный подход

С регулярными выражениями часто есть несколько путей добиться одного и того же результата.

В нашем случаем мы можем найти кавычки без использования ленивого режима с помощью регулярного выражения `pattern:"[^"]+"`:

```js run
let reg = /"[^"]+"/g;

let str = 'a "witch" and her "broom" is one';

alert( str.match(reg) ); // witch, broom
```

Регулярное выражение `pattern:"[^"]+"` получит нужный результат, потому что оно ищет кавычку `pattern:'"'`, за которой следует один или несколько символов не кавычек `pattern:[^"]`, а затем -- закрывающая кавычка.

Движок регулярного выражения заканчивает поиск `pattern:[^"]`, когда встречает закрывающую кавычку.

Обратите внимание, что эта логика не заменяет ленивые квантификаторы!

Просто она работает по-другому. Временами на нужен первый вариант, временами -- второй.

**Давайте посмотрим пример, в котором ленивый квантификатор не справляется, а этот вариант работает правильно.**

Например, мы хотим найти ссылки вида `<a href="..." class="doc">`, с произвольным `href`.

Какое регулярное выражение нам нужно использовать?

Первой мыслью может быть: `pattern:/<a href=".*" class="doc">/g`.

Давайте проверим:
```js run
let str = '...<a href="link" class="doc">...';
let reg = /<a href=".*" class="doc">/g;

// Работает!
alert( str.match(reg) ); // <a href="link" class="doc">
```

Регулярное выражение работает. Но давайте посмотрим, что произойдёт, если в тексте будет много ссылок?

```js run
let str = '...<a href="link1" class="doc">... <a href="link2" class="doc">...';
let reg = /<a href=".*" class="doc">/g;

// Упс! Две ссылки в одном совпадении!
alert( str.match(reg) ); // <a href="link1" class="doc">... <a href="link2" class="doc">
```

В данном случае мы получили неправильный результат по той же причине, что в примере с "witches". Квантификатор `pattern:.*` забирает слишком много символов.

Совпадение будет выглядеть так:

```html
<a href="....................................." class="doc">
<a href="link1" class="doc">... <a href="link2" class="doc">
```

Давайте изменим шаблон, сделав квантификатор ленивым `pattern:.*?`:

```js run
let str = '...<a href="link1" class="doc">... <a href="link2" class="doc">...';
let reg = /<a href=".*?" class="doc">/g;

// Работает!
alert( str.match(reg) ); // <a href="link1" class="doc">, <a href="link2" class="doc">
```

Теперь кажется, что всё работает правильно. У нас есть два совпадения:

```html
<a href="....." class="doc">    <a href="....." class="doc">
<a href="link1" class="doc">... <a href="link2" class="doc">
```

...Но давайте попробуем его на ещё одном тексте:

```js run
let str = '...<a href="link1" class="wrong">... <p style="" class="doc">...';
let reg = /<a href=".*?" class="doc">/g;

// Неправильное совпадение!
alert( str.match(reg) ); // <a href="link1" class="wrong">... <p style="" class="doc">
```

Ну вот, ленивый квантификатор нас подвёл. В совпадении находится не только ссылка, но и текст после неё, включая `<p...>`.

Почему?

Происходит следующее:

1. Первым делом регулярное выражение находит начало ссылки `match:<a href="`.
2. Затем оно ищет `pattern:.*?`, берёт один символ (лениво!) и проверяет, есть ли совпадение для `pattern:"` (нет).
3. Затем берёт другой символ для `pattern:.*?`, и так далее... Пока, наконец, не достигнет `match:" class="doc">`.

Но с этим есть проблема: это совпадение находится уже за границей ссылки, в другом теге `<p>`. Что нам не подходит.

Вот как оно выглядит по отношению к исходному тексту:

```html
<a href="..................................." class="doc">
<a href="link1" class="wrong">... <p style="" class="doc">
```

Итак, в данном случае ленивый режим нам не подходит.

Нам нужен шаблон для поиска `<a href="...something..." class="doc">`, но и с ленивым и с жадным режимами есть проблема.

Правильным вариантом может стать: `pattern:href="[^"]*"`. Он найдёт все символы внутри атрибута `href` до ближайшей следующей кавычки, как раз то, что нам нужно.

Работающий пример:

```js run
let str1 = '...<a href="link1" class="wrong">... <p style="" class="doc">...';
let str2 = '...<a href="link1" class="doc">... <a href="link2" class="doc">...';
let reg = /<a href="[^"]*" class="doc">/g;

// Работает!
alert( str1.match(reg) ); // совпадений нет, всё правильно
alert( str2.match(reg) ); // <a href="link1" class="doc">, <a href="link2" class="doc">
```

## Итого

У квантификаторов есть два режима работы:

Жадный
: По умолчанию движок регулярного выражения пытается повторить квантификатор столько раз, сколько это возможно. Например, `pattern:\d+` получит все возможные цифры. Когда цифры закончатся или он дойдёт до конца строки, движок продолжит искать совпадение для оставшегося шаблона. Если совпадения не будет, он уменьшит количество повторов (отступит) и попробует снова.

Ленивый
: Включается с помощью знака вопроса `pattern:?` после квантификатора. Движок регулярного выражения пытается найти совпадение для оставшегося шаблона перед каждым повторением квантификатора.

Как мы увидели, ленивый режим не "панацея" от всех проблем жадного поиска. В качестве альтернативы может выступать "хорошо настроенный" жадный поиск с исключениями. Вскоре мы увидим больше таких примеров.

