# Квантификаторы +, *, ? и {n}

Давайте возьмём строку вида `+7(903)-123-45-67` и найдём все числа в ней. Но теперь нас интересуют не цифры по отдельности, а именно числа: `7, 903, 123, 45, 67`.

Число — это последовательность из 1 или более цифр `\d`. Чтобы отметить количество повторений, нам нужно указать *квантификатор*.

## Количество {n}

Самый простой квантификатор — это число в фигурных скобках: `pattern:{n}`.

Он добавляется к символу (или символьному классу, или набору `[...]` и т.д.) и указывает, сколько их нам нужно.

У него есть несколько вариантов, давайте посмотрим примеры:

Точное количество: `{5}`
: Шаблон `pattern:\d{5}` обозначает ровно 5 цифр, он эквивалентен `pattern:\d\d\d\d\d`.

    Следующий пример находит пятизначное число:

    ```js run
    alert( "Мне 12345 лет".match(/\d{5}/) ); //  "12345"
    ```

    Мы можем добавить `\b`, чтобы исключить числа длиннее: `pattern:\b\d{5}\b`.

Диапазон: `{3,5}`, от 3 до 5
: Для того, чтобы найти числа c разрядностью от 3 до 5 цифр, мы можем указать границы в фигурных скобках: `pattern:\d{3,5}`

    ```js run
    alert( "Мне не 12, а 1234 года".match(/\d{3,5}/) ); // "1234"
    ```

    Верхнюю границу можно не указывать.

    Тогда шаблон `pattern:\d{3,}` найдет последовательность чисел длиной `3` и более цифр:

    ```js run
    alert( "Мне не 12, а 345678 лет".match(/\d{3,}/) ); // "345678"
    ```

Давайте вернёмся к строке `+7(903)-123-45-67`.

Число - это последовательность из одной или более цифр. Поэтому шаблон будет `pattern:\d{1,}`:

```js run
let str = "+7(903)-123-45-67";

let numbers = str.match(/\d{1,}/g);

alert(numbers); // 7,903,123,45,67
```

## Короткие обозначения

Для самых востребованных квантификаторов есть сокращённые формы записи:

`+`
: Означает "один или более". То же самое, что и `{1,}`.

    Например, `pattern:\d+` находит числа:

    ```js run
    let str = "+7(903)-123-45-67";

    alert( str.match(/\d+/g) ); // 7,903,123,45,67
    ```

`?`
: Означает "ноль или один". То же самое, что и `{0,1}`. По сути, делает символ необязательным.

    Например, шаблон `pattern:ou?r` найдёт `match:o` после которого, возможно, следует `match:u`, а затем `match:r`.

    Поэтому шаблон `pattern:colou?r` найдёт оба: `match:color` и `match:colour`:

    ```js run
    let str = "Следует писать color или colour?";

    alert( str.match(/colou?r/g) ); // color, colour
    ```

`*`
: Означает "ноль или более". То же самое, что и `{0,}`. То есть символ может повторяться много раз или вообще отсутствовать.

    Например, шаблон `pattern:\d0*` находит цифру вместе со всеми нулями, которые идут за ней (но могут и не идти):

    ```js run
    alert( "100 10 1".match(/\d0*/g) ); // 100, 10, 1
    ```

    Сравните это с `'+'` (один или более):

    ```js run
    alert( "100 10 1".match(/\d0+/g) ); // 100, 10
    // 1 не подходит, т.к 0+ требует как минимум один ноль
    ```

## Ещё примеры

Квантификаторы используются очень часто. Они служат основными "строительными блоками" сложных регулярных выражений, поэтому давайте рассмотрим ещё примеры.

Регулярное выражение для поиска десятичных дробей (чисел с плавающей точкой): `pattern:\d+\.\d+`
: В действии:
    ```js run
    alert( "0 1 12.345 7890".match(/\d+\.\d+/g) ); // 12.345
    ```

Регулярное выражение для поиска "открывающего HTML-тега без атрибутов". Например, `<span>` или `<p>`: `pattern:/<[a-z]+>/i`
: В действии:

    ```js run
    alert( "<body> ... </body>".match(/<[a-z]+>/gi) ); // <body>
    ```

<<<<<<< HEAD
    Это регулярное выражение ищет символ `pattern:'<'`, за которым идут одна или более букв английского алфавита, а затем `pattern:'>'`.
=======
    We look for character `pattern:'<'` followed by one or more Latin letters, and then  `pattern:'>'`.
>>>>>>> b300836f00536a5eb9a716ad2cbb6b8fe97c25af

Регулярное выражение для поиска "открывающего HTML-тега без атрибутов" (улучшенный вариант): `pattern:/<[a-z][a-z0-9]*>/i`
: Здесь регулярное выражение расширено: в соответствие со стандартом, в названии HTML-тега цифра может быть на любой позиции, кроме первой, например `<h1>`.

    ```js run
    alert( "<h1>Привет!</h1>".match(/<[a-z][a-z0-9]*>/gi) ); // <h1>
    ```

Регулярное выражение для поиска "открывающего или закрывающего HTML-тега без атрибутов": `pattern:/<\/?[a-z][a-z0-9]*>/i`
: В предыдущий шаблон мы добавили необязательный слеш `pattern:/?`. Этот символ понадобилось заэкранировать, чтобы JavaScript не принял его за конец шаблона.

    ```js run
    alert( "<h1>Привет!</h1>".match(/<\/?[a-z][a-z0-9]*>/gi) ); // <h1>, </h1>
    ```

```smart header="Чтобы регулярное выражение было точнее, нам часто приходится делать его сложнее"

В этих примерах мы видим общее правило: чем точнее регулярное выражение -- тем оно длиннее и сложнее.

<<<<<<< HEAD
Например, для HTML-тегов, скорее всего, подошло бы и более простое регулярное выражение: `pattern:<\w+>`.
=======
...But because `pattern:\w` means any Latin letter or a digit or `'_'`, the regexp also matches non-tags, for instance `match:<_>`. So it's much simpler than `pattern:<[a-z][a-z0-9]*>`, but less reliable.
>>>>>>> b300836f00536a5eb9a716ad2cbb6b8fe97c25af

...Но так как класс `pattern:\w` означает любую английскую букву или цифру, или `'_'`, то для такого регулярного выражения подойдут и не теги, например `match:<_>`. То есть оно гораздо проще, чем шаблон `pattern:<[a-z][a-z0-9]*>`, но вместе с тем и менее точное.

Подойдёт ли нам `pattern:<\w+>` или нужно использовать `pattern:<[a-z][a-z0-9]*>`?

В реальной жизни допустимы оба варианта. Ответ на подобные вопросы зависит от того, насколько реально важна точность и насколько потом будет сложно или несложно отфильтровать лишние совпадения.
```
