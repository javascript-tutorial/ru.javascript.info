# Квантификаторы +, *, ? и {n}

Давайте возьмём строку вида `+7(903)-123-45-67` и найдём все числа в ней. Но теперь нас интересуют не цифры по отдельности, а именно числа: `7, 903, 123, 45, 67`.

Число — это последовательность из 1 или более цифр `pattern:\d`. Чтобы указать количество повторений, нам нужно добавить *квантификатор*.

## Количество {n}

Самый простой квантификатор — это число в фигурных скобках: `pattern:{n}`.

Он добавляется к символу (или символьному классу, или набору `[...]` и т.д.) и указывает, сколько их нам нужно.

Можно по-разному указать количество, например:

Точное количество: `pattern:{5}`
: Шаблон `pattern:\d{5}` обозначает ровно 5 цифр, он эквивалентен `pattern:\d\d\d\d\d`.

    Следующий пример находит пятизначное число:

    ```js run
    alert( "Мне 12345 лет".match(/\d{5}/) ); //  "12345"
    ```

    Мы можем добавить `pattern:\b`, чтобы исключить числа длиннее: `pattern:\b\d{5}\b`.

Диапазон: `pattern:{3,5}`, от 3 до 5
: Для того, чтобы найти числа от 3 до 5 цифр, мы можем указать границы в фигурных скобках: `pattern:\d{3,5}`

    ```js run
    alert( "Мне не 12, а 1234 года".match(/\d{3,5}/) ); // "1234"
    ```

    Верхнюю границу можно не указывать.

    Тогда шаблон `pattern:\d{3,}` найдёт последовательность чисел длиной `3` и более цифр:

    ```js run
    alert( "Мне не 12, а 345678 лет".match(/\d{3,}/) ); // "345678"
    ```

Давайте вернёмся к строке `+7(903)-123-45-67`.

Число - это последовательность из одной или более цифр. Поэтому шаблон будет `pattern:\d{1,}`:

```js run
let str = "+7(903)-123-45-67";

let numbers = str.match(/\d{1,}/g);

alert(numbers); // 7,903,123,45,67
```

## Короткие обозначения

Для самых востребованных квантификаторов есть сокращённые формы записи:

`pattern:+`
: Означает "один или более". То же самое, что и `pattern:{1,}`.

    Например, `pattern:\d+` находит числа (из одной или более цифр):

    ```js run
    let str = "+7(903)-123-45-67";

    alert( str.match(/\d+/g) ); // 7,903,123,45,67
    ```

`pattern:?`
: Означает "ноль или один". То же самое, что и `pattern:{0,1}`. По сути, делает символ необязательным.

    Например, шаблон `pattern:ou?r` найдёт `match:o` после которого, возможно, следует `match:u`, а затем `match:r`.

    Поэтому шаблон `pattern:colou?r` найдёт два варианта: `match:color` и `match:colour`:

    ```js run
    let str = "Следует писать color или colour?";

    alert( str.match(/colou?r/g) ); // color, colour
    ```

`pattern:*`
: Означает "ноль или более". То же самое, что и `pattern:{0,}`. То есть символ может повторяться много раз или вообще отсутствовать.

    Например, шаблон `pattern:\d0*` находит цифру и все нули за ней (их может быть много или ни одного):

    ```js run
    alert( "100 10 1".match(/\d0*/g) ); // 100, 10, 1
    ```

    Сравните это с `pattern:+` (один или более):

    ```js run
    alert( "100 10 1".match(/\d0+/g) ); // 100, 10
    // 1 не подходит, т.к 0+ требует как минимум один ноль
    ```

## Ещё примеры

Квантификаторы используются очень часто. Они служат основными "строительными блоками" сложных регулярных выражений, поэтому давайте рассмотрим ещё примеры.

**Регулярное выражение для десятичных дробей (чисел с плавающей точкой): `pattern:\d+\.\d+`**

В действии:
```js run
alert( "0 1 12.345 7890".match(/\d+\.\d+/g) ); // 12.345
```

**Регулярное выражение для "открывающего HTML-тега без атрибутов", например, `<span>` или `<p>`.**

1. Самое простое: `pattern:/<[a-z]+>/i`

    ```js run
    alert( "<body> ... </body>".match(/<[a-z]+>/gi) ); // <body>
    ```

    Это регулярное выражение ищет символ `pattern:'<'`, за которым идут одна или более букв латинского алфавита, а затем `pattern:'>'`.

2. Улучшенное: `pattern:/<[a-z][a-z0-9]*>/i`

    Здесь регулярное выражение расширено: в соответствие со стандартом, в названии HTML-тега цифра может быть на любой позиции, кроме первой, например `<h1>`.

    ```js run
    alert( "<h1>Привет!</h1>".match(/<[a-z][a-z0-9]*>/gi) ); // <h1>
    ```

**Регулярное выражение для "открывающего или закрывающего HTML-тега без атрибутов": `pattern:/<\/?[a-z][a-z0-9]*>/i`**

В начало предыдущего шаблона мы добавили необязательный слеш `pattern:/?`. Этот символ понадобилось заэкранировать, чтобы JavaScript не принял его за конец шаблона.

```js run
alert( "<h1>Привет!</h1>".match(/<\/?[a-z][a-z0-9]*>/gi) ); // <h1>, </h1>
```

```smart header="Чтобы регулярное выражение было точнее, нам часто приходится делать его сложнее"

В этих примерах мы видим общее правило: чем точнее регулярное выражение -- тем оно длиннее и сложнее.

Например, для HTML-тегов без атрибутов, скорее всего, подошло бы и более простое регулярное выражение: `pattern:<\w+>`. Но стандарт HTML накладывает более жёсткие ограничения на имя тега, так что более точным будет шаблон `pattern:<[a-z][a-z0-9]*>`.

Подойдёт ли нам `pattern:<\w+>` или нужно использовать `pattern:<[a-z][a-z0-9]*>`? А, может быть, нужно ещё его усложнить, добавить атрибуты?

В реальной жизни допустимы разные варианты. Ответ на подобные вопросы зависит от того, насколько реально важна точность и насколько потом будет сложно или несложно отфильтровать лишние совпадения.
```
