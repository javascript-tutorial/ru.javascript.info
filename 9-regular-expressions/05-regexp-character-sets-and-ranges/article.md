# Наборы и диапазоны [...]

Несколько символов или символьных классов в квадратных скобках `[…]` означают "искать любой символ из заданных".

## Наборы

Для примера, `pattern:[eao]` означает любой из 3-х символов: `'a'`, `'e'` или `'o'`.

Это называется *набором*.

Наборы могут использоваться в регулярных выражениях вместе с обычными символами, например:

```js run
// найти [t или m], после которых идёт "op"
alert( "Mop top".match(/[tm]op/gi) ); // "Mop", "top"
```

Обратите внимание, что в наборе несколько символов, но в результате он соответствует ровно одному символу.

Так что этот пример не даёт совпадений:

```js run
alert( "Voila".match(/V[oi]la/) ); // null, нет совпадений
// ищет "V", затем [o или i], потом "la"
// а в строке V, потом o, потом i
```

Шаблон ищет:

- `pattern:V`,
- затем *один* из символов `pattern:[oi]`,
- потом `pattern:la`.

В этом случае совпадениями могут быть `match:Vola` или `match:Vila`.

## Диапазоны

Ещё квадратные скобки могут содержать *диапазоны символов*.

К примеру, `pattern:[a-z]` соответствует символу в диапазоне от `a` до `z`, или `pattern:[0-5]` -- цифра от `0` до `5`.

В приведённом ниже примере мы ищем `"x"`, за которым следуют две цифры или буквы от `A` до `F`:

```js run
alert( "Exception 0xAF".match(/x[0-9A-F][0-9A-F]/g) ); // xAF
```

Здесь в `pattern:[0-9A-F]` сразу два диапазона: ищется символ, который либо цифра от `0` до `9`, либо буква от `A` до `F`.

Кстати, заметим, что в слове `subject:Exception` выше есть подстрока `subject:xce`. Она не соответствует шаблону, потому что буквы строчные, а в наборе `pattern:[0-9A-F]` они прописные.

Если мы хотим найти буквы и в верхнем и в нижнем регистре, то мы можем добавить ещё диапазон `a-f`: `pattern:[0-9A-Fa-f]`. Или поставить у регулярного выражения флаг `i`.

**Символьные классы являются сокращениями для определённых наборов символов.**

Например:

- **\d** -- то же самое, что и `pattern:[0-9]`,
- **\w** -- то же самое, что и `pattern:[a-zA-Z0-9_]`,
- **\s** -- то же самое, что и `pattern:[\t\n\v\f\r ]`, плюс несколько других символов Юникода.

Также мы можем использовать символьные классы внутри `[…]`.

Например, мы хотим найти символ, используемый в словах `pattern:\w` или тире `pattern:-`, то набор будет: `pattern:[\w-]`.

Можем использовать и несколько классов вместе, например `pattern:[\s\w]` означает "пробельный символ или цифра".

## Исключающие диапазоны

Помимо обычных диапазонов, есть "исключающие" диапазоны, которые выглядят как `pattern:[^…]`.

Они обозначаются символом каретки `^` в начале диапазона и соответствуют любому символу *за исключением заданных*.

Например:

- `pattern:[^aeyo]` -- любой символ, за исключением `'a'`, `'e'`, `'y'` или `'o'`.
- `pattern:[^0-9]` -- любой символ, за исключением цифры, то же, что и `pattern:\D`.
- `pattern:[^\s]` -- любой непробельный символ, то же, что и `pattern:\S`.

Пример ниже ищет любые символы, кроме латинских букв, цифр и пробелов:

```js run
alert( "alice15@gmail.com".match(/[^\d\sA-Z]/gi) ); // @ и .
```

## Внутри […] экранировать не нужно

Обычно, когда мы хотим найти специальный символ, например, точку, нам нужно экранировать её как `pattern:\.`. А если нам нужна обратная косая черта, тогда используем `pattern:\\`, т.п.

В квадратных скобках большинство специальных символов можно использовать без экранирования:

- Точка `pattern:'.'`.
- Плюс `pattern:'+'`.
- Круглые скобки `pattern:'( )'`.
- Тире `pattern:'-'` в начале или в конце (где оно не задаёт диапазон).
- Символ каретки `pattern:'^'`, если не в начале (где это означает исключение).
- И открывающая квадратная скобка `pattern:'['`.

Другими словами, разрешены все специальные символы, кроме случаев, когда они означают что-то особое для диапазонов.

Точка `"."` внутри квадратных скобок -- просто точка. Шаблон `pattern:[.,]` будет искать один из символов: точку или запятую.

В приведённом ниже примере регулярное выражение `pattern:[-().^+]` ищет один из символов `-().^+`:

```js run
// Нет необходимости в экранировании
let reg = /[-().^+]/g;

alert( "1 + 2 - 3".match(reg) ); // Совпадения +, -
```

...Впрочем, если вы решите экранировать "на всякий случай", то не будет никакого вреда:

```js run
// Экранирование всех возможных символов
let reg = /[\-\(\)\.\^\+]/g;

alert( "1 + 2 - 3".match(reg) ); // также работает: +, -
```
