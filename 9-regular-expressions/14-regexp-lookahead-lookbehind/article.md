# Опережающие и ретроспективные проверки

В некоторых случаях нам нужно найти соответствие шаблону, за которым следует другой шаблон. Например, мы хотим получить цену одной индейки в строке: `subject:1 индейка стоит 30€`. 

Нам нужно число (здесь предположим, что в цена - целое число, без десятичной точки), после которого следует знак валюты `subject:€`.

Именно для таких задач и существует опережающая проверка.

## Опережающая проверка

Синтаксис: `pattern:x(?=y)`
Пояснение: найди `pattern:х` при условии, что за ним следует `pattern:y`.

Для целого числа, за которым идёт знак `subject:€`, шаблон регулярного выражения будет `pattern:\d+(?=€)`:

```js run
let str = "1 индейка стоит 30€";

alert( str.match(/\d+(?=€)/) ); // 30 (число 1 было проигнорировано, так как за ним НЕ следует `subject:€`)
```

Допустим, нам нужно узнать количество индеек, которое можно купить за 30€ - это число, за которым НЕ следует знак `subject:€`.

Для этой задачи мы можем применить негативную опережающую проверку.

Синтаксис: `pattern:x(?!y)`
Пояснение: найди такой `pattern:х`, за которым НЕ следует `pattern:y`.

```js run
let str = "2 индейки стоят 60€";

alert( str.match(/\d+(?!€)/) ); // 2 (в этот раз была проигнорирована цена)
```

## Ретроспективная проверка

Опережающие проверки позволяют задавать условия на то, что "идёт после".

Ретроспективная проверка выполняет такую же функцию, но с просмотром назад. Другими словами, она находит соответствие шаблону, только если перед ним есть что-то заранее определённое.

Синтаксис:
- Позитивная ретроспективная проверка: `pattern:(?<=y)x`, выдаёт совпадение на `pattern:x` при условии, что перед ним ЕСТЬ `pattern:y`.
- Негативная ретроспективная проверка: `pattern:(?<!y)x`, выдаёт совпадение на `pattern:x` при условии, что перед ним НЕТ `pattern:y`.

Чтобы протестировать ретроспективную проверку, давайте поменяем валюту на доллары США. Знак доллара обычно ставится перед суммой денег, поэтому для того чтобы найти `$30`, мы используем `pattern:(?<=\$)\d+` - число, перед которым идёт `subject:$`:

```js run
let str = "1 индейка стоит $30";

alert( str.match(/(?<=\$)\d+/) ); // 30 (одинокое число игнорируется)
```

Если нам необходимо найти количество индеек -- число, перед которым не идёт `subject:$`, мы можем использовать негативную ретроспективную проверку `pattern:(?<!\$)\d+`:

```js run
let str = "2 индейки стоят $60";

alert( str.match(/(?<!\$)\d+/) ); // 2 (проигнорировалась цена)
```

## Захват групп

Как правило, то что находится внутри скобок, задающих опережающую и ретроспективную проверку, не включается в результат совпадения.

Например, в шаблоне `pattern:\d+(?=€)` знак `pattern:€` не будет включён в результат. Это логично, ведь мы ищем число `pattern:\d+`, а `pattern:(?=€)` - это всего лишь проверка, что за ним идёт знак `subject:€`.

Но в некоторых ситуациях нам может быть интересно захватить и то, что в проверке. Для этого нужно обернуть это в дополнительные скобки.

В следующем примере знак валюты `pattern:(€|kr)` будет включён в результат вместе с суммой:

```js run
let str = "1 индейка стоит 30€";
let reg = /\d+(?=(€|kr))/; // добавлены дополнительные скобки вокруг €|kr

alert( str.match(reg) ); // 30, €
```

Тоже самое можно применить к ретроспективной проверке:

```js run
let str = "1 индейка стоит $30";
let reg = /(?<=(\$|£))\d+/;

alert( str.match(reg) ); // 30, $
```

Обратите внимание, что порядок выдачи результата ретроспективной проверки остаётся прежним, хотя скобки из опережающей проверки расположены ПЕРЕД основным шаблоном.

Обычно совпадения с выражениями в скобках нумеруются по порядку -- слева направо. Однако, ретроспективная проверка является исключением, так как при ней совпадение с выражением в скобках всегда идёт после результата основного шаблона. Так, в нашем примере совпадение с основным шаблоном `pattern:\d+` будет идти первым, а результат для `pattern:(\$|£)` будет вторым.

## Итого

Опережающая и ретроспективная проверки удобны, когда мы хотим искать шаблон по дополнительному условию на контекст, в котором он находится.

Для простых регулярных выражений мы можем сделать похожую вещь "вручную". То есть, найти все совпадения, независимо от контекста, а затем в цикле отфильтровать подходящие.

Как мы помним, что `str.matchAll` и `reg.exec` возвращают совпадения со свойством `.index`, поэтому мы знаем их точное расположение в тексте и можем посмотреть на контекст.
Но обычно регулярные выражения удобнее.

Виды проверок:

| Паттерн            | Тип                        | Совпадение                      |
|--------------------|----------------------------|---------------------------------|
| `pattern:x(?=y)`   | Позитивная опережающая     | `x`, если за ним следует `y`    |
| `pattern:x(?!y)`   | Негативная опережающая     | `x`, если за ним НЕ следует `y` |
| `pattern:(?<=y)x`  | Позитивная ретроспективная | `x`, если следует за `y`        |
| `pattern:(?<!y)x`  | Негативная ретроспективная | `x`, если НЕ следует за `y`     |

Опережающая проверка также может быть использована, чтобы отключить возврат при поиске. Для чего нам это может понадобиться и другие детали, вы узнаете в следующей главе.
