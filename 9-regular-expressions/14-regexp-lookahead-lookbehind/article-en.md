# Опережающие и ретроспективные проверки

В некоторых случаях, нам нужен паттерн, который следует за опеределённым паттерном. Например, нам нужно найти цену одной индейки из строки `subject:1 индейка стоит 30€`.

Следовательно, нам нужно число (в данном примере - это целое число), после которого следует знак валюты `subject:€`.

Именно для таких задач и существует опережающая проверка.

## Опережающая проверка

Синтаксис: `pattern:x(?=y)`
Пояснение: найди такой `pattern:х`, за которым обязательно следует `pattern:y`.

Следовательно, в данном примере регулярное выражение для суммы денег, которая следует за `subject:€` будет `pattern:\d+(?=€)`:

```js run
let str = "1 индейка стоит 30€";

alert( str.match(/\d+(?=€)/) ); // 30 (число 1 было проигнорировано, так как за ним НЕ следует `subject:€`)
```

Допустим, в этот раз нам нужно узнать количество индеек, которое можно купить за 30€ - число, за которым НЕ следует `subject:€`.

Для этой задачи мы можем применить негативную опережающую проверку.

Синтаксис: `pattern:x(?!y)`
Пояснение: найди такой `pattern:х`, за которым НЕ следует `pattern:y`.

```js run
let str = "2 индейки стоят 60€";

alert( str.match(/\d+(?!€)/) ); // 2 (в этот раз была проигнорирована цена)
```

## Ретроспективная проверка

Пользуясь опережающей проверкой, мы можем добавить условие об элементе, "который идёт после".

Ретроспективная проверка выполняет такую же функцию, но с просмотром назад. Другими словами, она позволяет найти паттерн, только если перед ним идёт определённый паттерн.

Синтаксис:
- Позитивная ретроспективная проверка: `pattern:(?<=y)x`, выдаёт совпадение на `pattern:x`, при условии, что перед ним ЕСТЬ `pattern:y`.
- Негативная ретроспективная проверка: `pattern:(?<!y)x`, выдаёт совпадение на `pattern:x`, при условии, что перед ним НЕТ `pattern:y`.

Чтобы протестировать ретроспективную проверку, давайте поменяем валюту на доллары США. Знак доллара обычно ставится перед суммой денег, поэтому для того чтобы найти `$30`, мы используем `pattern:(?<=\$)\d+`, так как это даст нам сумму перед `subject:$`.

```js run
let str = "1 индейка стоит $30";

alert( str.match(/(?<=\$)\d+/) ); // 30 (проигнорировалось число 1)
```

Если нам необходимо найти количество индеек - число, которое идёт перед `subject:$`, мы можем использовать негативную ретроспективную проверку `pattern:(?<!\$)\d+`:

```js run
let str = "2 индейки стоят $60";

alert( str.match(/(?<!\$)\d+/) ); // 2 (проигнорировалась цена)
```

## Захват групп

Как правило, то что находится внутри lookaround (общее наименование для опережающей и ретроспективной проверок), не включается в результат совпадения.

Например, в паттерне `pattern:\d+(?!€)` знак `pattern:€` не будет захвачен в результат совпадения.

Однако, существует способ, чтобы захватить весь lookaround или же его часть. Нам всего лишь нужно заключить lookaround в дополнительные скобки.

Например, в нижеследующем случае, валюта `pattern:(€|kr)` будет захвачена также как и сумма:

```js run
let str = "1 индейка стоит 30€";
let reg = /\d+(?=(€|kr))/; // добавлены дополнительные скобки вокруг €|kr

alert( str.match(reg) ); // 30, €
```

Тоже самое можно применить к ретроспективной проверке:

```js run
let str = "1 индейка стоит $30";
let reg = /(?<=(\$|£))\d+/;

alert( str.match(reg) ); // 30, $
```

Обратите внимание, что порядок выдачи результата ретроспективной проверки идентичен порядку опережающей проверки, несмотря на то, что в опережающей проверке скобки расположены ПЕРЕД главным паттерном.

Обычно, порядок действия в случае наличия скобок - это слева направо. Однако, ретроспективная проверка является исключением, её порядок захвата всегда идёт ПОСЛЕ главного паттерна. Поэтому, в данном примере, результат совпадения для `pattern:\d+` будет идти первым, а результат для `pattern:(\$|£)` будет вторым.

## Итого

Опережающая и ретроспективная проверки (обычно их называют lookaround) удобны для простых регулярных выражений, когда мы не хотим включать определённый паттерн в совпадение в зависимости от контекста до или после.

В некоторых случаях, мы можем сделать это вручную - использовать match all и потом отфильтровать по контексту в цикле.
Важно не забывать, что `str.matchAll` и `reg.exec` возвращают совпадения с `.index` проперти, поэтому мы знаем его точное расположение.
Однако, для таких заданий лучше использовать регулярные выражения.

Виды lookaround:

| Паттерн            | Тип                        | Совпадение                      |
|--------------------|----------------------------|---------------------------------|
| `pattern:x(?=y)`   | Позитивная опережающая     | `x`, если за ним следует `y`    |
| `pattern:x(?!y)`   | Негативная опережаюшая     | `x`, если за ним НЕ следует `y` |
| `pattern:(?<=y)x`  | Позитивная ретроспективная | `x`, если следует за `y`        |
| `pattern:(?<!y)x`  | Негативная ретроспективная | `x`, если НЕ следует за `y`     |

Опережающая проверка также может быть использована, чтобы отключить возвраты. Для чего нам это может понадобиться, вы узнаете в следующей главе.
