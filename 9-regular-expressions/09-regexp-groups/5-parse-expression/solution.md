Регулярное выражение для числа: `pattern:-?\d+(\.\d+)?`. Мы создали его в предыдущих задачах.

Регулярное выражение для оператора `pattern:[-+*/]`. Мы вставили тире `pattern:-` в начало выражения, потому что в середине этот символ будет означать диапазон, а нам это не нужно.

Отметим, что косая черта должна быть экранирована внутри регулярного выражения JavaScript `pattern:/.../`.

Нам необходимо число, оператор и, затем, другие числа. И необязательные символы пробела между ними.

Полное выражение: `pattern:-?\d+(\.\d+)?\s*[-+*/]\s*-?\d+(\.\d+)?`.

Для получения результата в виде массива давайте вставим скобки вокруг данных, которые нам необходимы: чисел и операторов: `pattern:(-?\d+(\.\d+)?)\s*([-+*/])\s*(-?\d+(\.\d+)?)`.

В действии:

```js run
let reg = /(-?\d+(\.\d+)?)\s*([-+*\/])\s*(-?\d+(\.\d+)?)/;

alert( "1.2 + 12".match(reg) );
```

Результат `result` включает в себя:

- `result[0] == "1.2 + 12"` (полное совпадение)
- `result[1] == "1.2"` (первая группа `(-?\d+(\.\d+)?)` -- первое число, включая десятичную часть)
- `result[2] == ".2"` (вторая группа `(\.\d+)?` -- первая десятичная часть)
- `result[3] == "+"` (третья группа `([-+*\/])` -- оператор)
- `result[4] == "12"` (чертвертая группа `(-?\d+(\.\d+)?)` -- второе число)
- `result[5] == undefined` (пятая группа `(\.\d+)?` -- вторая десятичная часть отсутствует, поэтому значение `undefined`)

Нам необходимы только числа и оператор без полного совпадения или десятичной части.

Полное совпадение (первый элемент массива) может быть удален при помощи сдвига массива `pattern:result.shift()`.

От десятичных групп можно избавиться, если исключить захват скобочной группы, добавив `pattern:?:` в начало: `pattern:(?:\.\d+)?`.

Итоговое решение:

```js run
function parse(expr) {
  let reg = /(-?\d+(?:\.\d+)?)\s*([-+*\/])\s*(-?\d+(?:\.\d+)?)/;

  let result = expr.match(reg);

  if (!result) return [];
  result.shift();

  return result;
}

alert( parse("-1.23 * 3.45") );  // -1.23, *, 3.45
```
