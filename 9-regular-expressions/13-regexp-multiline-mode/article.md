# Многострочный режим, флаг "m"

Многострочный режим включается флагом `pattern:/.../m`.

В этом случае изменяется поведение `pattern:^` и `pattern:$`.

В многострочном режиме они означают не только начало/конец текста, но и начало/конец строки.

## Начало строки ^

В примере ниже текст состоит из нескольких строк. Паттерн `pattern:/^\d+/gm` берёт число с начала каждой строки:

```js run
let str = `1е место: Винни
2е место: Пятачок
33е место: Слонопотам`;

*!*
alert( str.match(/^\d+/gm) ); // 1, 2, 33
*/!*
```

Обратим внимание -- без флага  `pattern:/.../m` было бы найдено только первое число:


```js run
let str = `1е место: Винни
2е место: Пятачок
33е место: Слонопотам`;

*!*
alert( str.match(/^\d+/g) ); // 1
*/!*
```

Так происходит, потому что в обычном режиме каретка `pattern:^` -- это только начало текста, а в многострочном -- начало любой строки.

Движок регулярных выражений двигается по тексту в поисках строки, начинающейся с `pattern:^`, и как находит -- продолжает искать в ней `pattern:\d+`.

## Конец строки $

Символ доллара `pattern:$` ведёт себя аналогично.

Регулярное выражение `pattern:\w+$` ищет последнее слово в каждой строке

```js run
let str = `1е место: Винни
2е место: Пятачок
33е место: Слонопотам`;

alert( str.match(/\w+$/gim) ); // Винни,Пятачок,Слонопотам
```

Без флага `pattern:/.../m` якорь `pattern:$` обозначал бы конец всей строки, и было бы найдено только последнее слово.

## Якорь ^$ против \n

Для того, чтобы найти конец строки, можно использовать не только `pattern:^` и `pattern:$`, но и символ перевода строки `\n`.

Но, в отличие от `pattern:$`, движок регулярных выражений берёт символ `\n` в результат.

Используем его в нашем примере вместо `pattern:$`:

```js run
let str = `1е место: Винни
2е место: Пятачок
33е место: Слонопотам`;

alert( str.match(/\w+\n/gim) ); // Винни\n,Пятачок\n
```

Здесь каждое совпадение -- это слово плюс символ перевода строки.

Ещё одно отличие -- символ перевода строки `\n` не обязательно является концом строки. Вот почему слово `Слонопотам` не вывелось в примере выше.

Таким образом, использование якорей обычно лучше и точнее соответствуют тому, что мы хотим получить в результате.
