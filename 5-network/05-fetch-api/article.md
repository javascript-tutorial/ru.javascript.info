# Fetch API

На данный момент мы знаем достаточно про fetch.

Теперь давайте рассмотрим оставшуюся часть API, чтобы охватить все его возможности.

Нижеследующий список - это все возможные опции для fetch с соответствующими значениями по умолчанию (в комментариях указаны все возможные значения):

```js
let promise = fetch(url, {
  method: "GET", // POST, PUT, DELETE, etc.
  headers: {
    "Content-Type": "text/plain;charset=UTF-8" // если телом запроса является строка, это значение будет зависеть от её формата
  },
  body: undefined // string, FormData, Blob, BufferSource или URLSearchParams
  referrer: "about:client", // "" в случае no-referrer, или URL текущего источника
  referrerPolicy: "no-referrer-when-downgrade", // no-referrer, origin, same-origin...
  mode: "cors", // same-origin, no-cors
  credentials: "same-origin", // omit, include
  cache: "default", // no-store, reload, no-cache, force-cache или only-if-cached
  redirect: "follow", // manual, error
  integrity: "", // контрольная сумма, например "sha256-abcdef1234567890"
  keepalive: false, // true
  signal: undefined, // AbortController, чтобы прервать запрос
  window: window // null
});
```

Довольно-таки внушительный список, не так ли?

В главе <info:fetch-basics> мы полностью охватили `методы`, `заголовки` и `тело ответа`.

Опцию `signal` мы объяснили в <info:fetch-abort>.

А теперь давайте пройдёмся по оставшимся опциям.

## referrer, referrerPolicy

Данные опции определяют, как `fetch` устанавливает HTTP-заголовок `Referer`.

В заголовке указывается URL-адрес страницы, с которой пришёл запрос. В большинстве случаев это не играет такой важной роли для передачи информации, однако в некоторых случаях, из-за угрозы безопасности, адрес лучше убрать или модифицировать.  

**Опция `referrer` позволяет установить любой` Referer` в пределах текущего источника или же отключить его.**

Чтобы не отправлять referer, нужно дать ему значение пустой строки:
```js
fetch('/page', {
*!*
  referrer: "" // отсутствует Referer заголовок
*/!*
});
```

Для того, чтобы установить другой URL-адрес для текущего источника:

```js
fetch('/page', {
  // предположим, что мы находимся на странице https://javascript.info
  // мы можем установить любое значение Referer, при условии что оно принадлежит текущему источнику
*!*
  referrer: "https://javascript.info/anotherpage"

*/!*
});
```

**Опция `referrerPolicy` устанавливает общие правила для `Referer`.**

Возможные значения описаны в [спецификации Referrer Policy](https://w3c.github.io/webappsec-referrer-policy/):

- **`"no-referrer-when-downgrade"`** -- значение по умолчанию: `Referer` отправляется всегда, если только мы не отправим запрос из HTTPS в HTTP (из более безопасного протокола в менее безопасный).
- **`"no-referrer"`** -- никогда не отправлять `Referer`.
- **`"origin"`** -- отправлять в `Referer` только текущий источник, а не полный URL-адрес страницы, например, послать `http://site.com`, вместо `http://site.com/path`.
- **`"origin-when-cross-origin"`** -- отправлять полный referrer для запросов в пределах текущего источника, но для кроссдоменных запросов отправлять только само значение источника
- **`"same-origin"`** -- отправлять полный referrer для запросов в пределах текущего источника, а для кроссдоменных запросов не отправлять referer вообще.
- **`"strict-origin"`** -- отправлять только значение источника, не отправлять referrer для HTTPS→HTTP запросов.
- **`"strict-origin-when-cross-origin"`** -- для запросов в пределах текущего источника отправлять полный referrer, для кроссдоменных запросов отправлять только значение источника, в случае HTTPS→HTTP запросов не отправлять ничего. 
- **`"unsafe-url"`** -- всегда отправлять полный URL-адрес в `Referer`.

Допустим, у нас есть админка со структурой URL, которая должна быть недоступна извне.

Если мы отправляем кроссдоменный запрос fetch, то по умолчанию, он отправит заголовок `Referer` с полным URL-адресом нашей админки (исключение - это когда мы делаем запрос от HTTPS в HTTP, в таком случае `Referer` не будет отправляться).

Например, `Referer: https://javascript.info/admin/secret/paths`.

Если же мы хотим полностью скрыть referrer:

```js
fetch('https://another.com/page', {
  referrerPolicy: "no-referrer" // no Referer - даёт такой же результат как и referrer: ""
});
```

В противном случае, если мы хотим, чтобы удалённая сторона знала домен откуда поступает запрос, мы можем отправить только часть «источника» URL-адреса:

```js
fetch('https://another.com/page', {
  referrerPolicy: "strict-origin" // Referer: https://javascript.info
});
```

## mode

Опция `mode` - это надёжная защита от кроссдоменных запросов:

- **`"cors"`** -- стоит по умолчанию, позволяет делать кроссдоменные запросы так, как описано в <info:fetch-кроссдомен>,
- **`"same-origin"`** -- кроссдоменные запросы запрещены,
- **`"no-cors"`** -- разрешены только простые кроссдоменные запросы.

Это может пригодиться, если URL-адрес для fetch приходит от третьего лица, и нам нужно что-то, чтобы контролировать ограничение кроссдоменных возможностей - эдакий "выключатель".

## credentials

Опция `credentials` может указывать должен ли `fetch` отправлять cookies и аутентификационные заголовки HTTP вместе с запросом.

- **`"same-origin"`** -- стоит по умолчанию, не отправлять для кроссдоменных запросов,
- **`"include"`** -- отправлять всегда, но при этом необходимы `Access-Control-Allow-Credentials` заголовки в ответе от кроссдоменного сервера,
- **`"omit"`** -- не отправлять ни при каких обстоятельствах, даже для запросов, сделанных в пределах текущего источника.

## Кэш

По умолчанию, `fetch` делает запросы используя стандартный HTTP-кэшинг. То есть, он учитывает заголовки `Expires`, `Cache-Control`, отправляет `If-Modified-Since` и так далее. Так же, как и обычные HTTP-запросы.

Опция `кэш` позволяет игнорировать HTTP-кэш или же настроить их использование:

- **`"default"`** -- `fetch` будет использовать стандартные правила и заголовки HTTP кэширования;
- **`"no-store"`** -- полностью игнорировать HTTP-кэш, этот режим становится режимом по умолчанию, если присутствуют такие заголовки как `If-Modified-Since`, `If-None-Match`, `If-Unmodified-Since`, `If-Match`, или `If-Range`;
- **`"reload"`** -- не брать результат из HTTP-кеша (даже при его присутствии), но сохранить ответ в кэше (если это дозволено заголовками ответа);
- **`"no-cache"`** -- в случае, если существует кэшированный ответ - создать условный запрос, в противном же случае - обычный запрос. Сохранить ответ в  HTTP-кэше;
- **`"force-cache"`** -- использовать ответ из HTTP-кеша, даже если он устаревший. Если же ответ в HTTP-кэше отсутствует, сделать обычный HTTP-запрос, действовать как обычно;
- **`"only-if-cached"`** -- использовать ответ из HTTP-кеша, даже если он устаревший. Если же ответ в HTTP-кэше отсутствует, тогда выдаётся ошибка. Это работает только когда `mode` установлен в `"same-origin"`.

## Перенаправление

Обычно, `fetch` следует таким HTTP-перенаправлениям, как 301, 302 и так далее.

Это можно поменять при помощи опции `redirect`:

- **`"follow"`** -- стоит по умолчанию, следовать HTTP-перенаправлениям,
- **`"error"`** -- ошибка в случае HTTP-перенаправления,
- **`"manual"`** -- не следовать HTTP-перенаправлению, но установить адрес перенаправления в `response.url`, а `response.redirected` будет иметь значение `true`, чтобы мы могли сделать перенаправление на новый адрес вручную.

## integrity

Опция `integrity` позволяет проверить, соответствует ли ответ известной заранее контрольной сумме.

Как описано в [спецификации] (https://w3c.github.io/webappsec-subresource-integrity/), поддерживаемыми хеш-функциями являются SHA-256, SHA-384 и SHA-512. В зависимости от браузера, могут быть и другие.

Например, мы скачиваем файл, и мы точно знаем, что контрольная сумма его SHA-256 равна "abc" (разумеется, настоящая контрольная сумма будет длиннее).

Мы можем добавить это в опцию `integrity` вот так:

```js
fetch('http://site.com/file', {
  integrity: 'sha256-abd'
});
```

Затем `fetch` самостоятельно вычислит SHA-256 и сравнит его с нашей строкой. В случае несоответствия срабатывает ошибка.

## keepalive

Опция `keepalive` указывает на то, что запрос может пережить страницу.

Например, для улучшения опыта взаимодействия мы собираем статистические данные о том, как посетитель ведёт себя на нашей странице (на что он кликает, части страницы, которые он просматривает).

Когда посетитель покидает нашу страницу - мы хотим сохранить это на нашем сервере.

Для этого мы можем использовать `window.onunload`:

```js run
window.onunload = function() {
  fetch('/analytics', {
    method: 'POST',
    body: "statistics",
*!*
    keepalive: true
*/!*
  });
};
```

Обычно, когда документ выгружен, все связанные с ним сетевые запросы прерываются. Но опция `keepalive` указывает браузеру выполнять запрос в фоновом режиме даже после того, как пользователь покидает страницу. Поэтому важно, чтобы наш запрос был успешным.

- Мы не можем посылать мегабайты: лимит тела для запроса с keepalive - 64Кбайт.
    - Если мы собрали достаточно данных, мы можем отправлять их регулярно, и это не будет большой нагрузкой для запроса при "onunload".
    - Этот лимит распространяется на все текущие запросы. Однако, мы можем обойти -- это правило, послав 100 запросов одновременно - каждый по 64Кбайт.
- Мы не получим ответ от сервера, если запрос сделан при `onunload`: так как в тот момент документ уже выгружен.
    - Обычно сервер посылает пустой ответ на такие запросы, так что это не является проблемой.
