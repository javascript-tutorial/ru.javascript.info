# Длинные опросы

Длинный опрос - это самый простой способ поддерживать постоянное соединение с сервером, не используя при этом никаких специфических протоколов (типа WebSocket или Server Side Events).

Его очень легко реализовать, и он хорошо подходит для многих задач.

## Частые опросы

Самый простой способ получать новую информацию от сервера - частый опрос.

То есть, периодические запросы на сервер вида: "Привет, я здесь, у вас есть какая-нибудь информация для меня?". Например, раз в 10 секунд.

В ответ сервер, во-первых, помечает у себя, что клиент онлайн, а во-вторых посылает сообщение, в котором в специальном формате содержится весь пакет сообщений, накопившихся к данному моменту.

Это работает, но есть и недостатки:
1. Сообщения передаются с задержкой до 10 секунд (между запросами).
2. Даже если сообщений нет, сервер "атакуется" запросами каждые 10 секунд. С точки зрения производительности, это довольно большая нагрузка для бэкэнда.

Так что, если речь идет об очень маленьком сервисе, подход может оказаться жизнеспособным.

Но в целом он нуждается в улучшении.

## Длинные опросы

"Длинные опросы" - гораздо лучший способ взаимодействия с сервером.

Они также очень просты в реализации, и сообщения доставляются без задержек.

Как это происходит:

1. Запрос отправляется на сервер.
2. Сервер не закрывает соединение, пока не получит сообщение.
3. Когда появляется сообщение - сервер отвечает на запрос, посылая данные.
4. Браузер немедленно делает новый запрос.

Для данного метода ситуация, когда браузер отправил запрос и удерживает соединение с сервером, ожидая ответа, является стандартной. Соединение прерывается только доставкой сообщений.

![](long-polling.svg)

Если соединение будет потеряно, скажем, из-за сетевой ошибки, браузер немедленно посылает новый запрос.

Примерный код клиентской функции `subscribe`, которая реализует длинные опросы:

```js
async function subscribe() {
  let response = await fetch("/subscribe");

  if (response.status == 502) {
    // Таймаут соединения; возможен, когда соединение ожидало слишком долго
    // и сервер (или промежуточный прокси) закрыл его
    // давайте восстановим связь
    await subscribe();
  } else if (response.status != 200) {
    // Показать ошибку
    showMessage(response.statusText);
    // Подключиться снова через секунду.
    await new Promise(resolve => setTimeout(resolve, 1000));
    await subscribe();
  } else {
    // Получить сообщение
    let message = await response.text();
    showMessage(message);
    await subscribe();
  }
}

subscribe();
```

Функция `subscribe()` делает запрос, затем ожидает ответ, обрабатывает его и снова вызывает сама себя.

```warn header="Сервер должен поддерживать много ожидающих соединений."
Архитектура сервера должна быть способна работать со многими ожидающими подключениями.

Некоторые серверные архитектуры запускают отдельный процесс для каждого соединения. Для большого количества соединений будет столько же процессов, и каждый процесс занимает значительный обьём памяти. Так много соединений просто поглотят всю память.

Часто такая проблема возникает с бэкендами, написанными на PHP или Ruby, но технически дело не в языке, а скорее в реализации.

Бэкенды, написанные с помощью Node.js, обычно не имеют таких проблем.
```

## Демо: чат

Демо:

[codetabs src="longpoll" height=500]

## Область применения

Длинные опросы прекрасно работают, когда сообщения приходят редко.

Если сообщения приходят очень часто, то схема приёма-отправки сообщений, приведённая выше, становится похожей на "пилу".

Каждое сообщение - это отдельный запрос, с заголовками, аутентификацией и так далее.

Поэтому в данном случае предпочтительнее использовать другой метод, такой как [Websocket](info:websocket) или [Server Sent Events](info:server-sent-events).
