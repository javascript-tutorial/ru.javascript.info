# Основые события мыши

События мыши вызывают не только "манипуляторы мыши". Они также эмулируются на сенсорных устройствах, для того чтобы сделать их совместимыми.

В этой главе мы более детально разберем события мыши и рассмотрим их свойства.

## Типы событий мыши

События мыши можно разделить на две категории: "простые" и "комплексные"

### Простые события

Наиболее часто используемые простые события:

`mousedown/mouseup`
: Кнопка мыши нажата/отпущена над элементом.

`mouseover/mouseout`
: Указатель мыши появился/ушел с элемента.

`mousemove`
: Каждое движение мыши над элементом вызывает это событие.

...Есть еще несколько типов событий, мы рассмотрим их позже.

### Комплексные события

`click`
: Вызывается при клике мышью, то есть при `mousedown`, а затем `mouseup` на одном элементе, если была использована левая кнопка мыши.

`contextmenu`
: Вызывается при `mousedown` правой кнопкой мыши по элементу.

`dblclick`
: Вызывается при двойном клике по элементу.

Комплексные события состоят из простых, так что в теории, мы могли бы обходится и без них. Но они значительно облегчают нашу жизнь.

### Порядок срабатывания событий

Одно действие может вызывать несолько событий.

Например, клик мыши сперва вызывает событие `mousedown`, когда кнопка мыши была нажата, потом `mouseup` и `click`, когда кнопка была отпущена.

В случаях, когда одно действие инициирует несколько событий, их порядок фиксируется. То есть обработчики вызываются в порядке `mousedown` -> `mouseup` -> `click`. События обрабатываются в той же последовательности: `onmouseup` завершается до запуска `onclick`.

```online
Кликните по кнопке ниже, чтобы увидеть в каком порядке срабатывают события. Попробуйте также двойной клик.

На тест-стенде ниже все события мыши записываются, а если между событиями проходит больше 1 секунды, они разделяются горизонтальной линией.

Так же мы можем видеть свойство `which`, которое показывает какая именно кнопка мыши была использована.

<input onmousedown="return logMouse(event)" onmouseup="return logMouse(event)" onclick="return logMouse(event)" oncontextmenu="return logMouse(event)" ondblclick="return logMouse(event)" value="Click me with the right or the left mouse button" type="button"> <input onclick="logClear('test')" value="Clear" type="button"> <form id="testform" name="testform"> <textarea style="font-size:12px;height:150px;width:360px;"></textarea></form>
```

## Получение информации о кнопке: which

События, связанные с кликом, всегда имеют свойство `which`, которое позволяет определить точную кнопку мыши.

Это свойство не используется для событий `click` и `contextmenu`, потому что первое событие происходит только при нажатии левой кнопки, а второе соответственно только при нажатии правой.

Но если мы отслеживаем `mousedown` и `mouseup`, тогда нам нужно это знать, потому что эти события срабатывают на нажатие любой кнопки мыши. В таком случае `which`, например, позволяет нам отличать нажатие левой кнопки от правой.

Возможны следующие значения:

- `event.which == 1` -- левая кнопка
- `event.which == 2` -- средняя кнопка
- `event.which == 3` -- правая кнопка

Средняя кнопка мыши используется гораздо реже остальных.

## Модификаторы: shift, alt, ctrl и meta

 Во всех событиях мыши присутствует информация о нажатых клавишах-модификаторах.
 
 Соответствующие свойства:

- `shiftKey`
- `altKey`
- `ctrlKey`
- `metaKey` (`key:Cmd` для Mac)

Например, кнопка ниже сработает только на `key:Alt+Shift`+клик:

```html autorun height=60
<button id="button">Alt+Shift+Кликни меня!</button>

<script>
  button.onclick = function(event) {
*!*
    if (event.altKey && event.shiftKey) {
*/!*
      alert('Урааа!');
    }
  };
</script>
```

```warn header="Внимание: на Mac используется `Cmd` вместо `Ctrl`"

На компьютерах под управлением Windows и Linux есть клавиши `key:Alt`, `key:Shift` и `key:Ctrl`. На Mac есть еще одна клавиша `key:Cmd`, которой соответствует свойство `metaKey`.

В большинстве случаев там, где на Windows/Linux используется `key:Ctrl`, на Mac используется `key:Cmd`. Там, где пользователь Windows нажимает `key:Ctrl+Enter` или `key:Ctrl+A`, пользователь Mac нажмёт `key:Cmd+Enter` или `key:Cmd+A`, и так далее, почти всегда `key:Cmd` вместо `key:Ctrl`.

Поэтому, если мы хотим поддерживать сочетание `key:Ctrl`+click или другие подобные, то на Mac имеет смысл использовать `key:Cmd`+click. Пользователям Mac это будет гораздо комфортнее.

Более того, даже если бы мы хотели бы заставить пользователей Mac использовать именно `key:Ctrl`+click – это было бы затруднительно. Дело в том, что обычный клик с зажатым `key:Ctrl` на Mac работает как *правый клик* и генерирует событие `contextmenu`, а не `click`, как на Windows/Linux.

Поэтому, если мы хотим, чтобы пользователи всех операционных систем чувствовали себя комфортно, то вместе с `ctrl` мы должны использовать `metaKey`.

В JS-коде это означает, что для удобства пользователей Mac нужно проверять if (event.ctrlKey || event.metaKey).

```

```warn header="Не забывайте про мобильные устройства"

Комбинации клавиш хороши как дополнение к рабочему процессу. Так что если у пользователя есть
  клавиатура -- это сработает. Но если у вашего устройства нет клавиатуры -- то есть другой способ сделать то же самое.
```

## Координаты: clientX/Y, pageX/Y

Все события мыши предоставляют доступ к текущим координатам курсора в двух видах:

1. Относительно окна: `clientX` и `clientY`.
2. Относительно документа: `pageX` and `pageY`.

Например, если окно размером 500x500, а курсор мыши находится в левом верхнем углу - `clientX` и `clientY` будут равны `0`, а если курсор мыши находится в центре, тогда `clientX` и `clientY` будут равны `250`. Прокрутка страницы или положение элемента в документе никак не повлияют на эти координаты, потому что они рассчитываются относительно окна, так же как и `position:fixed`.


````online
Проведите курсором мыши над полем ввода ниже, чтобы увидеть значения `clientX/clientY` (это поле ввода находится внутри `iframe`, поэтому и координаты рассчитываются относительно окна `iframe`)

```html autorun height=50
<input onmousemove="this.value=event.clientX+':'+event.clientY" value="Наведи на меня">
```
````

Координаты курсора мыши относительно документа рассчитываются от левого верхнего угла документа, поэтому при рассчете учитывается текущая прокрутка и положение элемента.
Координаты `pageX` и `pageY` аналогичны `position:absolute` на уровне документа.  

Подбронее о коордитанатах вы можете прочитать в главе <info:coordinates>.

## Отмена выделения на событие mousedown

Клики мыши могут иметь неприятные побочные эффекты. Например, двойной клик может выделять текст.

Если нам нужно обрабатывать событие клика, то "дополнительное" выделение текста выглядит не очень хорошо.

Например, двойной клик по элементу ниже выделит текст внутри:

```html autorun height=50
<b ondblclick="alert('dblclick')">Кликни два раза!</b>
```

Есть способ отменить выделение текста при помощи CSS свойства `user-select`. Подробнее об этом свойстве можно прочитать здесь [CSS UI Draft](https://www.w3.org/TR/css-ui-4/).

Большинство браузеров поддерживают его с префиксами:

```html autorun height=50
<style>
  b {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
  }
</style>

До...
<b ondblclick="alert('Test')">
  Невыделяемый
</b>
...После
```

Теперь двойной клик по слову "Невыделяемый" не будет выделять текст. Кажется, работет. 

...Но есть проблема! Текст теперь невозможно выделить полностью. Если пользователь начнет выделять текст со слова "До" и закончит на слове "После", часть со словом "Невыделяемый" будет пропущена. Действительно ли нам нужно это нужно?

В большинстве случаев нам это не нужно. Пользователю может понадобиться выделить текст для копирования или других нужд, поэтому это решение нам не очень подходит.

Нам необходимо только предотвратить выделение текста при двойном клике.

Выделение текста -- это действие браузера по-умолчанию на событие `mousedown`. Таким образом, мы можем обрабатывать событие `mousedown` и предовращать его, вот так:

```html autorun height=50
До...
<b ondblclick="alert('Клик!')" *!*onmousedown="return false"*/!*>
  Кликни два раза
</b>
...После
```

Теперь жирный текст не выделяется при двойном клике. 

Но текст внутри можно выделить. Однако выделение должно начинаться не с самого текста, а до или после него. Обычно это нормально, хотя.

````smart header="Canceling the selection"
Вместо того чтобы *предотвращать* выделение, мы можем отменять отменить его "постфактум" в обработчике событий.

Вот так:

```html autorun height=50
До...
<b ondblclick="*!*getSelection().removeAllRanges()*/!*">
  Кликни два раза
</b>
...После
```

Если дважды кликнуть по элементу, выделенному жирным, выделение сначала появится, а потом будет отменено. Это выглядит не очень хорошо.
````

````smart header="Предовращение копирования"
Если мы хотим отменить выделение, что бы защищить наш котнтент от копирования, то нам нужно использовать событие `oncopy`.

```html autorun height=80 no-beautify
<div *!*oncopy="alert('Копирование запрещено!');return false"*/!*>
  Уважаемый пользователь,
  Копирование запрещено для вас
  Если вы знаете JS или HTML, вы можете найти всю нужную вам информацию в исходном коде страницы.
</div>
```
Если вы попытаетесь скопировать текст внутри `<div>`, у вас это не получится, потому что событие `oncopy` запрещено.

Конечно, это не остановит пользователей, которые могут открыть исходный HTML код, но не все пользователи знаю как это сделать
````

## Итого

Сообытия мыши имею следующие свойства:

- Кнопка мыши: `which`.
- Клавиши-модификаторы (`true` если нажаты): `altKey`, `ctrlKey`, `shiftKey` и `metaKey` (Mac).
  - Если вам нужно обрабатывать `key:Ctrl`, то не забудьте, что пользователи Mac используют `key:Cmd`, поэтому лучше проверить `if (e.metaKey || e.ctrlKey)`.

- Координаты относительно окна: `clientX/clientY`.
- Координаты относительно документа: `pageX/pageY`.

It's also important to deal with text selection as an unwanted side-effect of clicks.

Так же важно позаботиться о выделении текста, как о нежелательном побочном эффекте от клика.

Есть несколько способов сделать это, например:
1. CSS свойство `user-select:none` (с префиксами браузеров) полностью отключает выделение текста.
2. Отмена выделения постфактум при помощи `getSelection().removeAllRanges()`.
3. Обработка события `mousedown` и предовращение действия по-умолчанию (зачастую это лучший способ).
