# Основы событий мыши

События мыши происходят не только от манипуляций мышью, но и эмулируются на сенсорных устройствах, чтобы сделать их совместимыми.

В этой главе мы более детально рассмотрим события мыши и их свойства.

## Типы событий мыши

Мы можем разделить события мыши на две категории: "простые" и "комплексные".

### Простые события

Самые часто используемые простые события:

`mousedown/mouseup`
: Кнопка мыши нажата/отпущена над элементом.

`mouseover/mouseout`
: Курсор мыши появляется над элементом и уходит с него.

`mousemove`
: Каждое движение мыши над элементом генерирует это событие.

...Есть также несколько иных типов событий, которые мы рассмотрим позже.

### Комплексные события

`click`
: Вызывается при `mousedown` , а затем `mouseup`  над одним и тем же элементом, если использовалась левая кнопка мыши.

`contextmenu`
: Вызывается при `mousedown` правой кнопкой мыши.

`dblclick`
: Вызывается двойным кликом на элементе.

Комплексные события состоят из простых, поэтому в теории мы могли бы без них обойтись. Но хорошо, что они существуют, потому что работать с ними очень удобно.

### Порядок событий

Одно действие может вызвать несколько событий.

Например, клик мышью вначале вызывает `mousedown`, когда кнопка нажата, затем `mouseup` и `click`, когда она отпущена.

В случае, когда одно действие инициирует несколько событий, порядок их выполнения фиксирован. То есть обработчики событий вызываются в следующем порядке: `mousedown` -> `mouseup` -> `click`. События обрабатываются в той же последовательности: `onmouseup` завершается до того, как запускается `onclick`.

```online
Кликните на кнопку ниже, и вы увидите события. Также попробуйте двойной клик.

В окне теста ниже все события мыши записываются, и если задержка между ними более 1 секунды, то они разделяются горизонтальной чертой.

Также мы можем увидеть свойство `which`, которое позволяет определить, какая кнопка мыши была нажата.

<input onmousedown="return logMouse(event)" onmouseup="return logMouse(event)" onclick="return logMouse(event)" oncontextmenu="return logMouse(event)" ondblclick="return logMouse(event)" value="Кликни меня левой или правой кнопкой мыши" type="button"> <input onclick="logClear('test')" value="Очистить" type="button"> <form id="testform" name="testform"> <textarea style="font-size:12px;height:150px;width:360px;"></textarea></form>
```

## Получение информации о кнопке: which

События, связанные с кликом, всегда имеют свойство `which`, которое позволяет определить нажатую кнопку мыши.

Это свойство не используется для событий `click` и `contextmenu`, поскольку первое происходит только при нажатии левой кнопкой мыши, а второе -- правой.

Но если мы отслеживаем `mousedown` и `mouseup`, то оно нам нужно, потому что эти события срабатывают на любой кнопке, и `which` позволяет различать между собой "нажатие правой кнопки" и "нажатие левой кнопки".

Есть три возможных значения:

- `event.which == 1` -- левая кнопка
- `event.which == 2` -- средняя кнопка
- `event.which == 3` -- правая кнопка

Средняя кнопка сейчас -- скорее экзотика, и используется очень редко.

## Модификаторы: shift, alt, ctrl и meta

Все события мыши включают в себя информацию о нажатых клавишах-модификаторах.

Их свойства:

- `shiftKey`
- `altKey`
- `ctrlKey`
- `metaKey` (`key:Cmd` для Mac)

Например, кнопка внизу работает только при комбинации `key:Alt+Shift`+клик:

```html autorun height=60
<button id="button">Нажми Alt+Shift+Click на мне!</button>

<script>
  button.onclick = function(event) {
*!*
    if (event.altKey && event.shiftKey) {
*/!*
      alert('Ура!');
    }
  };
</script>
```

```warn header="Внимание: обычно на Mac используется клавиша `Cmd` вместо `Ctrl`"
В Windows и Linux клавишами-модификаторами являются `key:Alt`, `key:Shift` и `key:Ctrl`. На Mac есть ещё одна: `key:Cmd`, она соответствует свойству `metaKey`.

В большинстве случаев, когда в Windows/Linux используется `key:Ctrl`, на Mac люди используют `key:Cmd`. Поэтому, когда пользователь Windows нажимает `key:Ctrl+Enter` и `key:Ctrl+A`, пользователь Mac нажимает `key:Cmd+Enter` или `key:Cmd+A`, и так далее, большинство приложений используют `key:Cmd` вместо `key:Ctrl`.

Поэтому, если мы хотим поддерживать такие комбинации, как `key:Ctrl`+клик, то для Mac имеет смысл использовать `key:Cmd`+клик. Это удобней для пользователей Mac.

Даже если мы и хотели бы заставить людей использовать `key:Ctrl`+клик на Mac, это довольно сложно. Проблема в том, что левый клик в сочетании с `key:Ctrl` интерпретируется как *правый клик* на Mac и генерирует событие `contextmenu`, а не `click` как на Windows/Linux.

Поэтому, если мы хотим, чтобы пользователям всех операционных систем было удобно, то вместе с `ctrlKey` нам нужно использовать `metaKey`.

Для JS-кода это означает, что мы должны проверить `if (event.ctrlKey || event.metaKey)`.
```

```warn header="Не забывайте про мобильные устройства"
Комбинации клавиш на клавиатуре -- это хорошее дополнение к рабочему процессу. Если у пользователя есть клавиатура -- они работают. Ну а если на его устройстве её нет -- должен быть другой способ сделать тоже самое.
```

## Координаты: clientX/Y, pageX/Y

Все события мыши имеют координаты двух видов:

1. Относительно окна: `clientX` и `clientY`.
2. Относительно документа: `pageX` и `pageY`.

Например, если у нас есть окно размером 500x500, и курсор мыши находится в левом верхнем углу, то значения `clientX` и `clientY` равны `0`. А если мышь находится в центре окна, то значения `clientX` и `clientY` равны `250` независимо от того, в каком месте документа она находится и до какого места документ прокручен. В этом они похожи на `position:fixed`.

````online
Наведите курсор мыши на поле ввода, чтобы увидеть `clientX/clientY` (оно расположено внутри `iframe`, поэтому координаты определяются относительно этого `iframe`):

```html autorun height=50
<input onmousemove="this.value=event.clientX+':'+event.clientY" value="Наведи мышку на меня">
```
````

Координаты относительно документа отсчитываются не от окна, а от левого верхнего угла документа.
Координаты `pageX`, `pageY` похожи на `position:absolute` на уровне документа.

Подробнее о координатах вы можете узнать в главе <info:coordinates>.

## Отключаем выделение при mousedown

Клики мышью имеют побочный эффект, который может быть неудобен в некоторых интерфейсах: двойной клик мышью выделяет текст.

Если мы хотим самостоятельно обработать события мыши, то такое "дополнительное" выделение зачастую "не к стати".

Например, двойной клик на текст ниже выделяет его в дополнение к нашему обработчику:

```html autorun height=50
<b ondblclick="alert('dblclick')">Двойной клик на мне</b>
```

Можно предотвратить такое выделение с помощью CSS: использовать свойство `user-select` из [CSS UI Draft](https://www.w3.org/TR/css-ui-4/).

Большинство браузеров поддерживает его с префиксами:

```html autorun height=50
<style>
  b {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
  }
</style>

До...
<b ondblclick="alert('Тест')">
  Невыделяемый текст
</b>
...После
```

Теперь, если вы сделаете двойной клик по "Невыделяемый текст", он не будет выделен. Похоже, сработало.

...Но есть потенциальная проблема! Текст стал действительно невыделяемым. Даже если пользователь начнет выделение с "До..." и закончит его на "...После", выделение пропустит часть "Невыделяемый текст". Действительно ли хотим сделать наш текст невыделяемым?

Чаще всего -- нет. У пользователя могут быть веские основания для выделения текста, копирования или других нужд. Если мы не позволим это сделать -- может быть очень неудобно. Поэтому данное решение не очень хорошее.

Всё, чего мы хотим, это предотвратить выделение при двойном клике.

Выделение текста -- это действие браузера по умолчанию при наступлении события `mousedown`. Поэтому альтернативным решением проблемы будет обработать событие `mousedown` и предотвратить его, вот так:

```html autorun height=50
До...
<b ondblclick="alert('Клик!')" *!*onmousedown="return false"*/!*>
  Сделайте двойной клик на мне
</b>
...После
```

Теперь выделенный жирным элемент не выделяется при двойном клике.

Текст внутри него по прежнему можно выделить. Однако, выделение должно начаться не на самом тексте, а до него или после. Обычно это нормально воспринимается пользователями.

````smart header="Отмена выделения"
Вместо *предотвращения* выделения, мы можем отменить его "постфактум" в обработчике событий.

Например вот так:

```html autorun height=50
До...
<b ondblclick="*!*getSelection().removeAllRanges()*/!*">
  Сделайте двойной клик на мне
</b>
...После
```

При двойном клике на элементе, выделенном жирным шрифтом, выделение появится и тут же будет немедленно снято ("мигнёт"). Выглядит это не очень красиво.
````

````smart header="Предотвращение копирования"
Если мы хотим отключить выделение для защиты нашего контента от копирования, то мы можем использовать другое событие: `oncopy`.

```html autorun height=80 no-beautify
<div *!*oncopy="alert('Копирование запрещено!');return false"*/!*>
  Уважаемый пользователь,
  Копирование информации запрещено для вас.
  Если вы знаете JS или HTML, вы можете найти всю нужную вам информацию в исходном коде страницы.
</div>
```
Если вы попытаетесь скопировать текст в `<div>`, у вас это не получится, потому что срабатывание события `oncopy` по умолчанию запрещено.

Конечно, это не остановит пользователя от открытия исходного HTML-кода, но не все знают, как это сделать.
````

## Итого

События мыши имеют следующие свойства:

- Кнопка: `which`.
- Клавиши-модификаторы (`true` если нажаты): `altKey`, `ctrlKey`, `shiftKey` и `metaKey` (Mac).
  - Если вы планируете обработать `key:Ctrl`, то не забудьте, что пользователи Mac используют `key:Cmd`, поэтому лучше проверить `if (e.metaKey || e.ctrlKey)`.

- Координаты относительно окна: `clientX/clientY`.
- Координаты относительно документа: `pageX/pageY`.

Также важно позаботиться о выделении текста, оно может быть нежелательным побочным эффектом кликов.

Есть несколько способов сделать это, например:
1. CSS-свойство `user-select:none` (с префиксами для различных браузеров) полностью отключает выделение текста.
2. Отмена выделения постфактум, используя `getSelection().removeAllRanges()`.
3. Обработать событие `mousedown` и предотвратить его действие по умолчанию (обычно является лучшим решением).

Впрочем, работа с выделением - это отдельная тема, раскрытая в соответствующей главе <info:selection-range>.
