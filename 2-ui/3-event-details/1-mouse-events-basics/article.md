# Основы событий мыши

События мыши происходят не только от манипуляций мышью, но и эмулируются на сенсорных устройствах, чтобы сделать их совместимыми.

В этой главе мы более детально рассмотрим события мыши и их свойства.

## Типы событий мыши 

Мы можем разделить события мыши на две категории: "простые" и "комплексные".

### Простые события

Наиболее часто используются простые события:

`mousedown/mouseup`
: Кнопка мыши нажата/отпущена над элементом.

`mouseover/mouseout`
: Курсор мыши появляется над элементом и уходит с него.

`mousemove`
: Каждое движение мыши над элементом генерирует это событие.

...Есть также несколько иных типов событий, которые мы рассмотрим позже.

### Комплексные события

`click`
: Вызывается при `mousedown` , а затем `mouseup` , над одним и тем же элементом, если использовалась левая кнопка мыши.

`contextmenu`
: Вызывается при `mousedown` правой кнопкой мыши.

`dblclick`
: Вызывается двойным кликом на элементе.

Комплексные события состоят из простых, поэтому в теории мы могли бы без них обойтись. Но хорошо, что они существуют, потому что работать с ними очень удобно.

### Порядок событий 

Одно действие может вызвать несколько событий.

Например, клик мышью вначале вызывает `mousedown`, когда кнопка нажата, затем `mouseup` и `click`, когда она отпущена.

В случае, когда одно действие инициирует несколько событий, порядок их выполнения фиксирован. То есть обработчики событий вызываются в следующем порядке: `mousedown` -> `mouseup` -> `click`. События обрабатываются в той же последовательности: `onmouseup` завершается до того, как запускается `onclick`.

```online
Кликните на кнопку ниже, и вы увидите события. Также попробуйте двойной клик.

В окне теста ниже все события мыши записываются, и если задержка между ними более 1 секунды, то они разделяются горизонтальной чертой.

Также мы можем увидеть свойство `which`, которое позволяет определить, какая кнопка мыши была нажата.

<input onmousedown="return logMouse(event)" onmouseup="return logMouse(event)" onclick="return logMouse(event)" oncontextmenu="return logMouse(event)" ondblclick="return logMouse(event)" value="Кликни меня левой или правой кнопкой мыши" type="button"> <input onclick="logClear('test')" value="Очистить" type="button"> <form id="testform" name="testform"> <textarea style="font-size:12px;height:150px;width:360px;"></textarea></form>
```

## Получение информации о кнопке: which

События, связанные с кликом, всегда имеют свойство `which`, которое позволяет определить нажатую кнопку мыши.

Это свойство не используется для событий `click` и `contextmenu`, поскольку первое происходит только при нажатии левой кнопкой мыши, а второе -- правой.

Но если мы отслеживаем `mousedown` и `mouseup`, то оно нам нужно, потому что эти события срабатывают на любой кнопке, и `which` позволяет различать между собой "нажатие правой кнопки" и "нажатие левой кнопки".

Есть три возможных значения:

- `event.which == 1` -- левая кнопка
- `event.which == 2` -- средняя кнопка
- `event.which == 3` -- правая кнопка

Средняя кнопка сейчас -- скорее экзотика, и используется очень редко.

## Модификаторы: shift, alt, ctrl и meta

Все события мыши включают в себя информацию о нажатых клавишах-модификаторах.

Их свойства:

- `shiftKey`
- `altKey`
- `ctrlKey`
- `metaKey` (`key:Cmd` для Mac)

Например, кнопка внизу работает только при комбинации `key:Alt+Shift`+клик:

```html autorun height=60
<button id="button">Нажми Alt+Shift+Click на мне!</button>

<script>
  button.onclick = function(event) {
*!*
    if (event.altKey && event.shiftKey) {
*/!*
      alert('Ура!');
    }
  };
</script>
```

```warn header="Внимание: обычно на Mac используется клавиша `Cmd` вместо `Ctrl`"
В Windows и Linux клавишами-модификаторами являются `key:Alt`, `key:Shift` и `key:Ctrl`. На Mac есть ещё одна: `key:Cmd`, она соответствует свойству `metaKey`.

В большинстве случаев, когда в Windows/Linux используется `key:Ctrl`, на Mac люди используют `key:Cmd`. Поэтому, когда пользователь Windows нажимает `key:Ctrl+Enter` и `key:Ctrl+A`, пользователь Mac нажимает `key:Cmd+Enter` или `key:Cmd+A`, и так далее, большинство приложений использует `key:Cmd` вместо `key:Ctrl`.

Поэтому, если мы хотим поддерживать такие комбинации, как `key:Ctrl`+клик, то для Mac имеет смысл использовать `key:Cmd`+клик. Это удобней для пользователей Mac.

Даже если мы хотим заставить людей использовать `key:Ctrl`+клик на Mac, это довольно сложно. Проблема в том, что левый клик в сочетании с `key:Ctrl` интерпретируется как *правый клик* на Mac и генерирует событие `contextmenu`, а не `click` как на Windows/Linux.

Поэтому, если мы хотим, чтобы пользователям всех операционных систем было удобно, то вместе с `ctrlKey` нам нужно использовать `metaKey`.

Для JS-кода это означает, что мы должны проверить `if (event.ctrlKey || event.metaKey)`.
```

```warn header="Не забывайте про мобильные устройства"
Комбинации клавиш на клавиатуре -- это хорошее дополнение к рабочему процессу. Так, если у пользователя есть клавиатура -- они работают. А если у устройства клавиатуры нет, тогда есть другие методы сделать тоже самое.
```

## Координаты: clientX/Y, pageX/Y

Все события мыши имеют координаты двух видов:

1. Относительно окна: `clientX` и `clientY`.
2. Относительно документа: `pageX` и `pageY`.

Например, если у нас есть окно размером 500x500, и курсор мыши находится в левом верхнем углу, то значения `clientX` и `clientY` равны `0`. А если мышь находится в центре окна, то значения `clientX` и `clientY` равны `250` независимо от того, в каком месте документа она находится. В этом они похожи на `position:fixed`.

````online
Наведите курсор мыши на поле ввода, чтобы увидеть `clientX/clientY` (оно расположено внутри `iframe`, поэтому координаты определяются относительно этого `iframe`):

```html autorun height=50
<input onmousemove="this.value=event.clientX+':'+event.clientY" value="Наведи мышку на меня">
```
````

Координаты относительно документа отсчитываются не от окна, а от левого верхнего угла документа.
Координаты `pageX`, `pageY` похожи на `position:absolute` на уровне документа.

Подробнее о координатах вы можете узнать в главе <info:coordinates>.

## Отсутствие выделения текста при mousedown

Клики мышью имеют побочный эффект, который может вызывать беспокойство. Двойной клик мышью выделяет текст.

Если мы хотим самостоятельно обработать события мыши, то "дополнительное" выделение выглядит не очень удачно.

Например, двойной клик на текст ниже выделяет его в дополнение к нашему обработчику:

```html autorun height=50
<b ondblclick="alert('dblclick')">Двойной клик на мне</b>
```

Можно предотвратить такое выделение с помощью CSS: использовать свойство `user-select` из [CSS UI Draft](https://www.w3.org/TR/css-ui-4/).

Большинство браузеров поддерживает его с префиксами:

```html autorun height=50
<style>
  b {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
  }
</style>

До...
<b ondblclick="alert('Тест')">
  Невыделяемый текст
</b>
...После
```

Теперь, если вы сделаете двойной клик по "Невыделяемый текст", он не будет выделен. Похоже, сработало.

...Но есть потенциальная проблема! Текст стал действительно невыделяемым. Даже если пользователь начнет выделение с "До..." и закончит его на "...После", выделение пропустит часть "Невыделяемый текст". Неужели мы действительно хотим сделать наш текст невыделяемым?

Чаще всего -- нет. У пользователя могут быть веские основания для выделения текста, копирования или других нужд. Если мы не позволим это сделать -- может быть очень неудобно. Поэтому данное решение не очень хорошее.

Всё, чего мы хотим, это предотвратить выделение при двойном клике.

Выделение текста -- это событие браузера по умолчанию при наступлении событии `mousedown`. Поэтому альтернативным решением проблемы будет обработать событие `mousedown` и предотвратить его подобным образом:

```html autorun height=50
До...
<b ondblclick="alert('Клик!')" *!*onmousedown="return false"*/!*>
  Двойной клик на мне
</b>
...После
```

Теперь выделенный жирным элемент не выделяется при двойном клике.

Текст внутри него по прежнему можно выделить. Однако, выделение должно начаться не на самом тексте, а до него или после. Обычно это нормально.

````smart header="Отмена выделения"
Вместо *предотвращения* выделения, мы можем отменить его "постфактум" в обработчике событий.

Например вот так:

```html autorun height=50
До...
<b ondblclick="*!*getSelection().removeAllRanges()*/!*">
  Двойной клик на мне
</b>
...После
```

При двойном клике на элементе, выделенном жирным шрифтом, выделение сначала появится, а затем будет немедленно снято. Хотя выглядит это не очень красиво.
````

````smart header="Предотвращение копирования"
Если мы хотим отключить выделение для защиты нашего контента от копирования, то мы можем использовать другое событие: `oncopy`.

```html autorun height=80 no-beautify
<div *!*oncopy="alert('Копирование запрещено!');return false"*/!*>
  Уважаемый пользователь,
  Копирование информации запрещено для вас.
  Если вы знаете JS или HTML, вы можете найти всю нужную вам информацию в исходном коде страницы.
</div>
```
Если вы попытаетесь скопировать текст в `<div>`, у вас это не получится, потому что срабатывание события `oncopy` по умолчанию запрещено.

Конечно, это не остановит пользователя от открытия исходного HTML-кода, но не все знают, как это сделать.
````

## Итого

События мыши имеют следующие свойства:

- Кнопка: `which`.
- Клавиши-модификаторы (`true` если нажаты): `altKey`, `ctrlKey`, `shiftKey` и `metaKey` (Mac).
  - Если вы планируете обработать `key:Ctrl`, то не забудьте, что пользователи Mac используют `key:Cmd`, поэтому лучше проверить `if (e.metaKey || e.ctrlKey)`.

- Координаты относительно окна: `clientX/clientY`.
- Координаты относительно документа: `pageX/pageY`.

Также важно позаботиться о выделении текста, как о нежелательном побочном эффекте кликов.

Есть несколько способов сделать это, например:
1. CSS-свойство `user-select:none` (с префиксами для различных браузеров) полностью отключает выделение текста.
2. Отмена выделения постфактум, используя `getSelection().removeAllRanges()`.
3. Обработать событие `mousedown` и предотвратить его действие по умолчанию (обычно является лучшим решением).
