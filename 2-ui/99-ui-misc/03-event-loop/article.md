
# Событийный цикл: микрозадачи и макрозадачи

Поток выполнения в браузере, равно как и в Node.js, основан на *событийном цикле*.

Понимание работы событийного цикла важно для оптимизаций, иногда для правильной архитектуры.

В этом разделе мы разберём теорию, а затем рассмотрим её практическое применение.

## Событийный цикл

Идея *событийного цикла* очень проста. Есть бесконечный цикл, в котором движок JavaScript ожидает задачи, исполняет их, и снова ожидает появления новых.

1. Пока есть задания:
    - выполнить самую старую задачу
2. Бездействовать до появления новой задачи, а затем перейти к пункту 1

Это формальный алгоритм того, что мы наблюдаем, просматривая веб-страницу. Движок JavaScript большую часть времени ничего не делает и работает, только если требуется исполнить скрипт/обработчик или обработать событие.

Задача может быть JS-кодом, который был активирован событием, но также может быть чем-то иным, а именно:

-  Когда загружается внешний скрипт `<script src="...">`, то задача - это выполнение этого скрипта.
-  Когда пользователь двигает мышь, задача - сгенерировать событие `mousemove` и выполнить его обработчики.
-  Когда истечёт таймер, установленный с помощью `setTimeout`, задача - это выполнение функции обратного вызова этого таймера.
-  И так далее.

Задачи поступают на выполнение -- движок выполняет их -- затем ожидает новые задачи (во время ожидания практически не нагружая процессор компьютера)

Может так случиться, что задача поступает, когда движок занят другой задачей, тогда вновь поступившая задача ставится в очередь.

Задачи формируют очередь, эту очередь называют "очередью макрозадач" (термин v8)

![](eventLoop.png)

Например, когда движок занят выполнением подключённого скрипта `script`, пользователь может передвинуть мышь, тем самым вызвав появление события `mousemove`, или может истечь таймер, установленный `setTimeout` и т.п. Эти задачи формируют очередь (см. иллюстрацию выше)

Задачи из очереди исполняются по правилу "первым пришел - первым обслужен". Когда браузер заканчивает выполнение `fetch`, он обрабатывает событие `mousemove`, затем выполняет обработчик, заданный `setTimeout`, и так далее.

Пока что всё просто, верно?

Отметим две детали:
1.  Рендеринг (отрисовка страницы) никогда не происходит во время выполнения задачи движком.

    Не имеет значение сколь долго выполняется задача. Изменения в DOM отрисовываются только после того, как задача выполнена.
2.  Если задача выполняется очень долго, то браузер не может выполнять другие задачи, обрабатывать пользовательские события, поэтом спустя некоторое время браузер предлагает "убить" долго выполняющуюся задачу.

    Обычно вся страница "умирает" вместе с задачей.

Теперь давайте взглянем, как можно применить эти знания.

## Пример из практики: разбиение процессороёмкой задачи.

Допустим, у нас есть задача, требующая значительных ресурсов процессора.

Например, подсветка синтаксиса (используется для выделения цветом участков кода на этой странице) довольно процессороёмкая задача. Для подсветки кода надо выполнить синтаксический анализ, создать много элементов для цветового выделения, добавить их в документ -- для большого текста это требует значительных ресурсов.

Пока движок занят подсветкой синтаксиса, он не может делать ничего, связанного с DOM, не может обрабатывать пользовательские события и т.д. Возможно, браузер даже "зависнет", что совершенно неприемлемо.

Поэтому мы можем разбить большой текст на части. Сделать подсветку для первых ста строк, затем запланировать разметку следующих 100 строк, воспользовавшись `setTimeout` с нулевой задержкой, и т.д.

Чтобы продемонстрировать такой подход, давайте будем использовать для простоты функцию, которая считает от `1` до `1000000000`.

Если вы запустите код ниже, движок "зависнет" на некоторое время. Для серверного JS это будет явно заметно, а если вы будете выполнять этот код в браузере, то попробуйте понажимать другие кнопки на странице -- вы заметите, что никакие другие события не обрабатываются до завершения функции счёта.

```js run
let i = 0;

let start = Date.now();

function count() {

  // делаем тяжёлую работу
  for (let j = 0; j < 1e9; j++) {
    i++;
  }

  alert("Done in " + (Date.now() - start) + 'ms');
}

count();
```

Браузер может даже показать сообщение "скрипт выполняется слишком долго" (скорее всего, не покажет, т.к. число в примере не слишком большое)

Давайте разобьём задачу на части, воспользовавшись вложенным `setTimeout`:

```js run
let i = 0;

let start = Date.now();

function count() {

  // делаем часть тяжелой работы (*)
  do {
    i++;
  } while (i % 1e6 != 0);

  if (i == 1e9) {
    alert("Done in " + (Date.now() - start) + 'ms');
  } else {
    setTimeout(count); // планируем новый вызов (**)
  }

}

count();
```

Теперь интерфейс браузера полностью работоспособен во время выполнения "счёта".

Один вызов `count` делает часть работы `(*)`, а затем, если необходимо, планирует свой очередной запуск `(**)`:

1.  Первое выполнение производит счёт: i=1...1000000.
2.  Второе выполнение производит счёт: i=1000001..2000000.
3.  ...и так далее.
    
Паузы между выполнениями `count` позволяют движку JavaScript заняться чем-нибудь другим, отреагировать на действия пользователя.

Отметим, что оба варианта -- с разбиением задачи с помощью `setTimeout` и без -- сопоставимы по скорости выполнения. Нет большой разницы в общем времени счёта.

Чтобы сократить разницу ещё сильнее, давайте немного улучшим наш код.

Мы перенесём планирование очередного вызова в начало `count()`:

```js run
let i = 0;

let start = Date.now();

function count() {

  // перенесём планирование очередного вызова в начало
  if (i < 1e9 - 1e6) {
    setTimeout(count); // запланировать новый вызов
  }

  do {
    i++;
  } while (i % 1e6 != 0);

  if (i == 1e9) {
    alert("Done in " + (Date.now() - start) + 'ms');
  }

}

count();
```

Теперь, когда мы начинаем выполнять `count()` и видим, что потребуется выполнить `count()` ещё раз, мы планируем этот вызов немедленно, перед выполнением работы.

Если вы выполните этот код, то легко заметите, что он требует значительно меньше времени.

Почему?

Всё просто: запомните, в браузере есть минимальная задержка в 4 миллисекунды для многих вложенных вызовов `setTimeout`. Даже если мы указываем задержку `0`, на самом деле она будет равна `4 мс` (или чуть больше). Поэтому чем раньше мы запланируем выполнение - тем быстрее выполнится код.

## Пример из практики: индикатор выполнения

Ещё одно преимущество разделения на части крупной задачи в браузерных скриптах - это возможность показывать индикатор выполнения.

Обычно браузер отрисовывает содержимое страницы после того, как заканчивается выполнение текущего кода. Не имеет значения насколько долго выполняется задача. Изменения в DOM отображаются только после её завершения.

С одной стороны, это хорошо, потому что наша функция может создавать много элементов, добавлять их по одному в документ и изменять их стили -- пользователь не увидит "промежуточного", незаконченного состояния. Это важно, верно?

В примере ниже, изменения `i` не будут заметны, пока функция не завершится, поэтому мы увидим только последнее значение `i`:


```html run
<div id="progress"></div>

<script>

  function count() {
    for (let i = 0; i < 1e6; i++) {
      i++;
      progress.innerHTML = i;
    }
  }

  count();
</script>
```

...Но, возможно, мы хотим что-нибудь показать во время выполнения задачи, например, индикатор выполнения.

Если мы используем `setTimeout` для разбиения крупной задачи на части, тогда изменения индикатора будут отрисованы в промежутках между частями.

Вот так будет лучше:

```html run
<div id="progress"></div>

<script>
  let i = 0;

  function count() {

    // сделать часть крупной задачи (*)
    do {
      i++;
      progress.innerHTML = i;
    } while (i % 1e3 != 0);

    if (i < 1e7) {
      setTimeout(count);
    }

  }

  count();
</script>
```

Теперь `<div>` показывает растущее значение `i` - это своего рода индикатор выполнения.


## Пример из практики: делаем что-нибудь после события

В обработчике события мы можем решить отложить некоторые действия, пока событие не "всплывёт" и не будет обработано на всех уровнях. Мы можем добиться этого, обернув код в `setTimeout` с нулевой задержкой.

В главе <info:dispatch-events> мы видели пример: определённое нами событие `menu-open` генерируется после того, как событие "click" полностью обработано.

```js
menu.onclick = function() {
  // ...

  // создадим наше собственное событие с данными пункта меню, по которому щёлкнули мышью
  let customEvent = new CustomEvent("menu-open", {
    bubbles: true
    /* details: можно добавить больше деталей, например, данные пункта, по которому щёлкнули */
  });

  // сгенерировать наше событие асинхронно
  setTimeout(() => menu.dispatchEvent(customEvent));
};
```

Пользовательское событие здесь абсолютно независимо. Оно сгенерировано асинхронно, после того как событие `click` всплыло и было полностью обработано. Это помогает обойти некоторые потенциальные ошибки, которые могут возникнуть, когда разные события вложены друг в друга.

## Микрозадачи

Помимо *макрозадач*, описанных в этой части, существуют *микрозадачи*, упомянутые в главе <info:microtask-queue>.

Есть два основных способа создать микрозадачу:

1.  Когда промис готов, выполнение его `.then/catch/finally` обработчика становится микрозадачей. Микрозадачи также используются "под капотом" `await`, т.к. это форма обработки промиса, похожая на `.then`, но синтаксически иная.
2.  Есть специальная функция `queueMicrotask(func)`, которая помещает `func` в очередь микрозадач.

После каждой *макрозадачи* движок исполняет все задачи из очереди *микрозадач* перед тем, как выполнить следующую макрозадачу.

**Очередь микрозадач имеет приоритет выше, чем очередь макрозадач.**

Например:

```js run
setTimeout(() => alert("timeout"));

Promise.resolve()
  .then(() => alert("promise"));

alert("code");
```

Каков порядок?

1.  `code` появляется первым, т.к. это обычный синхронный вызов.
2.  `promise` появляется вторым, потому что `.then` проходит через очередь микрозадач и выполняется после текущего синхронного кода.
3.  `timeout` появляется последним, потому что это макрозадача.

**Между микрозадачами события пользовательского интерфейса невозможны.**

Большинство задач браузера - это макрозадачи: обработка результатов сетевых запросов, обработка событий пользовательского интерфейса и т.п.

Поэтому, если мы хотим исполнить код асинхронно, но в то же время хотим сохранить состояние приложения практически неизменным (никаких изменений координат мыши, никаких новых данных из сети и т.п.), то мы можем добиться этого, создав микрозадачу с помощью `queueMicrotask`.

Отрисовка страницы также ожидает исчерпания очереди микрозадач.

Вот пример с индикатором выполнения, похожий на предыдущий, но в этот раз использована функция `queueMicrotask` вместо `setTimeout`. Можно заметить, что отрисовка страницы происходит в самом конце, как и в случае обычного синхронного кода.

```html run
<div id="progress"></div>

<script>
  let i = 0;

  function count() {

    // делаем часть крупной задачи (*)
    do {
      i++;
      progress.innerHTML = i;
    } while (i % 1e3 != 0);

    if (i < 1e6) {
  *!*
      queueMicrotask(count);
  */!*
    }

  }

  count();
</script>
```

Таким образом, микрозадачи асинхронны с точки зрения исполнения кода, но они не позволяют выполнить и обработать другие процессы и события браузера до завершения всех микрозадач.

## Итого

Более подробное изображение событийного цикла может выглядеть следующим образом:

![](eventLoop-full.png)

Более подробный алгоритм событийного цикла (всё же упрощенный в сравнении с тем, что представлен в [спецификации](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model)):

1. Выбрать и исполнить старейшую задачу из очереди *макрозадач* (например, "script").
2. Исполнить все *микрозадачи*:
    - Пока очередь микрозадач не пуста:
          - Выбрать из очереди и исполнить старейшую микрозадачу
3. Отрисовать изменения страницы, если они есть.
4. Подождать, пока в очередь макрозадач будет что-то добавлено (если необходимо)
5. Перейти к шагу 1.

Чтобы добавить в очередь новую макрозадачу:
- Используйте `setTimeout(f)` с нулевой задержкой.

Этот способ можно использовать для разбиения больших и требующих серьезного объёма вычислений задач на части, чтобы браузер мог реагировать на пользовательские события и показывать прогресс выполнения этих частей.

Также используется в обработчиках событий для отложенного выполнения действия после того, как событие полностью обработано (всплытие завершено)

Для добавления в очередь новой микрозадачи:
- Используйте `queueMicrotask(f)`.
- Также обработчики промисов выполняются в рамках очереди микрозадач.

События пользовательского интерфейса и сетевые события в промежутках между микрозадачами не обрабатываются: микрозадачи исполняются непрерывно одна за другой.

Поэтому `queueMicrotask` можно использовать для асинхронного выполнения функции, но с тем же состоянием приложения.

```smart header="Web Workers"
Для длительных тяжёлых вычислений, которые не должны блокировать событийный цикл, мы можем использовать [Web Workers](https://html.spec.whatwg.org/multipage/workers.html).

Это способ исполнить код в другом, параллельном потоке.

Web Workers могут обмениваться сообщениями с основным процессом, но они имееют свой переменные и свои событийный цикл.

Web Workers не имеют доступа к DOM, поэтому основное их применение - вычисления, они позволяют задействовать нескольких ядер одновременно.
```
