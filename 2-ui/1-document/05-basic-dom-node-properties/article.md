# Свойства узлов: тип, тег и содержимое

Давайте подробнее рассмотрим DOM-узлы.

В этой главе мы подробнее разберём, что они собой представляют и какие из их свойств мы используем чаще всего.

## Классы DOM-узлов

В зависимости от класса у DOM-узлов могут быть разные свойства. Например, у узла, соответствующего тегу `<a>`, есть свойства, связанные со ссылками, а у соответствующего тегу `<input>` -- свойства, связанные с полем ввода и т.д. Текстовые узлы отличаются от узлов-элементов. Но у них есть общие свойства и методы, потому что все классы DOM-узлов образуют единую иерархию.

Каждый DOM-узел принадлежит соответствующему встроенному классу.

Корнем иерархии является [EventTarget](https://dom.spec.whatwg.org/#eventtarget), от него наследует [Node](http://dom.spec.whatwg.org/#interface-node) и остальные DOM-узлы.

На рисунке ниже изображены основные классы:

![](dom-class-hierarchy.png)

Существуют следующие классы:

- [EventTarget](https://dom.spec.whatwg.org/#eventtarget) -- это корневой "абстрактный" класс. Объекты этого класса никогда не создаются. Он служит основой, благодаря которой все DOM-узлы поддерживают так называемые "события", о которых мы поговорим позже.
- [Node](http://dom.spec.whatwg.org/#interface-node) -- также является "абстрактным" классом, и служит основой для DOM-узлов. Он обеспечивает базовую функциональность: `parentNode`, `nextSibling`, `childNodes` и т.д. (это геттеры). Объекты класса `Node` никогда не создаются. Но есть определенные классы узлов, которые наследуют от него: `Text` -- для текстовых узлов, `Element` -- для узлов-элементов и более экзотический `Comment` -- для узлов-комментариев.
- [Element](http://dom.spec.whatwg.org/#interface-element) -- это базовый класс для DOM-элементов. Он обеспечивает навигацию на уровне элементов: `nextElementSibling`, `children` и методы поиска: `getElementsByTagName`, `querySelector`. Браузер поддерживает не только HTML, но также XML и SVG. Класс Element служит базой для следующих классов: `SVGElement`, `XMLElement` и `HTMLElement`.
- [HTMLElement](https://html.spec.whatwg.org/multipage/dom.html#htmlelement) -- является базовым классом для всех остальных HTML-элементов. От него наследуют разнообразные HTML-узлы:
    - [HTMLInputElement](https://html.spec.whatwg.org/multipage/forms.html#htmlinputelement) -- класс для тега `<input>`,
    - [HTMLBodyElement](https://html.spec.whatwg.org/multipage/semantics.html#htmlbodyelement) -- класс для тега `<body>`,
    - [HTMLAnchorElement](https://html.spec.whatwg.org/multipage/semantics.html#htmlanchorelement) -- класс для тега `<a>`
    - ...и т.д, каждому тегу соответствует свой класс, который предоставляет определенные свойства и методы.

Таким образом, полный набор свойств и методов данного узла собирается в результате наследования.

Рассмотрим DOM-объект для тега `<input>`. Он принадлежит классу [HTMLInputElement](https://html.spec.whatwg.org/multipage/forms.html#htmlinputelement). Он получает свойства и методы из:

- `HTMLInputElement` -- этот класс предоставляет специфичные для элементов формы свойства и наследует от...
- `HTMLElement` -- он предоставляет общие для HTML-элементов методы (и геттеры/сеттеры) и наследует от...
- `Element` -- предоставляет типовые методы элемента и наследует от...
- `Node` -- предоставляет общие свойства DOM-узлов и наследует от...
- `EventTarget` -- обеспечивает поддержку событий (поговорим о них дальше),
- ...и, наконец, он наследует от `Object`, поэтому доступны также методы "чистого объекта", такие как `hasOwnProperty`.

Для того, чтобы узнать имя класса DOM-узла, мы вспомним, что обычно у объекта есть свойство `constructor`. Оно ссылается на конструктор класса, и в свойстве `constructor.name` содержится его имя:

```js run
alert( document.body.constructor.name ); // HTMLBodyElement
```

...Или мы можем просто привести его к `строке`:

```js run
alert( document.body ); // [object HTMLBodyElement]
```

Проверить наследование можно также при помощи `instanceof`:

```js run
alert( document.body instanceof HTMLBodyElement ); // true
alert( document.body instanceof HTMLElement ); // true
alert( document.body instanceof Element ); // true
alert( document.body instanceof Node ); // true
alert( document.body instanceof EventTarget ); // true
```

Как видно, DOM-узлы -- это обычные JavaScript объекты. Для наследования они используют классы, основанные на прототипах.

В этом легко убедиться, если вывести в консоли браузера любой элемент через `console.dir(elem)`. Или даже напрямую обратиться к методам, которые хранятся в `HTMLElement.prototype`, `Element.prototype` и т.д.

```smart header="`console.dir(elem)` и `console.log(elem)`"
Большинство браузеров поддерживают в инструментах разработчика две команды : `console.log` и `console.dir`. Они выводят свои аргументы в консоль. Для JavaScript-объектов эти команды обычно выводят одно и то же.

Но для DOM-элементов они работают по-разному:

- `console.log(elem)` выводит элемент в виде DOM-дерева.
- `console.dir(elem)` выводит элемент в виде DOM-объекта, что удобно для анализа его свойств.

Попробуйте сами на `document.body`.
```

````smart header="Спецификация IDL"
В спецификации для описания классов DOM используется не JavaScript, а специальный язык [Interface description language](https://ru.wikipedia.org/wiki/%D0%AF%D0%B7%D1%8B%D0%BA_%D0%BE%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D1%8F_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D0%BE%D0%B2) (IDL), с которым достаточно легко разобраться.

В IDL все свойства представлены с указанием их типов. Например, `DOMString`, `boolean` и т.д.

Небольшой отрывок IDL с комментариями:

```js
// Объявление HTMLInputElement
*!*
// Двоеточие ":" после HTMLInputElement означает, что он наследует от HTMLElement
*/!*
interface HTMLInputElement: HTMLElement {
  // далее идут свойства и методы элемента <input>

*!*
  // "DOMString" означает, что значение этих свойств -- строки
*/!*
  attribute DOMString accept;
  attribute DOMString alt;
  attribute DOMString autocomplete;
  attribute DOMString value;

*!*
  // boolean -- значит, что autofocus хранит логический тип данных (true/false)
  attribute boolean autofocus;
*/!*
  ...
*!*
  // "void" перед методом означает, что данный метод не возвращает значение
*/!*
  void select();
  ...
}
```

Другие классы в целом похожи на этот.
````

## Свойство "nodeType"

Свойство `nodeType` предоставляет "старомодный" способ узнать "тип" DOM-узла.

Его значением является цифра:
- `elem.nodeType == 1` для узлов-элементов,
- `elem.nodeType == 3` для текстовых узлов,
- `elem.nodeType == 9` для объектов документа,
- [В спецификации](https://dom.spec.whatwg.org/#node) можно посмотреть остальные значения.

Например:

```html run
<body>
  <script>  
  let elem = document.body;

  // посмотрим что это?
  alert(elem.nodeType); // 1 => элемент

  // и первый потомок...
  alert(elem.firstChild.nodeType); // 3 => текст

  // для объекта document значение типа -- 9
  alert( document.nodeType ); // 9
  </script>
</body>
```

В современных скриптах, чтобы узнать тип узла, мы можем использовать метод `instanceof` и другие методы классов, но иногда проще воспользоваться `nodeType`. Мы не можем изменить значение `nodeType`, только прочитать его.

## Тег: nodeName и tagName

Получив DOM-узел, мы можем узнать имя его тега из свойств `nodeName` и `tagName`:

Например:

```js run
alert( document.body.nodeName ); // BODY
alert( document.body.tagName ); // BODY
```

Какая разница между tagName и nodeName ?

Разница отражена в названиях свойств, но неочевидна.

- Свойство `tagName` есть только у элементов `Element`.
- Свойство `nodeName` определено для любых узлов `Node`:
    - для элементов оно равно `tagName`.
    - для остальных типов узлов (текст, комментарий и т.д.) оно содержит строку с типом узла.

Другими словами, свойство `tagName` есть только у узлов-элементов (поскольку они происходят от класса `Element`), а `nodeName` может что-то сказать о других типах узлов.

Например, сравним `tagName` и `nodeName` на примере объекта `document` и узла-комментария:


```html run
<body><!-- комментарий -->

  <script>
    // для комментария
    alert( document.body.firstChild.tagName ); // undefined (не элемент)
    alert( document.body.firstChild.nodeName ); // #comment

    // for document
    alert( document.tagName ); // undefined (не элемент)
    alert( document.nodeName ); // #document
  </script>
</body>
```

Если мы имеем дело только с элементами, то `tagName` -- это то, что нам нужно.


```smart header="Имена тегов (кроме XHTML) всегда пишутся в верхнем регистре"
В браузере существуют два режима обработки документа: HTML и XML. HTML-режим обычно используется для веб-страниц. XML-режим включается, если браузер получает XML-документ с заголовком: `Content-Type: application/xml+xhtml`.

В HTML-режиме значения `tagName/nodeName` всегда записаны в верхнем регистре. Будет выведено `BODY` вне зависимости от того, как записан тег в HTML `<body>` или `<BoDy>`.

В XML-режиме регистр сохраняется "как есть". В настоящее время XML-режим применяется редко.
```


## innerHTML: содержимое элемента

Свойство [innerHTML](https://w3c.github.io/DOM-Parsing/#widl-Element-innerHTML) позволяет получить  HTML-содержимое элемента в виде строки.

Мы также можем изменять его. Это один из самых мощный способов менять содержимое на странице.

Пример ниже показывает содержимое `document.body`, а затем полностью заменяет его:

```html run
<body>
  <p>Параграф</p>
  <div>DIV</div>

  <script>
    alert( document.body.innerHTML ); // читаем текущее содержимое
    document.body.innerHTML = 'Новый BODY!'; // заменяем содержимое
  </script>

</body>
```

Мы можем попробовать вставить некорректный HTML, браузер исправит наши ошибки:

```html run
<body>

  <script>
    document.body.innerHTML = '<b>тест'; // забыли закрыть тег
    alert( document.body.innerHTML ); // <b>тест</b> (исправлено)
  </script>

</body>
```

```smart header="Scripts don't execute"
Если `innerHTML` вставляет в документ тег `<script>` -- он становится частью HTML, но не запускается.

```

### Будьте внимательны: "innerHTML+=" осуществляет перезапись

Мы можем добавить HTML к элементу, используя `elem.innerHTML+="ещё html"`.

Вот так:

```js
chatDiv.innerHTML += "<div>Привет<img src='smile.gif'/> !</div>";
chatDiv.innerHTML += "Как дела?";
```

На практике этим следует пользоваться с большой осторожностью, так как фактически происходит *не* добавление, а перезапись.

Технически эти две строки делают одно и то же:

```js
elem.innerHTML += "...";
// это более короткая запись для:
*!*
elem.innerHTML = elem.innerHTML + "..."
*/!*
```

Другими словами, `innerHTML+=` делает следующее:

1. Старое содержимое удаляется.
2. На его место становится новое значение `innerHTML` (с добавленной строкой).

**Так как содержимое "обнуляется" и переписывается заново, все изображения и другие ресурсы будут перезагружены**.

В примере `chatDiv` выше строка `chatDiv.innerHTML+="Как дела?"` заново создаёт содержимое HTML и перезагружает `smile.gif` (надеемся, картинка закеширована). Если в `chatDiv` много текста и изображений, то эта перезагрузка будет очень заметна.

Есть и другие побочные эффекты. Например, если существующий текст выделен мышкой, то при переписывании `innerHTML` большинство браузеров снимут выделение. А если это поле ввода `<input>` с текстом, введенным пользователем, то текст будет удалён. И т.д.

К счастью, есть и другие способы добавить содержимое, не использующие `innerHTML`, которые мы изучим позже.

## outerHTML: HTML элемента целиком

Свойство `outerHTML` содержит HTML элемента целиком. Это как `innerHTML` плюс сам элемент.

Посмотрим на пример:

```html run
<div id="elem">Привет <b>Мир</b></div>

<script>
  alert(elem.outerHTML); // <div id="elem">Привет <b>Мир</b></div>
</script>
```

**Будьте осторожны: в отличие от `innerHTML`, запись в `outerHTML` не изменяет элемент. Вместо этого элемент заменяется целиком во внешнем контексте.**

Да, звучит странно, и это действительно необычно, поэтому здесь мы и отмечаем это особо.

Рассмотрим пример:

```html run
<div>Привет, мир!</div>

<script>
  let div = document.querySelector('div');

*!*
  // заменяем div.outerHTML на <p>...</p>
*/!*
  div.outerHTML = '<p>Новый элемент!</p>'; // (*)

*!*
  // Содержимое div осталось тем же!
*/!*
  alert(div.outerHTML); // <div>Привет, мир!</div>
</script>
```

В строке `(*)` мы получили HTML-узел `<div>...</div>` и заменили его на `<p>...</p>`. Во внешнем документе мы видим новое содержимое вместо `<div>`. Но старая переменная `div` осталась прежней.

Использование `outerHTML` не изменяет DOM-элемент, а извлекает его из внешнего контекста и вставляет вместо него новый HTML-код.

Иногда начинающие разработчики делают здесь ошибку: они заменяют `div.outerHTML`, а потом продолжают работать с `div`, как будто это изменившийся элемент.

Такое возможно с `innerHTML`, но не с `outerHTML`.

Мы можем записать в `outerHTML`, но имейте в виду, что это не меняет свойство узла. Вместо этого создается новый. Мы можем получить ссылку на новый элемент, обратившись к DOM.

## nodeValue/data: содержимое текстового узла

Свойство `innerHTML` есть только у узлов-элементов.

У других типов узлов есть свои аналоги: свойства `nodeValue` и `data`. Эти свойства очень похожи при использовании, есть лишь небольшие различия в спецификации. Мы будем использовать `data`, потому что оно короче.

Прочитаем содержимое текстового узла и комментария:

```html run height="50"
<body>
  Привет
  <!-- Комментарий -->
  <script>
    let text = document.body.firstChild;
*!*
    alert(text.data); // Привет
*/!*

    let comment = text.nextSibling;
*!*
    alert(comment.data); // Комментарий
*/!*
  </script>
</body>
```

Мы можем представить, для чего нам может понадобиться читать или изменять текстовый узел, но как быть с комментариями? Обычно они никого не интересуют, но иногда их используют для вставки информации и инструкций шаблонизатора в HTML, как в примере ниже:

```html
<!-- if isAdmin -->
  <div>Добро пожаловать, Admin!</div>
<!-- /if -->
```

...Затем JavaScript может прочитать и обработать эту информацию.

## textContent: просто текст

Свойство `textContent` предоставляет доступ к *тексту* внутри элемента за вычетом всех `<тегов>`.

Например:

```html run
<div id="news">
  <h1>Срочно в номер!</h1>
  <p>Марсиане атаковали человечество!</p>
</div>

<script>
  // Срочно в номер! Марсиане атаковали человечество!
  alert(news.textContent);
</script>
```

Как мы видим, возвращается только текст, как если бы все `<теги>` были вырезаны, но текст в них остался.

На практике редко появляется необходимость читать текст таким образом.

**Намного полезнее возможность записывать текст в `textContent`, т.к. позволяет писать текст "безопасным способом".**

Представим, что у нас есть произвольная строка, введённая пользователем, и мы хотим показать её.

- С `innerHTML` вставка происходит "как HTML", со всеми HTML-тегами.
- С `textContent` вставка получается "как текст", все символы трактуются буквально.

Сравним два тега div:

```html run
<div id="elem1"></div>
<div id="elem2"></div>

<script>
  let name = prompt("Введите ваше имя?", "<b>Винни-пух!</b>");

  elem1.innerHTML = name;
  elem2.textContent = name;
</script>
```

1. В первый `<div>` имя приходит "как HTML": все теги стали именно тегами, поэтому мы видим имя, выделенное жирным шрифтом.
2. Во второй `<div>` имя приходит "как текст", поэтому мы видим `<b>Винни-пух!</b>`.

В большинстве случаев мы рассчитываем получить от пользователя текст и хотим, чтобы он интерпретировался как текст. Мы не хотим, чтобы на сайте появлялся произвольный HTML-код. Присваивание через `textContent` -- один из способов от этого защититься.

## Свойство "hidden"

Атрибут и DOM-свойство "hidden" указывает на то, видим ли мы элемент или нет.

Мы можем использовать его в HTML или назначать при помощи JavaScript, как в примере ниже:

```html run height="80"
<div>Оба тега DIV внизу невидимы</div>

<div hidden>С атрибутом "hidden"</div>

<div id="elem">С назначенным JavaScript свойством "hidden"</div>

<script>
  elem.hidden = true;
</script>
```

Технически, `hidden` работает так же, как `style="display:none"`. Но его применение проще.

Мигающий элемент:


```html run height=50
<div id="elem">Мигающий элемент</div>

<script>
  setInterval(() => elem.hidden = !elem.hidden, 1000);
</script>
```

## Другие свойства

У DOM-элементов есть дополнительные свойства, многие из них предоставляются соответствующим классом:

- `value` -- значение для `<input>`, `<select>` и `<textarea>` (`HTMLInputElement`, `HTMLSelectElement`...).
- `href` -- адрес ссылки "href" для `<a href="...">` (`HTMLAnchorElement`).
- `id` -- значение атрибута "id" для всех элементов (`HTMLElement`).
- ...и многие другие...

Например:

```html run height="80"
<input type="text" id="elem" value="значение">

<script>
  alert(elem.type); // "text"
  alert(elem.id); // "elem"
  alert(elem.value); // значение
</script>
```

Большинство стандартных HTML-атрибутов имеют соответствующее DOM-свойство, и мы можем получить к нему доступ.

Если мы хотим узнать полный список поддерживаемых свойств для данного класса, можно найти их в спецификации. Например, класс HTMLInputElement описывается здесь: <https://html.spec.whatwg.org/#htmlinputelement>.

Если же нам нужно быстро что-либо узнать или нас интересует специфика определенного браузера -- мы всегда можем вывести элемент в консоль, используя `console.dir(elem)`, и прочитать все свойства. Или исследовать "свойства DOM" во вкладке Elements инструментов разработчика в браузере.

## Итого

Каждый DOM-узел принадлежит определенному классу. Классы формируют иерархию. Весь набор свойств и методов является результатом наследования.

Главные свойства DOM-узла:

`nodeType`
: Свойство `nodeType` позволяет узнать тип DOM-узла. Его значение - числовое: `1` для элементов,`3` для текстовых узлов, и т.д. Только для чтения.

`nodeName/tagName`
: Для элементов это свойство возвращает название тега (записывается в верхнем регистре, за исключением XML-режима). Для узлов-неэлементов `nodeName` описывает, что это за узел. Только для чтения.

`innerHTML`
: Внутреннее HTML-содержимое узла-элемента. Можно изменять.

`outerHTML`
: Полный HTML узла-элемента. Запись в `elem.outerHTML` не меняет `elem`. Вместо этого она заменяет его во внешнем контексте.

`nodeValue/data`
: Содержимое узла-неэлемента (текст, комментарий). Эти свойства практически одинаковые, обычно мы используем `data`. Можно изменять.

`textContent`
: Текст внутри элемента: HTML за вычетом всех `<тегов>`. Запись в него помещает текст в элемент, при этом все специальные символы и теги интерпретируются как текст. Можно использовать для защиты от вставки произвольного HTML кода.

`hidden`
: Когда значение установлено в `true`, делает то же самое, что и CSS `display:none`.

В зависимости от своего класса DOM-узлы имеют и другие свойства. Например у элементов `<input>` (`HTMLInputElement`) есть свойства `value`, `type`, у элементов `<a> (`HTMLAnchorElement`) есть `href` и т.д. Большинство стандартных HTML-атрибутов имеют соответствующие свойства DOM.

Впрочем, HTML-атрибуты и свойства DOM не всегда одинаковы, мы увидим это в следующей главе.
