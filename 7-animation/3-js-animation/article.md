# JavaScript-анимации

С помощью JavaScript-анимаций можно делать вещи, которые нельзя реализовать на CSS.

Например, движение по сложному пути с временной функцией, отличной от кривой Безье, или canvas-анимации.

## Использование setInterval

Анимация может быть представлена в виде последовательности кадров (каждый кадр немного меняет HTML/CSS-свойства).

Например, изменение `style.left` от `0px` до `100px` -- двигает элемент. И если мы будем изменять это с помощью `setInterval` изменяя  на `2px` с небольшими интервалами времени, например 50 раз в секунду, тогда изменения будут выглядеть плавными. Принцип такой же, как в кино: 24 кадров в секунду достаточно, чтобы создать эффект плавности.

Псевдокод мог бы выглядеть так:

```js
let timer = setInterval(function() {
  if (animation complete) clearInterval(timer);
  else increase style.left by 2px
}, 20); // изменять на 2px каждые 20ms, это около 50 кадров в секунду
```

Более детальная реализация этой анимации:

```js
let start = Date.now(); // запомнить время начала

let timer = setInterval(function() {
  // сколько времени прошло с начала анимации?
  let timePassed = Date.now() - start;

  if (timePassed >= 2000) {
    clearInterval(timer); // закончить анимацию через 2 секунды
    return;
  }

  // отрисовать анимацию на момент timePassed, прошедший с начала анимации
  draw(timePassed);

}, 20);

// как timePassed меняет значение от 0 до 2000
// left изменяет значение от 0px до 400px
function draw(timePassed) {
  train.style.left = timePassed / 5 + 'px';
}
```

Для просмотра демо, кликните на него:

[codetabs height=200 src="move"]

## Использование requestAnimationFrame

Теперь, давайте представим, что у нас есть несколько анимаций, работающих одновременно.

Если мы запустим их независимо с помощью `setInterval(..., 20)`, тогда браузеру будет необходимо выполнять отрисовку гораздо чаще, чем раз в `20ms`.

Это происходит из-за того, что каждая анимация имеет свое собственное время старта и "каждые 20 миллисекунд" для разных анимаций -- разные. Интервалы не выравнены и у нас будет несколько независимых срабатываний в течение `20ms`

Другими словами:

```js
setInterval(function() {
  animate1();
  animate2();
  animate3();
}, 20)
```

...Меньше нагружают систему, чем три независимых функции:

```js
setInterval(animate1, 20); // независимые анимации
setInterval(animate2, 20); // в разных местах кода
setInterval(animate3, 20);
```

Независимые перерисовки, сгруппированные вместе, облегчают процесс перерисовки для браузера (и выглядят более плавными для пользователя).

Существует еще одна вещь, про которую надо помнить: когда CPU перегружен или еще по какой-то причине (например, когда вкладка браузера скрыта), нам не следует запускать перерисовку каждые `20ms`. 

Но как нам узнать об этом в JavaScript? Спецификация о [времени анимации](http://www.w3.org/TR/animation-timing/) описывает функцию `requestAnimationFrame`, которая решает все описанные проблемы и делает даже больше.

Синтаксис:
```js
let requestId = requestAnimationFrame(callback)
```

Такой вызов планирует запуск функции `callback` в ближайшее время, когда браузер сочтёт возможным осуществить анимацию.

Если в `callback` происходит изменение элемента, тогда оно будет выполнено с другими `requestAnimationFrame` и CSS-анимациями. Таким образом браузер выполнит один геометрический пересчет и отрисовку, вместо нескольких.

Значение `requestId` может быть использовано для отмены анимации:
```js
// отмена запланированного запуска callback
cancelAnimationFrame(requestId);
```

Функция `callback` имеет один аргумент -- время прошедшее с момента начала загрузки страницы в миллисекундах. Это значение может быть получено с помощью вызова [performance.now()](mdn:api/Performance/now).

Существуют причины, когда запуск анимации откладывается (обычно выполняется практически сразу после `requestAnimationFrame`), например CPU перегружен или батарейка ноутбука практически села.

Код ниже показывает время проходящее между первыми 10 запусками `requestAnimationFrame`. Обычно оно 10-20ms:

```html run height=40 refresh
<script>
  let prev = performance.now();
  let times = 0;

  requestAnimationFrame(function measure(time) {
    document.body.insertAdjacentHTML("beforeEnd", Math.floor(time - prev) + " ");
    prev = time;

    if (times++ < 10) requestAnimationFrame(measure);
  })
</script>
```

## Структура анимации

Теперь мы можем создать более сложную функцию анимации с помощью `requestAnimationFrame`:

```js
function animate({timing, draw, duration}) {

  let start = performance.now();

  requestAnimationFrame(function animate(time) {
    // timeFraction изменяется от 0 до 1
    let timeFraction = (time - start) / duration;
    if (timeFraction > 1) timeFraction = 1;

    // вычисление текущего состояния анимации
    let progress = timing(timeFraction)

    draw(progress); // отрисовать её

    if (timeFraction < 1) {
      requestAnimationFrame(animate);
    }

  });
}
```

Функция `animate` имеет три аргумента, которые описывают анимацию:

`duration`
: Продолжительность анимации. Например, `1000`.

`timing(timeFraction)`
: Временная функция, как CSS-свойство `transition-timing-function`, которая будет вычислять прогресс анимации (как ось `y` у кривой Безье) в зависимости от прошедшего времени (`0` в начале, `1` в конце).

    Например, линейная функция значит, что анимация идет с одной и той же скоростью:

    ```js
    function linear(timeFraction) {
      return timeFraction;
    }
    ```

    График функции:
    ![](linear.png)

    Это как если бы в `transition-timing-function` передать значение `linear`. Ниже будут представлены более интересные примеры.

`draw(progress)`
: Функция отрисовки, которая получает аргументом значение прогресса анимации и отрисовывает его. Значение `progress=0` означает что анимация находится в начале, и значение `progress=1` -- в конце.

    Эта та функция, которая на самом деле и рисует анимацию.

    Вот как она могла бы двигать элемент:
    ```js
    function draw(progress) {
      train.style.left = progress + 'px';
    }
    ```

    ...Или что угодно ещё, мы можем анимировать что-угодно, любым доступным способом.


Теперь давайте используем нашу функцию, чтобы анимировать свойство `width` от `0` до `100%`.

Нажмите на элемент для того, чтобы посмотреть пример:

[codetabs height=60 src="width"]

Код:

```js
animate({
  duration: 1000,
  timing(timeFraction) {
    return timeFraction;
  },
  draw(progress) {
    elem.style.width = progress * 100 + '%';
  }
});
```

В отличии от CSS-анимаций, мы можем создать любую временную функцию и любую функцию отрисовки. Временная функция не будет ограничена только кривой Безье, а функция `draw` может менять не только свойства, но и создавать новые элементы (например, для создания анимации фейерверка).

## Временные функции

Мы уже рассмотрели самый простой пример линейной функции выше.

Давайте посмотрим другие. Мы попробуем выполнить анимации с разными временными функциями, чтобы посмотреть как они работают.

### Степень n

Если мы хотим ускорить анимацию, мы можем возвести `progress` в степень `n`.

Например, параболическая кривая:

```js
function quad(timeFraction) {
  return Math.pow(timeFraction, 2)
}
```

График:

![](quad.png)

Посмотрим в действии (клик для активации):

[iframe height=40 src="quad" link]

...Или кубическая функция, или еще большее число `n`. Для ускорения надо увеличивать степень.

Вот график для функции `progress` в степени `5`:

![](quint.png)

В действии:

[iframe height=40 src="quint" link]

### Дуги

Функция:

```js
function circ(timeFraction) {
  return 1 - Math.sin(Math.acos(timeFraction));
}
```

График:

![](circ.png)

[iframe height=40 src="circ" link]

### Обратно: выстрел из лука

Эта функция совершает "выстрел из лука". В начале "оттягивается тетива" и потом "выстрел".

Эта функция имеет дополнительный аргумент `x`, в отличии от предыдущей, который контролирует расстояния "оттягивания тетивы".

Код:

```js
function back(x, timeFraction) {
  return Math.pow(timeFraction, 2) * ((x + 1) * timeFraction - x)
}
```

**График для `x = 1.5`:**

![](back.png)

Для анимации мы используем `x` с определенным значением. Пример для `x` со значением `1.5`:

[iframe height=40 src="back" link]

### Отскоки

Представьте, мы кидаем мячик вниз. Он падает, потом нескольк раз подпрыгивает и останавливается.

Функции `bounce` делает тоже самое, но в обратном порядке: "отскоки" начинаются сразу. Для этого заданы специальные коэффициенты:

```js
function bounce(timeFraction) {
  for (let a = 0, b = 1, result; 1; a += b, b /= 2) {
    if (timeFraction >= (7 - 4 * a) / 11) {
      return -Math.pow((11 - 6 * a - 11 * timeFraction) / 4, 2) + Math.pow(b, 2)
    }
  }
}
```

В действии:

[iframe height=40 src="bounce" link]

### Элластичная анимация

Еще одна "элластичная" функция, которая принимает дополнительный параметр `x` для "начального отрезка".

```js
function elastic(x, timeFraction) {
  return Math.pow(2, 10 * (timeFraction - 1)) * Math.cos(20 * Math.PI * x / 3 * timeFraction)
}
```

**График для `x=1.5`:**
![](elastic.png)

В действии со значением `x=1.5`:

[iframe height=40 src="elastic" link]

## Реверсивные функции ease*

Итак у нас получилась коллекция временных функций. Их прямое использование называется «easeIn».

Иногда нужно показать анимацию в обратном режиме. Преобразование функции, которое даёт такой эффект, называется «easeOut».

### easeOut

В режиме "easeOut" `timing` функции оборачиваются функцией `timingEaseOut`:

```js
timingEaseOut(timeFraction) = 1 - timing(1 - timeFraction)
```
Другими словами, мы имеем функцию "трансформер" -- `makeEaseOut`, которая берет "обычныую" временную функцию и обрачивает её.

```js
// принимает временную функцию и возрващает трансформированный вариант
function makeEaseOut(timing) {
  return function(timeFraction) {
    return 1 - timing(1 - timeFraction);
  }
}
```

Например, мы можем взять функцию `bounce` описанную выше:

```js
let bounceEaseOut = makeEaseOut(bounce);
```

Таким образом отскоки будут не в начале функции, а в конце. Смотрится гораздо лучше:

[codetabs src="bounce-easeout"]

Ниже мы можем увидеть, как трансформации изменяют поведение функции:

![](bounce-inout.png)

Если есть такой анимационный эффект, как подпрыгивание -- то после трансформации он будет показан в конце.

На графике выше красным цветом обозначена <span style="color:#EE6B47">обычная функция</span> и синим -- <span style="color:#62C0DC">инверитированная</span>.

- Обычный отскок -- объект сначало медленно скачет внезу, а затем резко прыгает вверх в конце.
- После `easeOut` -- объект сначало прыгает вверх и потом отскакивает там.

### easeInOut

Эффект может потребоваться не только в начале или конце, но и одновременно и в начале и в конце. Такая транформация называется "easeInOut".

Возьмем временную функцию, анимация будет высчитываться следующим образом:

```js
if (timeFraction <= 0.5) { // первая половина анимации
  return timing(2 * timeFraction) / 2;
} else { // вторая половина анимации
  return (2 - timing(2 * (1 - timeFraction))) / 2;
}
```

Код функции-транфсормера:

```js
function makeEaseInOut(timing) {
  return function(timeFraction) {
    if (timeFraction < .5)
      return timing(2 * timeFraction) / 2;
    else
      return (2 - timing(2 * (1 - timeFraction))) / 2;
  }
}

bounceEaseInOut = makeEaseInOut(bounce);
```

В действии, `bounceEaseInOut`:

[codetabs src="bounce-easeinout"]

Функция "easeInOut" объединяет два графика в один: `easeIn` (обычный) для первой половины анимации and `easeOut` (обратный) -- для второй половины.

Разница хорошо заметна, если сравнивать графики `easeIn`, `easeOut` и `easeInOut` для функции `circ`.

![](circ-ease.png)

- <span style="color:#EE6B47">Красный</span> обычный вариант `circ` (`easeIn`).
- <span style="color:#8DB173">Зеленый</span> -- `easeOut`.
- <span style="color:#62C0DC">Синий</span> -- `easeInOut`.

Как видно, график первой половины анимации представляет собой уменьшенный `easeIn`, а второй – уменьшенный `easeOut`. В результате, анимация начинается и заканчивается одинаковым эффектом.

## Больше про функцию "draw"

Вместо передвижения элемента мы можем делать что-нибудь ещё. Всё что нам для этого надо -- это правильная функция `draw`.

Вот пример "скачащей" анимации набирания текста:

[codetabs src="text"]

## Итого

JavaScript может помочь в тех случаях, когда CSS не справляется или нужен жесткий контроль над анимацией. JavaScript-анимации должны быть сделаны с помощью `requestAnimationFrame`. Это встроенный метод браузера, который вызывает переданную в него функцию в тот момент, когда браузер готовится совершить перерисовку (обычно это происходит быстро, но конкретные задержки зависят от браузера).

Когда вкладка скрыта, на ней совсем не происходит перерисовок и функция не будет вызвана: анимация будет приостановлена и не потратит ресурсы. Это хорошо.

Вот функция-помошник `animate` для создания анимации:

```js
function animate({timing, draw, duration}) {

  let start = performance.now();

  requestAnimationFrame(function animate(time) {
    // timeFraction изменяется от 0 до 1
    let timeFraction = (time - start) / duration;
    if (timeFraction > 1) timeFraction = 1;

    // вычисление текущего состояния анимации
    let progress = timing(timeFraction)

    draw(progress); // отрисовать её

    if (timeFraction < 1) {
      requestAnimationFrame(animate);
    }

  });
}
```

Опции:

- `duration` -- общая продолжительность анимации в миллисекундах.
- `timing` -- функция вычисления прогресса анимации. Получается момент времени от 0 до 1, возвращает прогресс анимации, обычно тоже от 0 до 1.
- `draw` -- функция отрисовки анимации.

Конечно, мы могли бы улучшить функцию-хелпер и добавить в неё больше наворотов. Но JavaScript-анимации не создаются в повседневной работе, их используют когда хотят сделать что-то интересное и необычное. Не стоит усложнять функцию, до тех пор пока они вам не понадобились.

JavaScript-анимации могут использовать любые временные функции. Мы рассмотрели множество примеров и их вариаций, чтобы сделать их еще более универсальными. В отличии от CSS, мы здесь не ограничены только кривой Безье.

Тоже самое и с `draw`: мы можем анимировать всё что угодно, не только CSS-свойства.
