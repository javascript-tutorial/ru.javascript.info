
# Промисы: обработка ошибок

Иногда при выполнении асинхронного кода могут возникать ошибки: соответствующий промис будет отклонён. Например, если удалённый сервер недоступен, то `fetch` вернёт ошибку. Мы можем использовать `.catch`, чтобы перехватывать эти ошибки (отклонённые промисы).

Для перехвата ошибок хорошо подходят цепочки промисов. Если промис будет отклонён, то управление над промисом переходит в ближайший перехватчик, дальше по цепочке. Это очень удобно на практике.

Например, в представленном ниже примере указана неправильная ссылка (сайт не существует) и `.catch` перехватывает ошибку:

```js run
*!*
fetch('https://no-such-server.blabla') // ошибка
*/!*
  .then(response => response.json())
  .catch(err => alert(err)) // TypeError: failed to fetch (текст может отличаться)
```

Или, может быть, с сервером всё в порядке, но в ответе мы получим некорректный JSON:

```js run
fetch('/') // сейчас fetch выполнится, сервер присылает в ответ HTML-страницу
*!*
  .then(response => response.json()) // ошибка: ответ не является JSON
*/!*
  .catch(err => alert(err)) // SyntaxError: Unexpected token < in JSON at position 0
```

Самый лёгкий путь перехватить все ошибки - это добавить `.catch` в конец цепочки:

```js run
fetch('/article/promise-chaining/user.json')
  .then(response => response.json())
  .then(user => fetch(`https://api.github.com/users/${user.name}`))
  .then(response => response.json())
  .then(githubUser => new Promise((resolve, reject) => {
    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    img.className = "promise-avatar-example";
    document.body.append(img);

    setTimeout(() => {
      img.remove();
      resolve(githubUser);
    }, 3000);
  }))
*!*
  .catch(error => alert(error.message));
*/!*
```

Если все в порядке, то `.catch` вообще не выполнится. Но если любой из промисов будет отклонён (проблемы с сетью или некорректная json-строка, или что угодно другое), то ошибка будет перехвачена.

## Неявный try..catch

Вокруг функции промиса и обработчиков находится "невидимый `try..catch`". Если происходит исключение, то оно перехватывается, и промис считается отклонённым с этой ошибкой.

Например, этот код:

```js run
new Promise((resolve, reject) => {
*!*
  throw new Error("Whoops!");
*/!*
}).catch(alert); // Error: Whoops!
```

...Работает так же, как и этот:

```js run
new Promise((resolve, reject) => {
*!*
  reject(new Error("Whoops!"));
*/!*  
}).catch(alert); // Error: Whoops!
```

"Невидимый `try..catch`" вокруг промиса, автоматически перехватывает ошибку и рассматривает её как отклонённый промис.

Это работает не только в промисе, но и в обработчиках. Если мы пробросим ошибку (`throw`) из обработчика (`.then`), то промис будет считаться отклонённым, и управление перейдёт к ближайшему обработчику ошибок.

Пример:

```js run
new Promise((resolve, reject) => {
  resolve("ok");
}).then((result) => {
*!*
  throw new Error("Whoops!"); // пробрасываем ошибку
*/!*
}).catch(alert); // Error: Whoops!
```

Это происходит для всех ошибок, не только для тех, которые вызваны оператором `throw`. Например, программная ошибка:

```js run
new Promise((resolve, reject) => {
  resolve("ok");
}).then((result) => {
*!*
  blabla(); // нет такой функции
*/!*
}).catch(alert); // ReferenceError: blabla is not defined
```

Финальный `.catch` не только перехватывает явно отклонённые промисы, но и случайные ошибки в обработчиках выше.

## Повторное пробрасывание ошибок (rethrowing)

Как мы уже заметили, `.catch` ведёт себя как `try..catch`. Мы можем иметь столько обработчиков `.then`, сколько мы хотим, и затем использовать один `.catch` в конце, чтобы перехватить ошибки из всех обработчиков.

В обычном `try..catch` мы можем проанализировать ошибку и повторно пробросить дальше, если не можем её обработать. То же самое возможно для промисов.

Если мы пробросим (`throw`) ошибку внутри блока `.catch`, то управление перейдёт к следующему ближайшему обработчику ошибок. И если мы обработаем ошибку и завершим работу обработчика нормально, то продолжит работу ближайший успешный обработчик `.then`.

В примере ниже `.catch` успешно обрабатывает ошибку:

```js run
// the execution: catch -> then
new Promise((resolve, reject) => {

  throw new Error("Whoops!");

}).catch(function(error) {

  alert("Ошибка обработана, продолжить работу");

}).then(() => alert("Управление перейдёт в следующий then"));
```

Здесь блок `.catch` завершается нормально. Поэтому вызывается следующий успешный обработчик `.then`.

В примере ниже мы видим другую ситуацию с блоком `.catch`. Обработчик `(*)` перехватывает ошибку и не может обработать её (например, он знает как обработать только `URIError`), поэтому ошибка пробрасывается далее:

```js run
// the execution: catch -> catch -> then
new Promise((resolve, reject) => {

  throw new Error("Whoops!");

}).catch(function(error) { // (*)

  if (error instanceof URIError) {
    // обрабатываем ошибку
  } else {
    alert("Не могу обработать ошибку");

*!*
    throw error; // пробрасывает эту или другую ошибку в следующий catch
*/!*
  }

}).then(function() {
  /* никогда не выполнится */
}).catch(error => { // (**)

  alert(`Неизвестная ошибка: ${error}`);
  // ничего не возвращаем => выполнение продолжается в нормальном режиме

});
```

Затем управление переходит от первого блока `.catch` `(*)` к следующему `(**)`, вниз по цепочке.

В следующей секции мы рассмотрим практическое применение повторного пробрасывания.

## Пример обработки ошибок fetch

Давайте улучшим обработку ошибок для примера "загрузка пользователя".

Промис, возвращаемый [fetch](mdn:api/WindowOrWorkerGlobalScope/fetch), считается отклонённым, когда невозможно сделать запрос. Например, удалённый сервер недоступен или неверный URL. Но, если удалённый сервер отвечает с ошибкой 404 или даже 500, тогда ответ считается успешно полученным.

Что если в строке с `(*)` сервер возвращает не JSON-страницу с 500 ошибкой? Что если такого пользователя нет, и GitHub возвращает страницу с 404 ошибкой в строке с `(**)`?

```js run
fetch('no-such-user.json') // (*)
  .then(response => response.json())
  .then(user => fetch(`https://api.github.com/users/${user.name}`)) // (**)
  .then(response => response.json())
  .catch(alert); // SyntaxError: Unexpected token < in JSON at position 0
  // ...
```


На данный момент код пытается загрузить ответ как JSON-строку, несмотря ни на что, и умирает с синтаксической ошибкой. Вы можете сами увидеть это, запустив представленный выше пример, так как файл `no-such-user.json` не существует.

Это не хорошо, потому что ошибка просто проваливается сквозь всю цепочку, без подробностей: что за ошибка и где.

Итак, давайте добавим ещё один шаг: мы должны проверить свойство c HTTP-статусом: `response.status`, и если он не 200, тогда сгенерировать ошибку.

```js run
class HttpError extends Error { // (1)
  constructor(response) {
    super(`${response.status} for ${response.url}`);
    this.name = 'HttpError';
    this.response = response;
  }
}

function loadJson(url) { // (2)
  return fetch(url)
    .then(response => {
      if (response.status == 200) {
        return response.json();
      } else {
        throw new HttpError(response);
      }
    })
}

loadJson('no-such-user.json') // (3)
  .catch(alert); // HttpError: 404 for .../no-such-user.json
```

1. Мы создали специальный класс для HTTP ошибок, чтобы отличать их от других типов ошибок. Кроме того, новый класс имеет конструктор, который принимает объект `response` и сохраняет его в ошибке. Таким образом, код обработки ошибок сможет получить доступ к ответу сервера.
2. Затем мы объединили код запроса данных и обработки ошибки в одну функцию, которая получает данные по `url` *и* обрабатывает ответ со статусом 200 как выполнившийся, а любой другой статус как ошибку. Это удобно, потому что нам часто необходима такая логика.
3. Сейчас `alert` показывает более полезное сообщение.

Самое замечательное в нашем собственном классе для ошибок заключается в том, что мы можем легко проверить тип ошибки при помощи `instanceof`.

Например, мы можем создать запрос и после, если получим 404, попросить пользователя поправить введённую информацию.

Код ниже загружает пользователя с указанным именем из GitHub. Если такого пользователя не существует, то он запрашивает правильное имя:

```js run
function demoGithubUser() {
  let name = prompt("Enter a name?", "iliakan");

  return loadJson(`https://api.github.com/users/${name}`)
    .then(user => {
      alert(`Full name: ${user.name}.`);
      return user;
    })
    .catch(err => {
*!*
      if (err instanceof HttpError && err.response.status == 404) {
*/!*
        alert("Нет такого пользователя, пожалуйста, заполните снова.");
        return demoGithubUser();
      } else {
        throw err; // (*)
      }
    });
}

demoGithubUser();
```

Обратите внимание: в приведённом коде `.catch` перехватывает все ошибки, но "знает как обработать" только `HttpError 404`. В данном примере это означает, что пользователя не существует, в этом случае `.catch` повторно запускает ввод имени.

Для других ошибок код понятия не имеет, что могло пойти не так. Может быть это программная ошибка или что-то другое. Поэтому просто повторно пробрасывает её в строке с `(*)`.

## Необработанные ошибки

Что произойдёт, если ошибка не будет обработана? Например, после повторного пробрасывания в строке с `(*)` в примере выше.

Или если мы просто забыли добавить обработку ошибки в самый конец цепочки, как здесь:

```js untrusted run refresh
new Promise(function() {
  noSuchFunction(); // Ошибка (нет такой функции)
})
  .then(() => {
    // обработчики .then, один или более
  }); // без .catch в самом конце!
```

В случае ошибки промис становится "отклонённым", и выполнение переходит к ближайшему обработчику ошибок. Но в примере выше нет никакого обработчика. Поэтому ошибка как бы "застревает", её некому обработать.

На практике, как и при обычных необработанных ошибках, это означает, что что-то пошло сильно не так.

Что происходит, когда обычная ошибка не перехвачена `try..catch`? Скрипт умирает. Похожее происходит и в случае необработанной ошибки промиса.

JavaScript-движок отслеживает такие ситуации и генерирует в этом случае глобальную ошибку. Вы можете увидеть её в консоли, если запустите пример выше.

В браузере мы можем поймать такие ошибки, используя событие `unhandledrejection`:

```js run
*!*
window.addEventListener('unhandledrejection', function(event) {
  // объект события имеет два специальных свойства:
  alert(event.promise); // [object Promise] - промис, который сгенерировал ошибку
  alert(event.reason); // Error: Whoops! - объект ошибки, которая не была обработана
});
*/!*

new Promise(function() {
  throw new Error("Whoops!");
}); // нет обработчика ошибок
```

Это событие является частью [HTML-стандарта](https://html.spec.whatwg.org/multipage/webappapis.html#unhandled-promise-rejections).

Если происходит ошибка, и она не перехватывается, отсутствует `.catch`, то генерируется событие `unhandledrejection`, и соответствующий объект `event` содержит информацию об ошибке.

Обычно такие ошибки неустранимы, поэтому лучше всего - информировать пользователя о проблеме и, возможно, отправить информацию об ошибке на сервер.

В не-браузерных средах, таких как Node.js, есть другие похожие способы отслеживания необработанных ошибок.


## Итого

- `.catch` перехватывает все виды отклонённых промисов: будь то вызов `reject()` или ошибка, брошенная в обработчике при помощи `throw`.
- Необходимо размещать `.catch` там, где мы хотим обработать ошибки и знаем, как это сделать. Обработчик может проанализировать ошибку (полезны пользовательские классы ошибок) и пробросить её, если ничего не знает о ней (может быть, это программная ошибка).
- Можно и совсем не использовать `.catch`, если нет нормального способа восстановиться после ошибки.
- В любом случае нам следует использовать обработчик события `unhandledrejection` (для браузеров и аналог для других окружений), чтобы отслеживать необработанные ошибки и информировать о них пользователя (и, возможно, наш сервер), благодаря чему наше приложения никогда не будет "просто умирать".

И, наконец, если у нас имеется индикатор загрузки, тогда `finally` - это отличное место, чтобы остановить его, когда загрузка завершена:

```js run
function demoGithubUser() {
  let name = prompt("Enter a name?", "iliakan");

*!*
  document.body.style.opacity = 0.3; // (1) запускаем индикатор загрузки
*/!*

  return loadJson(`https://api.github.com/users/${name}`)
*!*
    .finally(() => { // (2) останавливаем индикатор загрузки
      document.body.style.opacity = '';
      return new Promise(resolve => setTimeout(resolve)); // (*)
    })
*/!*
    .then(user => {
      alert(`Full name: ${user.name}.`);
      return user;
    })
    .catch(err => {
      if (err instanceof HttpError && err.response.status == 404) {
        alert("Нет такого пользователя, пожалуйста, заполните снова.");
        return demoGithubUser();
      } else {
        throw err;
      }
    });
}

demoGithubUser();
```

Здесь, в строке `(1)`, мы запускаем индикатор загрузки, затемняя документ. Метод не имеет значения, можно использовать любой другой индикатор загрузки.

Когда промис будет выполнен, будет он успешно выполнен или произойдёт ошибка, `finally` сработает в строке `(2)` и остановит индикатор загрузки.

Здесь есть небольшой браузерный трюк в строке с `(*)`, где возвращаем в `finally` промис с нулевым таймаутом. Просто некоторым браузерам (например, Chrome) нужно "немного времени" вне обработчиков промиса, чтобы отрисовать изменения в документе. Таким образом, это гарантирует, что индикатор загрузки визуально остановится, прежде чем управление пойдёт дальше по цепочке.
