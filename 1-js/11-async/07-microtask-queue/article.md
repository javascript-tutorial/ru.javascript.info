
# Микрозадачи и цикл событий

Обработчики промисов `.then`/`.catch`/`.finally` всегда асинхронны.

Даже когда промис сразу же выполнен, код в строках *ниже* `.then`/`.catch`/`.finally` будет запущен до этих обработчиков.

Вот демо:

```js run
let promise = Promise.resolve();

promise.then(() => alert("промис выполнен"));

alert("код выполнен"); // этот alert показывается первым
```

Если вы запустите его, сначала вы  увидите `код выполнен`, а потом `промис выполнен`.

Это странно, потому что промис определенно был выполнен с самого начала.

Почему `.then` срабатывает позже? Что происходит?

## Микрозадачи

Асинхронные задачи требуют правильного управления. Для этого стандарт предусматривает внутреннюю очередь `PromiseJobs`, более известную как "очередь микрозадач (microtask queue)" (термин V8).

Как сказано в [спецификации](https://tc39.github.io/ecma262/#sec-jobs-and-job-queues):

- Очередь определяется как первым-пришёл-первым-ушёл (FIFO): задачи, попавшие в очередь первыми, выполняются тоже первыми.
- Выполнение задачи происходит только в том случае, если ничего больше не запущено.

Или, проще говоря, когда промис выполнен, его обработчики `.then/catch/finally` попадают в очередь. Они пока не выполняются. Движок JavaScript берёт задачу из очереди и выполняет её, когда он освободится от выполнения текущего кода.

Вот почему сообщение "код выполнен" в примере выше будет показано первым.

![](promiseQueue.png)

Обработчики промисов всегда проходят через эту внутреннюю очередь.

Если есть цепочка с несколькими `.then/catch/finally`, то каждый из них выполняется асинхронно. То есть сначала ставится в очередь, а потом выполняется, когда выполнение текущего кода завершено и добавленные ранее в очередь обработчики выполнены.

**Но что если порядок имеет значение для нас? Как мы можем вывести `код выполнен` после `промис завершен`?**

Легко, используя `.then`:

```js run
Promise.resolve()
  .then(() => alert("промис выполнен!"))
  .then(() => alert("код выполнен"));
```

Теперь порядок стал таким, как было задумано.

## Цикл событий

Поток выполнения браузерного JavaScript, как и Node.js, основан на *цикле событий (event loop)*. 

"Цикл событий" - это процесс, при котором движок спит и ждёт событий, когда появятся - обрабатывает их и снова засыпает.

События могут приходить как из внешних источников, например действий пользователя, так и быть сигналами об окончании различных внутренних задач.

Примеры событий:
- `mousemove`, пользователь двигает курсор мыши.
- `setTimeout`, запланированный вызов обработчика.
- внешний `<script src="...">` загружен, готов к выполнению.
- сетевая операция, например, `fetch` завершена.
- ... и т.д.

Что-то происходит -- движок это обрабатывает -- и снова ждёт наступления события (пока он находится в спящем режиме, потребление ресурсов CPU близко к нулю).

![](eventLoop.png)

Как вы можете видеть, здесь также есть очередь. Так называемая "очередь макрозадач (macrotask queue)" (термин v8).

В случае, если событие наступает, когда движок занят, его обработка добавляется в очередь. 

Например, когда движок занят обработкой сетевого запроса `fetch`, пользователь может перемещать указатель мыши, вызывая событие `mousemove`, может сработать `setTimeout` и т.д., как показано на картинке выше.

События из очереди макрозадач обрабатываются по принципу: первый пришёл - первый обслужен. Когда движок браузера заканчивает с выполнением `fetch`, он обрабатывает событие `mousemove`, потом вызывает обработчик `setTimeout` и т.д.

Пока всё довольно просто, не так ли? Движок занят, соответственно другие задачи ждут в очереди.

А сейчас важный момент.

**Очередь микрозадач имеет приоритет.**

Другими словами, движок сначала выполняет все микрозадачи, а потом макрозадачи. Обработка промисов всегда имеет приоритет.

Например, посмотрим на следующий код:

```js run
setTimeout(() => alert("timeout"));

Promise.resolve()
  .then(() => alert("promise"));

alert("code");
```

Каков тут порядок исполнения? 

1. `code` показывается первым, т.к. это обычный синхронный вызов.
2. `promise` отображается вторым, т.к. `.then` проходит через очередь микрозадач и запускается после текущего кода.
3. `timeout`- показывается последним, т.к. это макрозадача.

Может случиться так, что в процессе выполнения макрозадачи будет создан новый промис.

Или наоборот, в микрозадаче будет запланирована макрозадача (например `setTimeout`).

Например, здесь в `.then` запланирован `setTimeout`:

```js run
Promise.resolve()
  .then(() => {
    setTimeout(() => alert("timeout"), 0);
  })
  .then(() => {
    alert("promise");
  });
```

Естественно, `promise` отображается первым, т.к. макрозадача `setTimeout` ожидает в менее приоритетной очереди макрозадач. 

Поэтому макрозадачи выполняются, только когда промисы дают движку "свободное время". Так, если у нас есть цепочка промисов, которые выполняются один за другим без задержек, то `setTimeout` или обработчик действия пользователя не может попасть в середину между ними.


## Необработанные ошибки

Помните "необработанные ошибки" из главы <info:promise-error-handling>?

Теперь мы можем описать, как именно JavaScript понимает, что ошибка не обработана.

**"Необработанная ошибка" возникает в случае, если ошибка промиса не обрабатывается в конце очереди микрозадач.**

Например, рассмотрим этот код:

```js run
let promise = Promise.reject(new Error("Promise Failed!"));

window.addEventListener('unhandledrejection', event => {
  alert(event.reason); // Промис выполнен с ошибкой!
});
```

Мы создаём `promise`, завершённый с ошибкой, и не обрабатываем ошибку. В итоге мы видим событие "unhandled rejection" (также будет выведено в консоли).

Мы бы его не получили, если бы добавили `.catch`, например так:

```js run
let promise = Promise.reject(new Error("Promise Failed!"));
*!*
promise.catch(err => alert('поймана'));
*/!*

// ошибки нет, всё тихо
window.addEventListener('unhandledrejection', event => alert(event.reason));
```

А сейчас попробуем также поймать ошибку, но после `setTimeout`:

```js run
let promise = Promise.reject(new Error("Promise Failed!"));
*!*
setTimeout(() => promise.catch(err => alert('поймана')));
*/!*

// Error: Promise Failed!
window.addEventListener('unhandledrejection', event => alert(event.reason));
```

Снова появилось событие о необработанной ошибке. Почему? Потому что `unhandledrejection` генерируется, когда очередь микрозадач выполнена. Движок проверяет промисы и, если какой-либо из них в состоянии "rejected", то генерируется это событие.

В примере выше `.catch`, добавленный в `setTimeout`, также срабатывает, но позже, уже после возникновения `unhandledrejection`.

## Итого

- Обработка промисов всегда асинхронная, т.к. все действия промисов проходят через внутреннюю очередь "promise jobs", так называемую "очередь микрозадач (microtask queue)" (термин v8).

    **Таким образом, обработчики `.then/catch/finally` вызываются после выполнения текущего кода.**

    Если нам нужно гарантировать выполнение какого-то кода после `.then/catch/finally`, то лучше всего добавить его вызов в цепочку `.then`.

- Существует также "очередь макрозадач (macrotask queue)", которая содержит различные события, результаты сетевых операций, запланированные вызовы `setTimeout` и т.д., которые называются "макрозадачами (macrotasks)" (термин v8).

    Движок использует очередь макрозадач для их выполнения в порядке появления.

    **Макрозадачи запускаются после выполнения кода *и* после того, как очередь микрозадач будет пуста.**

    Другими словами, они имеют более низкий приоритет.

Таким образом, порядок выполнения следующий: обычный код, потом обработка промисов, потом всё остальное (события и т.д.).
