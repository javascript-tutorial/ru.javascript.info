
# –Æ–Ω–∏–∫–æ–¥, –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ —Å—Ç—Ä–æ–∫

```warn header="–ì–ª—É–±–æ–∫–æ–µ –ø–æ–≥—Ä—É–∂–µ–Ω–∏–µ –≤ —Ç–µ–º—É"
–≠—Ç–æ—Ç —Ä–∞–∑–¥–µ–ª –±–æ–ª–µ–µ –ø–æ–¥—Ä–æ–±–Ω–æ –æ–ø–∏—Å—ã–≤–∞–µ—Ç, –∫–∞–∫ —É—Å—Ç—Ä–æ–µ–Ω—ã —Å—Ç—Ä–æ–∫–∏. –¢–∞–∫–∏–µ –∑–Ω–∞–Ω–∏—è –ø—Ä–∏–≥–æ–¥—è—Ç—Å—è, –µ—Å–ª–∏ –≤—ã –Ω–∞–º–µ—Ä–µ–Ω—ã —Ä–∞–±–æ—Ç–∞—Ç—å —Å —ç–º–æ–¥–∑–∏, —Ä–µ–¥–∫–∏–º–∏ –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–º–∏ —Å–∏–º–≤–æ–ª–∞–º–∏, –∏–µ—Ä–æ–≥–ª–∏—Ñ–∞–º–∏, –∏ —Ç.–¥.
```

–ö–∞–∫ –º—ã —É–∂–µ –∑–Ω–∞–µ–º, —Å—Ç—Ä–æ–∫–∏ –≤ JavaScript –æ—Å–Ω–æ–≤–∞–Ω—ã –Ω–∞ [–Æ–Ω–∏–∫–æ–¥–µ](https://ru.wikipedia.org/wiki/–Æ–Ω–∏–∫–æ–¥): –∫–∞–∂–¥—ã–π —Å–∏–º–≤–æ–ª –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç –∏–∑ —Å–µ–±—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –±–∞–π—Ç–æ–≤ –∏–∑ 1-4 –±–∞–π—Ç–æ–≤.

JavaScript –ø–æ–∑–≤–æ–ª—è–µ—Ç –Ω–∞–º –≤—Å—Ç–∞–≤–∏—Ç—å —Å–∏–º–≤–æ–ª –≤ —Å—Ç—Ä–æ–∫—É, —É–∫–∞–∑–∞–≤ –µ–≥–æ —à–µ—Å—Ç–Ω–∞–¥—Ü–∞—Ç–µ—Ä–∏—á–Ω—ã–π –∫–æ–¥ –Æ–Ω–∏–∫–æ–¥–∞ —Å –ø–æ–º–æ—â—å—é –æ–¥–Ω–æ–π –∏–∑ —ç—Ç–∏—Ö —Ç—Ä–µ—Ö –Ω–æ—Ç–∞—Ü–∏–π:

- `\xXX`

    –í–º–µ—Å—Ç–æ `XX` –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —É–∫–∞–∑–∞–Ω—ã –¥–≤–µ —à–µ—Å—Ç–Ω–∞–¥—Ü–∞—Ç–µ—Ä–∏—á–Ω—ã–µ —Ü–∏—Ñ—Ä—ã —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º –æ—Ç `00` –¥–æ `FF`. –í —ç—Ç–æ–º —Å–ª—É—á–∞–µ `\xXX` -- —ç—Ç–æ —Å–∏–º–≤–æ–ª, –Æ–Ω–∏–∫–æ–¥ –∫–æ—Ç–æ—Ä–æ–≥–æ —Ä–∞–≤–µ–Ω `XX`.

    –ü–æ—Å–∫–æ–ª—å–∫—É –Ω–æ—Ç–∞—Ü–∏—è `\xXX` –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ç–æ–ª—å–∫–æ –¥–≤–µ —à–µ—Å—Ç–Ω–∞–¥—Ü–∞—Ç–µ—Ä–∏—á–Ω—ã–µ —Ü–∏—Ñ—Ä—ã, –µ–µ –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ –¥–ª—è –ø–µ—Ä–≤—ã—Ö 256 —Å–∏–º–≤–æ–ª–æ–≤ –Æ–Ω–∏–∫–æ–¥–∞.

    –≠—Ç–∏ 256 —Å–∏–º–≤–æ–ª–æ–≤ –≤–∫–ª—é—á–∞—é—Ç –≤ —Å–µ–±—è –ª–∞—Ç–∏–Ω—Å–∫–∏–π –∞–ª—Ñ–∞–≤–∏—Ç, –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–æ –æ—Å–Ω–æ–≤–Ω—ã—Ö —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∏—Ö —Å–∏–º–≤–æ–ª–æ–≤ –∏ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –¥—Ä—É–≥–∏–µ. –ù–∞–ø—Ä–∏–º–µ—Ä, `"\x7A"` - —ç—Ç–æ —Ç–æ –∂–µ —Å–∞–º–æ–µ, —á—Ç–æ `"z"` (–Æ–Ω–∏–∫–æ–¥ `U+007A`).

    ```js run
    alert( "\x7A" ); // z
    alert( "\xA9" ); // ¬©, —Å–∏–º–≤–æ–ª –∞–≤—Ç–æ—Ä—Å–∫–æ–≥–æ –ø—Ä–∞–≤–∞
    ```

- `\uXXXX`
    –í–º–µ—Å—Ç–æ `XXXX` –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —É–∫–∞–∑–∞–Ω—ã —Ä–æ–≤–Ω–æ 4 —à–µ—Å—Ç–Ω–∞–¥—Ü–∞—Ç–µ—Ä–∏—á–Ω—ã–µ —Ü–∏—Ñ—Ä—ã —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º –æ—Ç `0000` –¥–æ `FFFF`. –í —ç—Ç–æ–º —Å–ª—É—á–∞–µ `\uXXXX` - —ç—Ç–æ —Å–∏–º–≤–æ–ª, –∫–æ–¥ –Æ–Ω–∏–∫–æ–¥–∞ –∫–æ—Ç–æ—Ä–æ–≥–æ —Ä–∞–≤–µ–Ω `XXXX`.

    –°–∏–º–≤–æ–ª—ã —Å–æ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ –Æ–Ω–∏–∫–æ–¥–∞, –ø—Ä–µ–≤—ã—à–∞—é—â–∏–º–∏ `U+FFFF`, —Ç–∞–∫–∂–µ –º–æ–≥—É—Ç –±—ã—Ç—å –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω—ã —Å –ø–æ–º–æ—â—å—é —ç—Ç–æ–π –Ω–æ—Ç–∞—Ü–∏–∏, –Ω–æ –≤ —Ç–∞–∫–æ–º —Å–ª—É—á–∞–µ –Ω–∞–º –ø—Ä–∏–¥–µ—Ç—Å—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–∞–∫ –Ω–∞–∑—ã–≤–∞–µ–º—É—é —Å—É—Ä—Ä–æ–≥–∞—Ç–Ω—É—é –ø–∞—Ä—É (–æ –Ω–µ–π –º—ã –ø–æ–≥–æ–≤–æ—Ä–∏–º –ø–æ–∑–∂–µ –≤ —ç—Ç–æ–π –≥–ª–∞–≤–µ).
    
    ```js run
    alert( "\u00A9" ); // ¬©, —Ç–æ –∂–µ —Å–∞–º–æ–µ, —á—Ç–æ \xA9, –∏—Å–ø–æ–ª—å–∑—É—è 4-–∑–Ω–∞—á–Ω—É—é —à–µ—Å—Ç–Ω–∞–¥—Ü–∞—Ç–µ—Ä–∏—á–Ω—É—é –Ω–æ—Ç–∞—Ü–∏—é
    alert( "\u044F" ); // —è, –±—É–∫–≤–∞ –∫–∏—Ä–∏–ª–ª–∏—á–µ—Å–∫–æ–≥–æ –∞–ª—Ñ–∞–≤–∏—Ç–∞
    alert( "\u2191" ); // ‚Üë, —Å–∏–º–≤–æ–ª —Å—Ç—Ä–µ–ª–∫–∏ –≤–≤–µ—Ä—Ö
    ```

- `\u{X‚Ä¶XXXXXX}`

    –í–º–µ—Å—Ç–æ `X‚Ä¶XXXXXX` –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å —à–µ—Å—Ç–Ω–∞–¥—Ü–∞—Ç–µ—Ä–∏—á–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –æ—Ç 1 –¥–æ 6 –±–∞–π—Ç –æ—Ç `0` –¥–æ `10FFFF` (—Å–∞–º–∞—è –≤—ã—Å–æ–∫–∞—è —Ç–æ—á–∫–∞ –∫–æ–¥–∞, –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–∞—è —Å—Ç–∞–Ω–¥–∞—Ä—Ç–æ–º –Æ–Ω–∏–∫–æ–¥). –≠—Ç–∞ –Ω–æ—Ç–∞—Ü–∏—è –ø–æ–∑–≤–æ–ª—è–µ—Ç –Ω–∞–º –ª–µ–≥–∫–æ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—Ç—å –≤—Å–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ —Å–∏–º–≤–æ–ª—ã –Æ–Ω–∏–∫–æ–¥–∞.

    ```js run
    alert( "\u{20331}" ); // ‰Ω´, —Ä–µ–¥–∫–∏–π –∫–∏—Ç–∞–π—Å–∫–∏–π –∏–µ—Ä–æ–≥–ª–∏—Ñ (–¥–ª–∏–Ω–Ω—ã–π –Æ–Ω–∏–∫–æ–¥)
    alert( "\u{1F60D}" ); // üòç, —Å–∏–º–≤–æ–ª —É–ª—ã–±–∞—é—â–µ–≥–æ—Å—è –ª–∏—Ü–∞ (–µ—â—ë –æ–¥–∏–Ω –¥–ª–∏–Ω–Ω—ã–π –Æ–Ω–∏–∫–æ–¥)
    ```

## –°—É—Ä—Ä–æ–≥–∞—Ç–Ω—ã–µ –ø–∞—Ä—ã

All frequently used characters have 2-byte codes (4 hex digits). Letters in most European languages, numbers, and the basic unified CJK ideographic sets (CJK -- from Chinese, Japanese, and Korean writing systems), have a 2-byte representation.

Initially, JavaScript was based on UTF-16 encoding that only allowed 2 bytes per character. But 2 bytes only allow 65536 combinations and that's not enough for every possible symbol of Unicode.

So rare symbols that require more than 2 bytes are encoded with a pair of 2-byte characters called "a surrogate pair".

As a side effect, the length of such symbols is `2`:

```js run
alert( 'ùí≥'.length ); // 2, MATHEMATICAL SCRIPT CAPITAL X
alert( 'üòÇ'.length ); // 2, FACE WITH TEARS OF JOY
alert( '©∑∂'.length ); // 2, a rare Chinese character
```

That's because surrogate pairs did not exist at the time when JavaScript was created, and thus are not correctly processed by the language!

We actually have a single symbol in each of the strings above, but the `length` property shows a length of `2`.

Getting a symbol can also be tricky, because most language features treat surrogate pairs as two characters.

For example, here we can see two odd characters in the output:

```js run
alert( 'ùí≥'[0] ); // shows strange symbols...
alert( 'ùí≥'[1] ); // ...pieces of the surrogate pair
```

Pieces of a surrogate pair have no meaning without each other. So the alerts in the example above actually display garbage.

Technically, surrogate pairs are also detectable by their codes: if a character has the code in the interval of `0xd800..0xdbff`, then it is the first part of the surrogate pair. The next character (second part) must have the code in interval `0xdc00..0xdfff`. These intervals are reserved exclusively for surrogate pairs by the standard.

So the methods `String.fromCodePoint` and `str.codePointAt` were added in JavaScript to deal with surrogate pairs.

They are essentially the same as [String.fromCharCode](mdn:js/String/fromCharCode) and [str.charCodeAt](mdn:js/String/charCodeAt), but they treat surrogate pairs correctly.

One can see the difference here:

```js run
// charCodeAt is not surrogate-pair aware, so it gives codes for the 1st part of ùí≥:

alert( 'ùí≥'.charCodeAt(0).toString(16) ); // d835

// codePointAt is surrogate-pair aware
alert( 'ùí≥'.codePointAt(0).toString(16) ); // 1d4b3, reads both parts of the surrogate pair
```

That said, if we take from position 1 (and that's rather incorrect here), then they both return only the 2nd part of the pair:

```js run
alert( 'ùí≥'.charCodeAt(1).toString(16) ); // dcb3
alert( 'ùí≥'.codePointAt(1).toString(16) ); // dcb3
// meaningless 2nd half of the pair
```

You will find more ways to deal with surrogate pairs later in the chapter <info:iterable>. There are probably special libraries for that too, but nothing famous enough to suggest here.

````warn header="Takeaway: splitting strings at an arbitrary point is dangerous"
We can't just split a string at an arbitrary position, e.g. take `str.slice(0, 4)` and expect it to be a valid string, e.g.:

```js run
alert( 'hi üòÇ'.slice(0, 4) ); //  hi [?]
```

Here we can see a garbage character (first half of the smile surrogate pair) in the output.

Just be aware of it if you intend to reliably work with surrogate pairs. May not be a big problem, but at least you should understand what happens.
````

## Diacritical marks and normalization

In many languages, there are symbols that are composed of the base character with a mark above/under it.

For instance, the letter `a` can be the base character for these characters: `√†√°√¢√§√£√•ƒÅ`.

Most common "composite" characters have their own code in the Unicode table. But not all of them, because there are too many possible combinations.

To support arbitrary compositions, the Unicode standard allows us to use several Unicode characters: the base character followed by one or many "mark" characters that "decorate" it.

For instance, if we have `S` followed by the special "dot above" character (code `\u0307`), it is shown as SÃá.

```js run
alert( 'S\u0307' ); // SÃá
```

If we need an additional mark above the letter (or below it) -- no problem, just add the necessary mark character.

For instance, if we append a character "dot below" (code `\u0323`), then we'll have "S with dots above and below": `SÃáÃ£`.

For example:

```js run
alert( 'S\u0307\u0323' ); // SÃáÃ£
```

This provides great flexibility, but also an interesting problem: two characters may visually look the same, but be represented with different Unicode compositions.

For instance:

```js run
let s1 = 'S\u0307\u0323'; // SÃáÃ£, S + dot above + dot below
let s2 = 'S\u0323\u0307'; // SÃ£Ãá, S + dot below + dot above

alert( `s1: ${s1}, s2: ${s2}` );

alert( s1 == s2 ); // false though the characters look identical (?!)
```

To solve this, there exists a "Unicode normalization" algorithm that brings each string to the single "normal" form.

It is implemented by [str.normalize()](mdn:js/String/normalize).

```js run
alert( "S\u0307\u0323".normalize() == "S\u0323\u0307".normalize() ); // true
```

It's funny that in our situation `normalize()` actually brings together a sequence of 3 characters to one: `\u1e68` (S with two dots).

```js run
alert( "S\u0307\u0323".normalize().length ); // 1

alert( "S\u0307\u0323".normalize() == "\u1e68" ); // true
```

In reality, this is not always the case. The reason is that the symbol `·π®` is "common enough", so Unicode creators included it in the main table and gave it the code.

If you want to learn more about normalization rules and variants -- they are described in the appendix of the Unicode standard: [Unicode Normalization Forms](https://www.unicode.org/reports/tr15/), but for most practical purposes the information from this section is enough.
