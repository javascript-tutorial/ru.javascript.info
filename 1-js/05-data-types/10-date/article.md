# Дата и время

Рассмотрим новый встроенный объект: [Date](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date). Он содержит дату и время, а также предоставляет методы управления ими.

Например, его можно использовать для хранения времени создания/изменения, для измерения времени или просто для вывода текущей даты.

## Создание

Для создания нового объекта `Date` нужно вызвать конструктор `new Date()` с одним из следующих аргументов:

`new Date()`
: Без аргументов -- создать объект `Date` с текущими датой и временем:

    ```js run
    let now = new Date();
    alert( now ); // показывает текущие дату и время
    ```

`new Date(milliseconds)`
: Создать объект `Date` с временем, равным количеству миллисекунд (тысячная доля секунды), прошедших с 1 января 1970 года UTC+0.    

    ```js run
    // 0 соответствует 01.01.1970 UTC+0
    let Jan01_1970 = new Date(0);
    alert( Jan01_1970 );

    // теперь добавим 24 часа и получим 02.01.1970 UTC+0
    let Jan02_1970 = new Date(24 * 3600 * 1000);
    alert( Jan02_1970 );
    ```

    Количество миллисекунд, прошедших с начала 1970 года, называется *меткой времени* (англ. timestamp).

    Это легковесное численное представление даты. Из метки времени всегда можно получить дату с помощью `new Date(timestamp)` и преобразовать существующий объект `Date` в метку времени, используя метод `date.getTime()` (см. ниже).

`new Date(datestring)`
: Если аргумент всего один, и это строка, то её разбор производится по алгоритму `Date.parse` (см. ниже).


    ```js run
    let date = new Date("2017-01-26");
    alert(date);
    // Временнáя составляющая даты принимается за полночь по Гринвичу и 
    // меняется в соответствии с временной зоной места выполнения кода
    // Так что в результате можно получить
    // Thu Jan 26 2017 11:00:00 GMT+1100 (восточноавстралийское время)
    // или
    // Wed Jan 25 2017 16:00:00 GMT-0800 (тихоокеанское время)
    ```

`new Date(year, month, date, hours, minutes, seconds, ms)`
: Создать объект `Date` с заданными компонентами в местной временной зоне. Обязательны только первые два аргумента.

    Заметим:

    - `year` должен состоять из четырёх цифр: значение `2013` корректно, `98` -- нет.
    - `month` начинается с `0` (январь) по `11` (декабрь).
    - Параметр `date` здесь представляет собой день месяца. Если параметр не задан, то принимается значение `1`.
    - Если параметры `hours/minutes/seconds/ms` отсутствуют, их значением становится `0`.

    Например:

    ```js
    new Date(2011, 0, 1, 0, 0, 0, 0); // // 1 Jan 2011, 00:00:00
    new Date(2011, 0, 1); // то же самое, так как часы и проч. равны 0
    ```

    Минимальная точность – 1 мс (1/1000 секунды):

    ```js run
    let date = new Date(2011, 0, 1, 2, 3, 4, 567);
    alert( date ); // 1.01.2011, 02:03:04.567
    ```

## Получение компонентов даты

Существует множество методов получения года, месяца и т.д. из объекта `Date`. Но если их классифицировать, то они легко запоминаются:

[getFullYear()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/getFullYear)
: Получить год (4 цифры)

[getMonth()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/getMonth)
: Получить месяц, **от 0 до 11**.

[getDate()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/getDate)
: Получить день месяца, от 1 до 31, что несколько противоречит названию метода.

[getHours()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/getHours), [getMinutes()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/getMinutes), [getSeconds()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/getSeconds), [getMilliseconds()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/getMilliseconds)
: Получить, соответственно, часы, минуты, секунды или миллисекунды.

```warn header="Никакого `getYear()`. Только `getFullYear()`"
Многие интерпретаторы JavaScript реализуют нестандартный и устаревший метод `getYear()`, который порой возвращает год в виде двух цифр. Пожалуйста, обходите его стороной. Если нужно значение года, используйте `getFullYear()`.
```

Кроме того, можно получить определённый день недели:

[getDay()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/getDay)
: Вернуть день недели от `0` (воскресенье) до `6` (суббота). Несмотря на то, что в ряде стран за первый день недели принят понедельник, в JavaScript начало недели приходится на воскресенье.

**Все вышеперечисленные методы возвращают значения в соответствии с местной временной зоной.**

Однако существуют и их UTC-варианты, возвращающие день, месяц, год для временной зоны UTC+0: [getUTCFullYear()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/getUTCFullYear), [getUTCMonth()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/getUTCMonth), [getUTCDay()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/getUTCDay). Для их использования требуется после `"get"` подставить `"UTC"`.

Если ваша местная временная зона смещена относительно UTC, то следующий код покажет разные часы:

```js run
// текущая дата
let date = new Date();

// час в вашей текущей временной зоне
alert( date.getHours() );

// час во временной зоне UTC+0 (лондонское время без перехода на летнее время)
alert( date.getUTCHours() );
```

Помимо вышеприведённых методов, существуют два особых метода без UTC-варианта:

[getTime()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/getTime)
: Для заданной даты возвращает метку времени -- количество миллисекунд, прошедших с 1 января 1970 года UTC+0.

[getTimezoneOffset()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset)
: Возвращает разницу в минутах между местной временной зоной и UTC:

    ```js run
    // если вы во временной зоне UTC-1, то выводится 60
    // если вы во временной зоне UTC+3, выводится -180
    alert( new Date().getTimezoneOffset() );

    ```

## Установка компонентов даты

Следующие методы позволяют установить компоненты даты и времени:

- [`setFullYear(year [, month, date])`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/setFullYear)
- [`setMonth(month [, date])`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/setMonth)
- [`setDate(date)`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/setDate)
- [`setHours(hour [, min, sec, ms])`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/setHours)
- [`setMinutes(min [, sec, ms])`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/setMinutes)
- [`setSeconds(sec [, ms])`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/setSeconds)
- [`setMilliseconds(ms)`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/setMilliseconds)
- [`setTime(milliseconds)`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/setTime) (устанавливает дату в виде целого количества миллисекунд, прошедших с 01.01.1970 UTC)

У всех этих методов, кроме `setTime()`, есть UTC-вариант, например: `setUTCHours()`.

Как мы видим, некоторые методы могут устанавливать сразу несколько компонентов даты, например: `setHours`. Если какая-то компонента не указана, она не меняется.

Пример:

```js run
let today = new Date();

today.setHours(0);
alert(today); // выводится сегодняшняя дата, но значение часа будет 0

today.setHours(0, 0, 0, 0);
alert(today); // всё равно выводится сегодняшняя дата, но время будет ровно 00:00:00.
```

## Автоисправление даты

*Автоисправление* -- это очень полезная возможность объектов `Date`. Можно устанавливать заведомо некорректные компоненты, а объект сам себя исправит.

Пример:

```js run
let date = new Date(2013, 0, *!*32*/!*); // 32 Jan 2013 ?!?
alert(date); // ...1st Feb 2013!
```

Неправильные компоненты даты автоматически распределяются по остальным.

Предположим, нам требуется увеличить дату "28 февраля 2016" на два дня. В зависимости от того, високосный это год или нет, результатом будет "2 марта" или "1 марта". Нам об этом думать не нужно. Просто прибавляем два дня. Объект `Date` позаботится об остальном:

```js run
let date = new Date(2016, 1, 28);
*!*
date.setDate(date.getDate() + 2);
*/!*

alert( date ); // 1 Mar 2016
```

Эту возможность часто используют, чтобы получить дату по прошествии заданного отрезка времени. Например, получим дату "спустя 70 секунд с текущего момента":

```js run
let date = new Date();
date.setSeconds(date.getSeconds() + 70);

alert( date ); // выводит правильную дату
```

Также можно установить нулевые или даже отрицательные значения. Например:

```js run
let date = new Date(2016, 0, 2); // 2 Jan 2016

date.setDate(1); // задать первое число месяца
alert( date );

date.setDate(0); // первый день месяца -- это 1, так что выводится последнее число предыдущего месяца
alert( date ); // 31 Dec 2015
```

## Преобразование к числу, разность дат

Если объект `Date` преобразовать в число, то получим метку времени, по аналогии с `date.getTime()`:

```js run
let date = new Date();
alert(+date); // количество миллисекунд, то же самое, что date.getTime()
```

Важный побочный эффект: даты можно вычитать, в результате получаем разность в миллисекундах.

Этот приём можно использовать для измерения времени:

```js run
let start = new Date(); // начинаем считать

// выполняем некоторые действия
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

let end = new Date(); // заканчиваем считать

alert( `Цикл отработал за ${end - start} миллисекунд` );
```

## Date.now()

Если нужно просто получить разницу между датами, объект `Date` нам для этого не нужен.

Существует особый метод `Date.now()`, возвращающий текущую метку времени.

Семантически он эквивалентен `new Date().getTime()`, однако метод не создаёт промежуточный объект `Date`. Так что этот способ работает быстрее и не нагружает сборщик мусора.

Данный метод используется из соображений удобства или когда важно быстродействие, например, при разработке игр на JavaScript или других специализированных приложений.

Вероятно, предыдущий пример лучше переписать так:

```js run
*!*
let start = Date.now(); // счёт в миллисекундах с 1 января 1970 года
*/!*

// выполняем некоторые действия
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

*!*
let end = Date.now(); // заканчиваем считать
*/!*

alert( `Цикл отработал за ${end - start} миллисекунд` ); // вычитаются числа, а не даты
```

## Бенчмаркинг

Будьте внимательны, если хотите точно протестировать производительность функции, требовательной к ресурсам ЦП.

Например, сравним две функции, вычисляющие разницу между двумя датами: какая сработает быстрее?

```js
// есть date1 и date2, какая функция быстрее вернёт разницу между ними в миллисекундах?
function diffSubtract(date1, date2) {
  return date2 - date1;
}

// или
function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}
```

Обе функции делают буквально одно и то же, только одна использует явный метод `date.getTime()` для получения даты в миллисекундах, а другая полагается на преобразование даты в число. Результат их работы всегда один и тот же.

Но какая функция быстрее?

Для начала можно запустить их много раз подряд и засечь разницу. В нашем случае функции очень простые, так что потребуется где-то 100000 повторений.

Проведём измерения:

```js run
function diffSubtract(date1, date2) {
  return date2 - date1;
}

function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}

function bench(f) {
  let date1 = new Date(0);
  let date2 = new Date();

  let start = Date.now();
  for (let i = 0; i < 100000; i++) f(date1, date2);
  return Date.now() - start;
}

alert( 'Время diffSubtract: ' + bench(diffSubtract) + 'мс' );
alert( 'Время diffGetTime: ' + bench(diffGetTime) + 'мс' );
```

Вот это да! Метод `getTime()` работает ощутимо быстрее! Всё потому, что не производится преобразование типов и интерпретаторам такое намного легче оптимизировать.

Замечательно, это уже что-то. Но до хорошего бенчмарка нам ещё далеко.

Представьте, что при выполнении `bench(diffSubtract)` ЦП параллельно работал над чём-то ещё, также потребляющим ресурсы. А когда началось выполнение `bench(diffGetTime)`, процесс уже завершился.

Достаточно реалистичный сценарий в современных многопроцессорных операционных системах.

В результате, у первого бенчмарка окажется меньше ресурсов ЦП, чем у второго. Это может исказить результаты.

**Для получения наиболее достоверных результатов тестирования производительности весь набор бенчмарков нужно запускать по несколько раз.**

Рассмотрим пример:

```js run
function diffSubtract(date1, date2) {
  return date2 - date1;
}

function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}

function bench(f) {
  let date1 = new Date(0);
  let date2 = new Date();

  let start = Date.now();
  for (let i = 0; i < 100000; i++) f(date1, date2);
  return Date.now() - start;
}

let time1 = 0;
let time2 = 0;

*!*
// bench(upperSlice) и bench(upperLoop) поочерёдно запускаются 10 раз
for (let i = 0; i < 10; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}
*/!*

alert( 'Итоговое время diffSubtract: ' + time1 );
alert( 'Итоговое время diffGetTime: ' + time2 );
```

Современные интерпретаторы JavaScript начинают применять современные оптимизации только к "горячему коду", выполняющемуся несколько раз (незачем оптимизировать то, что редко выполняется). Так что в примере выше первые запуски не оптимизированы должным образом. Нелишним будет добавить следующий код для разогрева:

```js
// добавляем для "разогрева" перед основным циклом
bench(diffSubtract);
bench(diffGetTime);

// а теперь тестируем производительность
for (let i = 0; i < 10; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}
```

```warn header="Внимательно тестируйте производительность"
Современные интерпретаторы JavaScript выполняют множество оптимизаций. Они могут повлиять на результаты "искусственных тестов" по сравнению с "нормальным использованием", особенно если мы тестируем что-то немасштабное. Поэтому если хотите серьёзно понять производительность, пожалуйста, изучите, как работают интерпретаторы JavaScript. И тогда вам, вероятно, совершенно не понадобятся микробенчмарки.

Огромный набор статей о V8 можно найти здесь: <http://mrale.ph>.
```

## Разбор строки с датой

Метод [Date.parse(str)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/parse) считывает дату из строки.

Формат строки должен быть следующим: `YYYY-MM-DDTHH:mm:ss.sssZ`, где:

- `YYYY-MM-DD` -- это дата: год-месяц-день.
- Символ `"T"` используется в качестве разделителя.
- `HH:mm:ss.sss` -- время: часы, минуты, секунды и миллисекунды.
- Необязательная часть `'Z'` обозначает временную зону в формате `+-hh:mm`. Если указать просто букву `Z`, то получим UTC+0.

Возможны и более короткие варианты, например, `YYYY-MM-DD` или `YYYY-MM` или даже `YYYY`.

Вызов `Date.parse(str)` обрабатывает строку в заданном формате и возвращает метку времени (количество миллисекунд с 1 января 1970 года UTC+0). Если формат неправильный, возвращается `NaN`.

Например:

```js run
let ms = Date.parse('2012-01-26T13:51:50.417-07:00');

alert(ms); // 1327611110417  (метка времени)
```

Можно мгновенно создать объект `new Date` из метки времени:

```js run
let date = new Date( Date.parse('2012-01-26T13:51:50.417-07:00') );

alert(date);  
```

## Итого

- Дата и время в JavaScript представлены объектом [Date](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date). Нельзя создать "только дату" или "только время": объекты `Date` всегда содержат и то, и другое.
- Счёт месяцев начинается с нуля (да, январь -- это нулевой месяц).
- Дни недели в `getDay()` также отсчитываются с нуля, что соответствует воскресенью.
- Объект `Date` самокорректируется при введении значений, выходящих за рамки допустимых значений. Это полезно для сложения/вычитания дней/месяцев/недель.
- Даты можно вычитать, и разность возвращается в миллисекундах. Так происходит, потому что при преобразовании в число объект `Date` становится меткой времени.
- Используйте `Date.now()` для быстрого получения текущей метки времени.

Учтите, что в отличие от других систем метки времени в JavaScript измеряются в миллисекундах, а не в секундах.

Также порой нам нужно более точно измерить время. Собственными средствами JavaScript измерять время в микросекундах (одна миллионная секунды) нельзя, но в большинстве сред такая возможность есть. К примеру, в браузерах есть метод [performance.now()](https://developer.mozilla.org/ru/docs/Web/API/Performance/now), возвращающий количество миллисекунд с начала загрузки страницы с точностью до микросекунд (3 цифры после точки):

```js run
alert(`Загрузка началась ${performance.now()}мс назад`);
// Получаем что-то вроде: "Загрузка началась 34731.26000000001мс назад"
// .26 –- это микросекунды (260 микросекунд)
// корректными являются только первые три цифры после точки, а остальные -- это ошибка точности
```

В Node.js для этого предусмотрен модуль `microtime` и ряд других способов. Технически, любое устройство или среда позволяет добиться большей точности, просто её нет в объекте `Date`.
