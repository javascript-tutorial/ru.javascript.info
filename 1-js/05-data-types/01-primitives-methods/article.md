# Методы с примитивными типами данных

JavaScript позволяет нам работать с примитивными типами данных (далее: примитивы) - строки, числа, и т.д., так, как если бы они были объектами.

Они даже предоставляют методы. Мы изучим их позже, а сначала разберем, как это все работает, потому что, конечно, примитивы - не объекты.

Давайте взглянем на ключевые различия между примитивами и объектами.

Примитив

- Это значение «примитивного» типа.
- Есть 6 примитивных типов: `string`, `number`, `boolean`, `symbol`, `null` и `undefined`.

Объект

- Может хранить множество значений как свойства.
- Объявляется при помощи фигурных скобок `{}`, например: `{name: "Рома", age: 30}`. В JavaScript есть и другие виды объектов: например, функции тоже являются объектами.

Одна из лучших особенностей объектов это то, что мы можем хранить функцию как одно из свойств объекта.

```js run
let roma = {
  name: "Рома",
  sayHi: function() {
    alert("Привет, дружище!");
  }
};

roma.sayHi(); // Привет, дружище!
```

Здесь мы создали объект `roma` с методом `sayHi`.

Существует множество встроенных объектов. Например, те, которые работают с датами, ошибками, HTML-элементами и т.д. Они имеют различные свойства и методы.

Однако у этих возможностей есть обратная сторона!

Объекты «тяжелее» примитивов. Они нуждаются в дополнительных ресурсах для поддержания внутренней структуры. Но так как свойства и методы очень полезны в программировании, движки JavaScript оптимизируют их для уменьшения дополнительной нагрузки.

## Примитив как объект

Вот парадокс, с которым столкнулся создатель JavaScript:

- Есть много всего, что хотелось бы сделать с примитивами, такими как строка или число. Было бы замечательно, если бы мы могли работать с ними через вызовы методов.
- Примитивы должны быть как можно легкими и быстрыми.

Вот решение, хотя выглядит оно немного неуклюже:

1. Примитивы остаются примитивами. Одно значение, как и хотелось.
2. Язык позволяет иметь доступ к методам и свойствам строк, чисел, булевых значений и символов.
3. Чтобы это работало, создается специальный "объект-обертка", который предоставляет дополнительную функциональность, а после удаляется.

Каждый примитив имеет свой собственный "объект-обертку", которые называются: `String`, `Number`, `Boolean` и `Symbol`. Таким образом, они имеют разный набор методов.

К примеру, существует метод [str.toUpperCase()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase), который возвращает cтроку в верхнем регистре.

Вот как он работает:

```js run
let str = "Привет";

alert( str.toUpperCase() ); // ПРИВЕТ
```

Очень просто, не правда ли? Вот, что на самом деле происходит в `str.toUpperCase()`:

1. Строка `str` - примитив. В момент обращения к его свойству, создается специальный объект, который знает значение строки и имеет такие полезные методы, как `toUpperCase()`.
2. Этот метод запускается и возвращает новую строку (показывается в `alert`).
3. Специальный объект удаляется, оставляя только примитив `str`.

Получается, что примитивы могут предоставлять методы, и в то же время оставаться «лёгкими».

Движок JavaScript очень оптимизирует этот процесс. Он даже может пропустить создание специального объекта. Однако, он все же должен придерживаться спецификаций и работать так, как будто он его создает.

Число имеет собственный набор методов. Например, [toFixed(n)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) округляет число до n знаков после запятой.

```js run
let n = 1.23456;

alert( n.toFixed(2) ); // 1.23
```

Более подробно с различными свойствами и методами мы познакомимся в главах <info:number> и <info:string>.


````warn header="Конструкторы `String/Number/Boolean` предназначены только для внутреннего пользования"
Некоторые языки, такие как Java позволяют создание "объектов-оберток" для примитивов при помощи такого синтаксиса как `new Number(1)` или `new Boolean(false)`.

В JavaScript, это тоже возможно по историческим причинам, но очень **не рекомендуется**. В некоторых местах последствия могут быть катастрофическими.

Например:

```js run
alert( typeof 0 ); // "число"

alert( typeof new Number(0) ); // "object"!
```

Объекты в if всегда дают true, так что в примере ниже будет показан alert:

```js run
let zero = new Number(0);

if (zero) {
  // zero возвращает "true", так как является объектом
  alert( "zero имеет «истинное» значение?!?" );
}
```

С другой стороны, использование функций `String/Number/Boolean` без оператора `new` - вполне разумно и полезно. Они превращают значение в соответствующий примитивный тип: в строку, в число, в булевой тип.

К примеру, следующее вполне допустимо:

```js
let num = Number("123"); // превращает строку в число
```
`````


````warn header="null/undefined не имеют методов"
Особенные примитивы `null` and `undefined` являются исключениями. У них нет соответствующих "объектов-оберток" и они не имеют никаких методов. В некотором смысле, они "самые примитивные".

Попытка доступа к свойствам такого значения возвратит ошибку:
```js run
alert(null.test); // ошибка
````

## Итого

- Все примитивы кроме `null` и `undefined` предоставляют множество полезных методов. Мы познакомимся с ними поближе в следующих главах.
- Формально, эти методы работают с помощью временных объектов, но движки JavaScript очень хорошо оптимизируют этот процесс внутренне, так что их вызов не требует много ресурсов.
