# Числа

В современном JavaScript существует два типа чисел:
1. Обычные числа в JavaScript хранятся в 64-битном формате [IEEE-754](http://en.wikipedia.org/wiki/IEEE_754-1985), который также называют "числа двойной точности с плавающей точкой" (double precision floating point numbers). Это числа, которые мы используем большую часть времени, и мы поговорим о них в этой главе.
2. Числа BigInt для представления целых чисел произвольной длины. Иногда они необходимы, поскольку обычное число не может безопасно превышать <code>2<sup>53</sup></code> или быть меньше <code>-2<sup>53</sup></code>. Так как `BigInt` числа нужны в нескольких специальных областях, мы посвятили им отдельную главу <info:bigint>.

В данной главе мы рассмотрим только первый тип чисел: числа типа `number`. Давайте глубже изучим, как с ними работать в JavaScript.

## Способы записи числа

Представьте, что нам надо записать число 1 миллиард. Самый очевидный путь:

```js
let billion = 1000000000;
```

Мы также можем использовать символ подчеркивания `_` в качестве разделителя:

```js
let billion = 1_000_000_000;
```

Здесь подчеркивание `_` играет роль “[синтаксического сахара](https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D1%81%D0%B0%D1%85%D0%B0%D1%80?oldformat=true)”, оно просто делает число более читаемым. Движок JavaScript просто игнорирует `_` между цифрами, так что это точно такой же миллиард, как и выше.

Тем не менее в реальной жизни мы стараемся не писать длинные последовательности нулей. Мы слишком ленивы для этого. Мы стараемся писать что-то вроде `"1bn"` для миллиарда или `"7.3bn"` для 7 миллиардов 300 миллионов. То же самое верно и для большинства больших чисел.

В JavaScript мы можем сократить число, добавив к нему букву `"e"` и указав количество нулей:

```js run
let billion = 1e9;  // 1 миллиард, буквально: 1 и 9 нулей

alert( 7.3e9 );  // 7,3 миллиарда (то же самое, что 7300000000 или 7_300_000_000)
```

Другими словами, `e` умножает число на `1` с заданным количеством нулей.

```js
1e3 === 1 * 1000; // e3 означает *1000
1.23e6 === 1.23 * 1000000; // e6 означает *1000000
```


Теперь давайте напишем что-нибудь очень маленькое. Скажем, 1 микросекунда (одна миллионная секунды):

```js
let mсs = 0.000001;
```

Как и раньше, использование буквы `"е" `может помочь. Если мы хотели бы избежать явного написания нулей, мы могли бы сказать – то же самое, что:

```js
let mcs = 1e-6; // шесть нулей, слева от 1
```

Если мы посчитаем нули в `0,000001`, то их будет 6. Поэтому естественно, что это `1e-6`.

Другими словами, отрицательное число после `"e"` означает деление на 1 с указанным количеством нулей:

```js
// -3 делится на 1 с 3 нулями
1e-3 === 1 / 1000; // 0.001

// -6 делится на 1 с 6 нулями
1.23e-6 === 1.23 / 1000000; // 0.00000123
```

### Шестнадцатеричные, двоичные и восьмеричные числа

[Шестнадцатеричные](https://ru.wikipedia.org/wiki/%D0%A8%D0%B5%D1%81%D1%82%D0%BD%D0%B0%D0%B4%D1%86%D0%B0%D1%82%D0%B5%D1%80%D0%B8%D1%87%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F) числа широко используются в JavaScript для представления цветов, кодировки символов и многого другого. Поэтому, естественно, существует более короткий способ их записи: `0x`, а затем число.

Например:

```js run
alert( 0xff ); // 255
alert( 0xFF ); // 255 (то же самое, регистр не имеет значения)
```

Не так часто используются двоичные и восьмеричные числа, но они также поддерживаются `0b` для двоичных и `0o` для восьмеричных:


```js run
let a = 0b11111111; // бинарная форма записи числа 255
let b = 0o377; // восьмеричная форма записи числа 255

alert( a == b ); // true, с двух сторон число 255
```

Существует только 3 числовые системы счисления с такой поддержкой. Для других систем счисления следует использовать функцию `parseInt` (которую мы рассмотрим позже в этой главе).

## toString(base)

Метод `num.toString(base)` возвращает строковое представление числа `num` в системе счисления `base`.

Например:
```js run
let num = 255;

alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111
```

`base` может варьироваться от `2` до `36` (по умолчанию `10`).

Часто используемые:

- **base=16** — для шестнадцатеричного представления цвета, кодировки символов и т.д., цифры могут быть `0..9` или `A..F`.
- **base=2** — обычно используется для отладки побитовых операций, цифры `0` или `1`.
- **base=36** — максимальное основание, цифры могут быть `0..9` или `A..Z`. То есть, используется весь латинский алфавит для представления числа. Забавно, но можно использовать `36`-разрядную систему счисления когда нам нужно превратить длинный числовой идентификатор во что-то более короткое, например, чтобы создать короткий URL-адрес. Можно просто представить его в системе счисления с основанием `36`:

    ```js run
    alert( 123456..toString(36) ); // 2n9c
    ```

```warn header="Две точки для вызова метода"
Обратите внимание, что две точки в `123456..toString(36)` - это не опечатка. Если мы хотим вызвать метод непосредственно на число, как `toString` в примере выше, то нам нужно поставить две точки `..` после него.

Если мы поставим одну точку: `123456.toString(36)`, тогда это будет ошибкой, поскольку синтаксис JavaScript предполагает, что после первой точки начинается десятичная часть. А если мы поставили еще одну точку, то JavaScript понимает, что десятичная часть отсутствует, и начинается метод.

Также можно записать как `(123456).toString(36)`.
```

## Округление

Одна из часто используемых операций при работе с числами - это округление.

В JavaScript есть несколько встроенных функций для работы с округлением:

`Math.floor`
: Округление в меньшую сторону: `3.1` становится `3`, а `-1.1` — `-2`.

`Math.ceil`
: Округление в большую сторону: `3.1` становится `4`, а `-1.1` — `-1`.

`Math.round`
: Округление до ближайшего целого: `3.1` становится `3`, `3.6` — `4`, что касается середины: `3,5` тоже округляется до `4`.

`Math.trunc` (не поддерживается в Internet Explorer)
: Удаляет все, что находится после десятичной точки, без округления: `3.1` становится `3`, `-1.1` становится `-1`.

Вот таблица, в которой представлены различия между ними:

|   | `Math.floor` | `Math.ceil` | `Math.round` | `Math.trunc` |
|---|---------|--------|---------|---------|
|`3.1`|  `3`    |   `4`  |    `3`  |   `3`   |
|`3.6`|  `3`    |   `4`  |    `4`  |   `3`   |
|`-1.1`|  `-2`    |   `-1`  |    `-1`  |   `-1`   |
|`-1.6`|  `-2`    |   `-1`  |    `-2`  |   `-1`   |


Эти функции охватывают все возможные способы взаимодействия с десятичной частью числа. Но что, если мы захотим округлить число до `n-й` цифры после десятичной дроби?

К примеру, у нас есть `1.2345` и мы хотим округлить число до 2-х знаков после запятой, получив только `1.23`.

Есть два способа сделать это::

1. Умножить и разделить.

    Например, чтобы округлить число до второго знака после запятой, мы можем умножить число на `100` (или на большую степень 10), вызвать функцию округления и разделить обратно.
    ```js run
    let num = 1.23456;

    alert( Math.floor(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23
    ```

2. Метод [toFixed(n)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) округляет число до `n` знаков после запятой и возвращает строковое представление результата.
3. Метод [toFixed(n)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) округляет число до `n` цифр после точки и возвращает строковое представление результата.

    ```js run
    let num = 12.34;
    alert( num.toFixed(1) ); // "12.3"
    ```

    Округляет в большую или меньшую сторону до ближайшего значения, подобно `Math.round`:

    ```js run
    let num = 12.36;
    alert( num.toFixed(1) ); // "12.4"
    ```

    Обратите внимание, что результатом `toFixed` является строка. Если десятичная часть короче, чем необходима, будут добавлены нули в конец строки:

    ```js run
    let num = 12.34;
    alert( num.toFixed(5) ); // "12.34000", добавлены нули, чтобы получить 5 знаков после запятой
    ```

    Мы можем преобразовать полученное значение в число, используя унарный оператор `+` или `Number()` вызов: `+num.toFixed(5)`.

## Неточные вычисления

Внутри JavaScript число представлено в виде 64-битного формата [IEEE-754](https://ru.wikipedia.org/wiki/IEEE_754-1985), поэтому для хранения числа требуется ровно 64 бита: 52 из них используются для хранения цифр, 11 - для хранения положения десятичной точки (для целых чисел они равны нулю) и 1 бит - для знака.

Если число слишком большое, оно переполнит 64-битное хранилище, что потенциально вернёт бесконечность:

```js run
alert( 1e500 ); // Infinity
```

Что может быть немного менее очевидным, но случается довольно часто, так это потеря точности.

Рассмотрим этот (ложный!) тест:

```js run
alert( 0.1 + 0.2 == 0.3 ); // *!*false*/!*
```

Да-да,  если мы проверим, равна ли сумма `0.1` и `0.2` `0.3`, мы получим `false`.

Странно! Что же это тогда, если не` 0,3`?

```js run
alert( 0.1 + 0.2 ); // 0.30000000000000004
```

Oй! Здесь есть больше последствий, чем неправильное сравнение. Представьте, что вы создаете сайт электронных покупок, и посетитель кладет товары стоимостью `$0.10 `и `$0.20` в свою корзину. Общая сумма заказа составит `$0.30000000000000004`. Это удивило бы любого.

Но почему это происходит?

Число хранится в памяти в двоичном виде, в виде последовательности битов – единиц и нулей. Но такие дроби, как `0.1`, `0,2`, которые выглядят простыми в десятичной системе счисления, на самом деле являются бесконечными дробями в их двоичной форме.

Другими словами, что такое `0.1`? Это единица делённая на десять — `1/10`, одна десятая. В десятичной системе счисления такие числа легко представимы, по сравнению с одной третьей: `1/3`, которая становится бесконечной дробью `0.33333(3)`.

Таким образом, деление на степени `10` гарантированно хорошо работает в десятичной системе счисления, но деление на `3` - нет. По той же причине в двоичной системе счисления гарантированно работает деление на степени `2`, но `1/10` становится бесконечной двоичной дробью.

В JavaScript просто нет способа сохранить *ровно 0.1* или *ровно 0.2*, используя двоичную систему, точно так же, как нет способа сохранить одну треть в виде десятичной дроби.

Числовой формат IEEE-754 решает эту проблему путем округления до ближайшего возможного числа. Эти правила округления обычно не позволяют нам увидеть эту “крошечную потерю точности”, но она существует.

Мы можем видеть это в действии:
```js run
alert( 0.1.toFixed(20) ); // 0.10000000000000000555
```

И когда мы суммируем 2 числа, их “потери точности” суммируются.

Вот почему `0.1 + 0.2` - это не совсем `0.3`.

```smart header="Не только JavaScript"
Та же проблема существует во многих других языках программирования.

PHP, Java, C, Perl, Ruby дают точно такой же результат, потому что они основаны на одном и том же числовом формате(IEEE-754).
```

Можем ли мы решить эту проблему? Конечно, самый надежный метод - округлить результат с помощью метода [toFixed(n)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed):

```js run
let sum = 0.1 + 0.2;
alert( sum.toFixed(2) ); // 0.30
```

Помните, что метод `toFixed` всегда возвращает строку. Это гарантирует, что он содержит 2 цифры после десятичной точки. Это действительно удобно, если у нас есть интернет-магазин и нам нужно показать `$0.30`. В других случаях мы можем использовать унарный плюс, чтобы преобразовать его в число:

```js run
let sum = 0.1 + 0.2;
alert( +sum.toFixed(2) ); // 0.3
```

Мы также можем временно умножить числа на 100 (или большее число), чтобы превратить их в целые числа, выполнить математику, а затем разделить обратно. Тогда когда мы совершаем математические операции с целыми числами, ошибка несколько уменьшается, но мы все равно получаем ее при делении:

```js run
alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
alert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001
```

Таким образом, подход умножения / деления уменьшает ошибку, но не устраняет ее полностью.

Иногда мы могли бы попытаться вообще избежать дробей. Например, если мы имеем дело с магазином, то мы можем хранить цены в центах вместо долларов. Но что, если мы применим скидку в размере 30%? На практике полное уклонение от дробей редко возможно. Просто округлите их, чтобы при необходимости обрезать “хвосты”.

````smart header="Забавная вещь"
Попробуйте запустить это:

```js run
// Здравствуйте! Я - самовозрастающее число!
alert( 9999999999999999 ); // покажет 10000000000000000
```

Это страдает от той же проблемы: потери точности. Число состоит из 64 бит, 52 из них можно использовать для хранения цифр, но этого недостаточно. Таким образом, наименее значимые цифры исчезают.

JavaScript не выдает ошибку в таких случаях. Он делает все возможное, чтобы вписать число в нужный формат, но, к сожалению, этот формат недостаточно велик.
````

```smart header="Два нуля"
Другим забавным следствием внутреннего представления чисел является присутствие двух  нулей: `0` и `-0`.

Это потому, что знак представлен одним битом, поэтому он может быть установлен или не установлен для любого числа, включая ноль.

В большинстве случаев это различие незаметно, поскольку операторы воспринимают их как одно и то же.
```



## Тесты: isFinite и isNaN

Помните эти специальные числовые значения?

- `Infinity` (и `-Infinity`) - это специальное числовое значение, которое больше/меньше чем что-либо.
- `NaN` представляет ошибку.

Они относятся к типу `number`, но не являются “обычными” числами, поэтому для их проверки существуют специальные функции:

- `isNaN(value)` преобразует свой аргумент в число, а затем проверяет является ли оно `NaN`:

    ```js run
    alert( isNaN(NaN) ); // true
    alert( isNaN("str") ); // true
    ```

    Но нужна ли нам эта функция? Разве мы не можем просто использовать сравнение `=== NaN`? Извините, но мой ответ - нет. Значение `NaN` уникально тем, что оно ничему не равно, даже самому себе:

    ```js run
    alert( NaN === NaN ); // false
    ```

- `isFinite(value)` преобразует аргумент в число и возвращает `true`, если это обычное число, а не `NaN/Infinity/-Infinity`:

    ```js run
    alert( isFinite("15") ); // true
    alert( isFinite("str") ); // false, потому что специальное значение: NaN
    alert( isFinite(Infinity) ); // false, потому что специальное значение: Infinity
    ```

Иногда `isFinite` используется для проверки того, является ли строка обычным числом:


```js run
let num = +prompt("Enter a number", '');

// вернёт true если только вы не введете  Infinity/-Infinity или не число
alert( isFinite(num) );
```

Пожалуйста, обратите внимание, что пустая строка или строка, содержащая только пробел, обрабатывается как `0` во всех числовых функциях, включая `isFinite`.

```smart header="Сравнение c `Object.is`"

Существует специальный метод [Object.is](mdn:js/Object/is), который сравнивает значения примерно как `===`, но более надежно для двух крайних случаев:

1. Это работает с `NaN`: `Object.is(NaN, NaN) === true`, здесь он хорош.
2. Значения `0` и `-0` различны: `Object.is (0, -0) === false`, технически это верно, потому что внутренне число имеет знаковый бит, который может отличаться, даже если все остальные биты равны нулям.

Во всех других случаях `Object.is(a, b)` идентичен `a === b`.

Этот способ сравнения часто используется в спецификации JavaScript. Когда внутреннему алгоритму необходимо сравнить 2 значения на предмет точного совпадения, он использует `Object.is` (внутренне называется [SameValue](https://tc39.github.io/ecma262/#sec-samevalue)).
```


## parseInt и parseFloat

Для явного преобразования к числу можно использовать `+` или `Number()`. Если строка не является в точности числом, то результат будет `NaN`:

```js run
alert( +"100px" ); // NaN
```

Единственное исключение — это пробелы в начале строки и в конце, они игнорируются.

В реальной жизни мы часто сталкиваемся со значениями у которых есть единица измерения, например `"100px"` или `"12pt"` в CSS. Также во множестве стран символ валюты записывается после номинала `"19€"`. Так как нам получить числовое значение из таких строк?

Для этого есть `parseInt` и `parseFloat`.

Они "читают" число из строки. Если в процессе чтения возникает ошибка, они возвращают полученное до ошибки число. Функция `parseInt` возвращает целое число, а `parseFloat` возвращает число с плавающей точкой:

```js run
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') ); // 12, вернётся только целая часть
alert( parseFloat('12.3.4') ); // 12.3, произойдёт остановка чтения на второй точке
```

Функции `parseInt/parseFloat` вернут `NaN`, если не смогли прочитать ни одну цифру:

```js run
alert( parseInt('a123') ); // NaN, на первом символе происходит остановка чтения
```

````smart header="Второй аргумент `parseInt(str, radix)`"
Функция `parseInt()` имеет необязательный второй параметр. Он определяет систему счисления, таким образом `parseInt` может также читать строки с шестнадцатеричными числами, двоичными числами и т.д.:

```js run
alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, без 0x тоже работает

alert( parseInt('2n9c', 36) ); // 123456
```
````

## Другие математические функции

В JavaScript встроен объект [Math](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math), который содержит различные математические функции и константы.

Несколько примеров:

`Math.random()`
: Возвращает псевдослучайное число в диапазоне от 0 (включительно) до 1 (но не включая 1)

    ```js run
    alert( Math.random() ); // 0.1234567894322
    alert( Math.random() ); // 0.5435252343232
    alert( Math.random() ); // ... (любое количество псевдослучайных чисел)
    ```

`Math.max(a, b, c...)` / `Math.min(a, b, c...)`
: Возвращает наибольшее/наименьшее число из перечисленных аргументов.

    ```js run
    alert( Math.max(3, 5, -10, 0, 1) ); // 5
    alert( Math.min(1, 2) ); // 1
    ```

`Math.pow(n, power)`
: Возвращает число `n`, возведённое в степень `power`

    ```js run
    alert( Math.pow(2, 10) ); // 2 в степени 10 = 1024
    ```

В объекте `Math` есть множество функций и констант, включая тригонометрические функции, подробнее можно ознакомиться в документации по объекту [Math](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math).

## Итого

Чтобы писать числа с большим количеством нулей:

- Используйте краткую форму записи чисел - `"e"`, с указанным количеством нулей. Например: `123e6` это `123` с 6-ю нулями `123000000`.
- Отрицательное число после `"e"` приводит к делению числа на 1 с указанным количеством нулей. Например: `123e-6` это `0.000123` (`123` миллионных).

Для других систем счисления:

- Можно записывать числа сразу в шестнадцатеричной (`0x`), восьмеричной (`0o`) и бинарной (`0b`) системах счисления
- `parseInt(str, base)` преобразует строку в целое число в соответствии с указанной системой счисления: `2 ≤ base ≤ 36`.
- `num.toString(base)` представляет число в строковом виде в указанной системе счисления `base`.

Для преобразования значений типа `12pt` и `100px` в число:

- Используйте `parseInt/parseFloat` для "мягкого" преобразования строки в число, данные функции по порядку считывают число из строки до тех пор пока не возникнет ошибка.

Для дробей:

- Используйте округления `Math.floor`, `Math.ceil`, `Math.trunc`, `Math.round` или `num.toFixed(precision)`.
- Помните, что при работе с дробями происходит потеря точности.

Ещё больше математических функций:

- Документация по объекту [Math](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math). Библиотека маленькая, но содержит всё самое важное.
