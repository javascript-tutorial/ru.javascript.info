libs:
  - lodash

---

# Привязка контекста к функции

При использовании `setTimeout` с методами объекта (или при передаче методов объекта) возникает известная проблема: "потеря `this`".

Внезапно, `this` просто перестает работать правильно. Такая ситуация типична для новичков, но также случается и с опытными разработчиками.

## Потеря "this"

Мы уже знаем, что в JavaScript легко потерять `this`: когда метод передается где-то отдельно от объекта - `this` теряется.

Вот как это может произойти с `setTimeout`:

```js run
let user = {
  firstName: "Вася",
  sayHi() {
    alert(`Привет, ${this.firstName}!`);
  }
};

*!*
setTimeout(user.sayHi, 1000); // Привет, undefined!
*/!*
```

При запуске этого кода мы видим, что вызов `this.firstName` возвращает не "Вася", а `undefined`!

Это произошло потому, что `setTimeout` получил функцию `sayHi`, отдельно от объекта `user` (именно здесь функция и потеряла контекст). То есть последняя строка может быть переписана как:

```js
let f = user.sayHi;
setTimeout(f, 1000); // контекст user потеряли
```

Метод `setTimeout` в браузере имеет особенность: он устанавливает `this=window` для вызова функции (в Node.js `this` становится объектом таймера, но здесь это не имеет значения). Таким образом, для `this.firstName` он пытается получить `window.firstName`, которого не существует. В других подобных случаях, как мы увидим, обычно `this` просто становится `undefined`.

Задача довольно типичная - мы хотим передать метод объекта куда-то ещё (в этом конкретном случае - в планировщик), где он будет вызван. Как бы сделать так, чтобы он вызывался в правильном контексте?

## Решение 1: сделать функцию-обёртку

Самый простой вариант решения – это обернуть вызов в анонимную функцию, создав замыкание:

```js run
let user = {
  firstName: "Вася",
  sayHi() {
    alert(`Привет, ${this.firstName}!`);
  }
};

*!*
setTimeout(function() {
  user.sayHi(); // Привет, Вася!
}, 1000);
*/!*
```

Теперь код работает корректно, так как объект `user` достаётся из замыкания, а затем вызывается его метод `sayHi`.

То же самое, только короче:

```js
setTimeout(() => user.sayHi(), 1000); // Привет, Вася!
```

Выглядит хорошо, но теперь в нашем коде появилась небольшая уязвимость.

Что произойдёт, если до момента срабатывания `setTimeout` (ведь задержка составляет целую секунду!) в переменную `user` будет записано другое значение? Тогда вызов неожиданно будет совсем не тот!

```js run
let user = {
  firstName: "Вася",
  sayHi() {
    alert(`Привет, ${this.firstName}!`);
  }
};

setTimeout(() => user.sayHi(), 1000);

// ...в течение 1 секунды
user = { sayHi() { alert("Другой пользователь в 'setTimeout'!"); } };

// Другой пользователь в 'setTimeout'!
```

Следующее решение гарантирует, что такого не случится.

## Решение 2: привязать контекст с помощью bind

В современном JavaScript у функций есть встроенный метод [bind](mdn:js/Function/bind), который позволяет зафиксировать `this`.

Базовый синтаксис `bind`:

```js
// полный синтаксис будет представлен немного позже
let boundFunc = func.bind(context);
```

Результатом вызова `func.bind(context)` является особый "экзотический объект" (термин взят из спецификации), который вызывается как функция и прозрачно передает вызов в `func`, при этом устанавливая `this=context`.

Другими словами, вызов `boundFunc` подобен вызову `func` с фиксированным `this`.

Например, здесь `funcUser` передает вызов в `func`, фиксируя `this=user`:

```js run  
let user = {
  firstName: "Вася"
};

function func() {
  alert(this.firstName);
}

*!*
let funcUser = func.bind(user);
funcUser(); // Вася  
*/!*
```

Здесь `func.bind(user)` - это "связанный вариант" `func`, с фиксированным `this=user`.

Все аргументы передаются исходному методу `func` "как есть", например:

```js run  
let user = {
  firstName: "Вася"
};

function func(phrase) {
  alert(phrase + ', ' + this.firstName);
}

// привязка this к user
let funcUser = func.bind(user);

*!*
funcUser("Привет"); // Привет, Вася (аргумент "Привет" передан, при этом this = user)
*/!*
```

Теперь давайте попробуем с методом объекта:

```js run
let user = {
  firstName: "Вася",
  sayHi() {
    alert(`Привет, ${this.firstName}!`);
  }
};

*!*
let sayHi = user.sayHi.bind(user); // (*)
*/!*

sayHi(); // Привет, Вася!

setTimeout(sayHi, 1000); // Привет, Вася!
```

В строке `(*)` мы берем метод `user.sayHi` и привязываем его к `user`. Теперь `SayHi` - это "связанная" функция, которая может быть вызвана отдельно или передана в `setTimeout` (контекст всегда будет правильным).

Здесь мы можем видеть, что `bind` исправляет только `this`, а аргументы передаются "как есть":

```js run
let user = {
  firstName: "Вася",
  say(phrase) {
    alert(`${phrase}, ${this.firstName}!`);
  }
};

let say = user.say.bind(user);

say("Привет"); // Привет, Вася (аргумент "Привет" передан в функцию "say")
say("Пока"); // Пока, Вася (аргумент "Пока" передан в функцию "say")
```

````smart header="Удобный метод: `bindAll`"
Если у объекта много методов и мы планируем их активно передавать, то можно привязать контекст для них всех в цикле:

```js
for (let key in user) {
  if (typeof user[key] == 'function') {
    user[key] = user[key].bind(user);
  }
}
```

Некоторые JS-библиотеки предоставляют встроенные функции для удобной массовой привязки контекста, например [_.bindAll(obj)](http://lodash.com/docs#bindAll) в lodash.
````

## Итого

Метод `func.bind(context, ...args)` возвращает "связанный вариант" функции `func`, который фиксирует контекст `this` и первые аргументы, если они заданы.

Обычно мы применяем `bind`, для исправления `this` в методе объекта, чтобы мы могли передать его куда-нибудь. Например, в `setTimeout`. В современной разработке существуют и другие причины для "связывания", мы встретимся с ними позже.
