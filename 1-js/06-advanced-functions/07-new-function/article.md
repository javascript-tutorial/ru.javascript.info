
# Синтаксис "new Function"

Существует ещё один вариант объявлять функции. Он используется крайне редко, но иногда другого решения не найти.

## Синтаксис

Синтаксис для объявления функции:

```js
let func = new Function([arg1, arg2, ...argN], functionBody);
```

Функция создается с заданными аргументами `arg1...argN` и телом `functionBody`.

Это проще понять на конкретном примере. Здесь объявлена функция с двумя аргументами:

```js run
let sum = new Function('a', 'b', 'return a + b');

alert( sum(1, 2) ); // 3
```

А вот функция без аргументов, в этом случае достаточно указать только тело:

```js run
let sayHi = new Function('alert("Hello")');

sayHi(); // Hello
```

Главное отличие от других способов объявления функции, которые были рассмотрены ранее, заключается в том, что функция создаётся полностью "на лету" из строки, переданной во время выполнения.

Все предыдущие объявления требовали от нас, программистов, писать объявление функции в скрипте.

Но `new Function` позволяет превратить любую строку в функцию. Например, можно получить новую функцию с сервера и затем выполнить ее:

```js
let str = ... код, полученный с сервера динамически ...

let func = new Function(str);
func();
```

Это используется в очень специфических случаях, например, когда мы получаем код с сервера для динамической компиляции функции из шаблона, в сложных веб-приложениях.

## Замыкание

Обычно функция помнит, где родилась, в специальном свойстве `[[Environment]]`. Это ссылка на лексическое окружение (Lexical Environment), в котором она создана.

Но когда функция создаётся с использованием `new Function`, её `[[Environment]]` - это ссылка не на текущее лексическое окружение, а на глобальное. Поэтому такая функция не имеет доступа к внешним переменным, только к глобальным.

So, such function doesn't have access to outer variables, only to the global ones.

```js run

function getFunc() {
  let value = "test";

*!*
  let func = new Function('alert(value)');
*/!*

  return func;
}

getFunc()(); // ошибка: value не определено
```

Сравним это с обычным объявлением:

```js run
function getFunc() {
  let value = "test";

*!*
  let func = function() { alert(value); };
*/!*

  return func;
}

getFunc()(); // *!*"test"*/!*, из лексического окружения функции getFunc
```

Эта особенность `new Function` выглядит странно, но оказывается очень полезной на практике.

Представьте, что нужно создать функцию из строки. Код этой функции неизвестен во время написания скрипта (вот поэтому не используем обычные функции), а будет определён только в процессе выполнения. Мы можем получить код с сервера или другого ресурса.

Наша новая функция должна взаимодействовать с основным скриптом.

Что если бы она имела доступ к внешним переменным?

Проблема в том, что перед отправкой JavaScript-кода на реальные работающие проекты код сжимается с помощью *минификатора* - специальной программы, которая уменьшает размер кода, удаляя комментарии, лишние пробелы, и, что самое главное, локальным переменным даются укороченные имена.

Например, если в функции объявляется переменная `let userName`, то минификатор изменяет её на `let a` (или другую букву, если она не занята), и изменяет её везде. Обычно так делать безопасно, потому что переменная является локальной и никто снаружи не имеет к ней достп. И внутри функции минификатор заменяет каждое её упоминание. Минификаторы достаточно умные. Они не просто "тупой" поиск-замена, они анализируют структуру кода, и поэтому ничего не ломают.

Так что если бы даже `new Function` и имела доступ к внешним переменным, она не смогла бы найти переименованную `userName`.

**Если бы `new Function` имела доступ к внешним переменным, при этом были бы проблемы с минификаторами.**

Чтобы передать что-то в функцию, созданную как `new Function`, нужно использовать ее аргументы.

## Итого

Синтаксис:

```js
let func = new Function ([arg1, arg2, ...argN], functionBody);
```

По историческим причинам аргументы также могут быть объявлены через запятую в одной строке.

Эти 3 строки ниже эквивалентны:

```js
new Function('a', 'b', 'return a + b'); // стандартный синтаксис
new Function('a,b', 'return a + b'); // через запятую в одной строке
new Function('a , b', 'return a + b'); // через запятую с пробелами в одной строке
```

Функции, объявленные через `new Function`, имеют `[[Environment]]`, ссылающийся на глобальное лексическое окружение, а не на родительское. Поэтому, они не могут использовать внешние локальные переменные. Но это очень хорошо, потому что это избавляет нас от ошибок. Переданные явно параметры - гораздо лучшее архитектурное решение, которое не вызывает проблем у минификаторов.

