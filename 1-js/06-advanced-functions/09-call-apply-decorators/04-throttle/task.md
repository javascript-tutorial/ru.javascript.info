importance: 5

---

# Тормозящий (throttling) декоратор

Создайте "тормозящий" декоратор `throttle(f, ms)` - который возвращает обёртку, передавая вызов в `f` не более одного раза в `ms` миллисекунд. Те вызовы, которые попадают в период "торможения", игнорируются.

**Отличие от `debounce` - если проигнорированный вызов является последним во время "задержки", то он выполняется в конце.**

Давайте рассмотрим реальное приложение, чтобы лучше понять это требование и выяснить, откуда оно взято.

**Например, мы хотим отслеживать движения указателя.**

В браузере мы можем объявить функцию, которая будет запускаться при каждом движении указателя и получать его местоположение. Во время активного использования мыши эта функция запускается очень часто, это может происходить около 100 раз в секунду (каждые 10 мс).

**Отслеживающая функция должна обновлять некоторую информацию на веб-странице.**

Функция обновления `update()` слишком ресурсоёмкая, чтобы делать это при каждом микродвижении. Также нет смысла делать это чаще, чем один раз в 100 мс.

Поэтому мы обернем вызов в декоратор: будем использовать throttle(update, 100) как функцию, которая будет запускаться при каждом перемещении указателя вместо оригинальной update(). Декоратор будет вызываться часто, но `update()` будет вызываться максимум раз в 100 мс.

Визуально это будет выглядеть вот так:

1. Для первого движения указателя декорированный вариант передает вызов в `update`. Это важно, т.к. пользователь сразу видит нашу реакцию на его перемещение.
2. Затем, когда указатель продолжает движение, в течение 100 мс ничего не происходит. Декорированный вариант игнорирует вызовы.
3. По истечению 100 мс происходит еще одно «обновление» с последними координатами. 
4. Затем, наконец, указатель где-то останавливается. Декорированный вариант ждет, пока не истечет 100 мс и затем вызывает `update` с последними координатами. Так что, пожалуй, самое главное то, что окончательные координаты указателя обработаны.

Пример кода:

```js
function f(a) {
  console.log(a)
}

// f1000 передает вызовы f максимум раз в 1000 мс
let f1000 = throttle(f, 1000);

f1000(1); // показывает 1
f1000(2); // (ограничение, 1000 мс еще нет)
f1000(3); // (ограничение, 1000 мс еще нет)

// когда 1000 мс истекли ...
// ...выводим 3, промежуточное значение 2 было проигнорировано
```

P.S.: Аргументы и контекст `this`, переданные в `f1000`, должны быть переданы в оригинальную `f`.
