
# Объект функции, NFE

Как мы уже знаем, в JavaScript функции -- это значения.

Каждое значение в JavaScript имеет свой тип. А функция -- это какой тип?

В JavaScript, функции -- это объекты.

Можно представить функцию как "объект, который может делать какое-то действие". Функции можно не только вызывать, но использовать их как обычные объекты: добавлять/удалять свойства, передавать их по ссылке и т.д.


## Свойство "name"

Объект функции содержит несколько полезных свойств.

Например, имя функции нам доступно как свойство "name":

```js run
function sayHi() {
  alert("Hi");
}

alert(sayHi.name); // sayHi
```

Что еще более забавно, логика назначения `name` довольно хитрая. Она присваивает корректное имя в случае, если функция создается без имени и тут же присваивается, вот так:

```js run
let sayHi = function() {
  alert("Hi");
}

alert(sayHi.name); // sayHi (работает!)
```

Это даже работает в случае присваивания значения по умолчанию:

```js run
function f(sayHi = function() {}) {
  alert(sayHi.name); // sayHi (работает!)
}

f();
```

В спецификации это называется "контекстное имя": если функция не имеет name, то JavaScript пытается понять его из контекста.

Также имена имеют и методы объекта:

```js run
let user = {

  sayHi() {
    // ...
  },

  sayBye: function() {
    // ...
  }

}

alert(user.sayHi.name); // sayHi
alert(user.sayBye.name); // sayBye
```

В этом нет никакой магии. Бывает, что корректное имя определить невозможно. В таких случаях свойство name имеет пустое значение. Например:

```js
// функция объявлена внутри массива
let arr = [function() {}];

alert( arr[0].name ); // <пустая строка>
// здесь отсутствует возможность определить имя, поэтому его нет
```

Впрочем, на практике такое бывает редко, обычно функции имеют `name`.

## Свойство "length"

"length" -- это еще одно встроенное свойство, возвращающее количество параметров функции. Например: 

```js run
function f1(a) {}
function f2(a, b) {}
function many(a, b, ...more) {}

alert(f1.length); // 1
alert(f2.length); // 2
alert(many.length); // 2
```

Как мы видим, троеточие, обозначающее "остальные параметры", здесь "не считается"

Свойство `length` иногда используется для [интроспекций](https://ru.wikipedia.org/wiki/Интроспекция_(программирование)) в функциях, которые работают с другими функциями.

Например, в коде ниже функция `ask` принимает в качестве параметров вопрос `question` и произвольное количество функций-обработчиков ответа `handler`.


Когда пользователь отвечает на вопрос, функция вызывает обработчики. Мы можем передать два типа обработчиков:

- Функцию без аргументов, которая будет вызываться только в случае положительного ответа.
- Функцию с аргументами, которая будет вызываться в обоих случаях и возвращать ответ.

Идея состоит в том, чтобы иметь простой синтаксис обработчика без аргументов для положительных ответов (наиболее распространённый случай), но также и возможность передавать универсальные обработчики. 

Чтобы вызвать `handlers` правильно, мы проверяем свойство `length`:

```js run
function ask(question, ...handlers) {
  let isYes = confirm(question);

  for(let handler of handlers) {
    if (handler.length == 0) {
      if (isYes) handler();
    } else {
      handler(isYes);
    }
  }

}

// для положительных ответов вызываются оба типа обработчиков
// для отрицательных - только второго типа
ask("Вопрос?", () => alert('Вы ответили да'), result => alert(result));
```

Это частный случай так называемого [Ad-hoc-полиморфизма](https://ru.wikipedia.org/wiki/Полиморфизм_(информатика)#Ad-hoc-полиморфизм) -- обработка аргументов в зависимости от их типа или, как в нашем случае -- от значения `length`. Эта идея имеет применение в библиотеках JavaScript.

## Пользовательские свойства

Мы также можем добавить свои собственные свойства.

Давайте добавим свойство `counter` для отслеживания общего количества вызовов:

```js run
function sayHi() {
  alert("Hi");

  *!*
  // давайте посчитаем, сколько вызовов мы сделали
  sayHi.counter++;
  */!*
}
sayHi.counter = 0; // начальное значение

sayHi(); // Hi
sayHi(); // Hi

alert( `Вызвана ${sayHi.counter} раза` ); // Вызвана 2 раза
```

```warn header="Свойство не есть переменная"
Свойство функции, назначенное как `sayHi.counter = 0`, не *объявляет* локальную переменную `counter` внутри неё. Другими словами, свойство `counter` и переменная `let counter` - это две независимые вещи.

Мы можем использовать функцию как объект, хранить в ней свойства, но они никак не влияют на её выполнение. Переменные -- это не свойства функции и наоборот. Это два параллельных мира.
```

Иногда свойства функции могут использоваться вместо замыканий. Например, мы можем переписать функцию-счетчик из главы <info:closure>, используя её свойство:

```js run
function makeCounter() {
  // вместо
  // let count = 0

  function counter() {
    return counter.count++;
  };

  counter.count = 0;

  return counter;
}

let counter = makeCounter();
alert( counter() ); // 0
alert( counter() ); // 1
```

Свойство `count` теперь хранится прямо в функции, а не в её внешнем лексическом окружении.

Это хуже или лучше, чем использовать замыкание?

Основное отличие в том, что если значение `count` живет во внешней переменной, то она не доступна для внешнего кода. Изменить её могут только вложенные функции. А если оно присвоено как свойство функции, то мы можем его получить:

```js run
function makeCounter() {

  function counter() {
    return counter.count++;
  };

  counter.count = 0;

  return counter;
}

let counter = makeCounter();

*!*
counter.count = 10;
alert( counter() ); // 10
*/!*
```

Поэтому выбор реализации зависит от наших целей.

## Named Function Expression

Named Function Expression или NFE -- это термин для Function Expression у которого есть имя.

Например, давайте объявим Function Expression:

```js
let sayHi = function(who) {
  alert(`Hello, ${who}`);
};
```

И присвоим ему имя:

```js
let sayHi = function *!*func*/!*(who) {
  alert(`Hello, ${who}`);
};
```

Чего мы здесь достигли? Какова цель этого дополнительного имени `func`?

Для начала заметим, что функция все ещё задана как Function Expression. Добавление `"func"` после `function` не превращает его в Function Declaration, потому что оно все еще является частью выражения присваивания.

Добавление такого имени ничего не ломает.

Функция все еще доступна как `sayHi()`:

```js run
let sayHi = function *!*func*/!*(who) {
  alert(`Hello, ${who}`);
};

sayHi("John"); // Hello, John
```

Есть две важные особенности имени `func`:

1. Оно позволяет функции ссылаться на себя же.
2. Оно не доступно за пределами функции.

Например, ниже функция `sayHi` вызывает себя с `"Guest"`, если не передан параметр `who`:

```js run
let sayHi = function *!*func*/!*(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
*!*
    func("Guest"); // использует func чтобы снова вызвать себя же
*/!*
  }
};

sayHi(); // Hello, Guest

// А вот так - не cработает:
func(); // Ошибка, func не определена (недоступна вне функции)
```

Почему мы используем `func`? Почему просто не использовать `sayHi` для вложенного вызова?

Вообще, обычно мы можем так поступить:

```js
let sayHi = function(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
*!*
    sayHi("Guest");
*/!*
  }
};
```

Однако, у этого кода есть проблема, которая заключается в том, что значение `sayHi` может быть изменено. Функция может быть присвоена другой переменной, и тогда код начнет выдавать ошибки:

```js run
let sayHi = function(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
*!*
    sayHi("Guest"); // Ошибка: sayHi не является функцией
*/!*
  }
};

let welcome = sayHi;
sayHi = null;

welcome(); // Ошибка, вложенный вызов sayHi больше не работает!
```

Так происходит, потому что функция берет `sayHi` из её внешнего лексического окружения. Так как локальная переменная `sayHi` отсутствует, используется внешняя. И на момент вызова эта внешняя `sayHi` равна `null`.

Необязательное имя, которое можно вставить в Function Expression, как раз и призвано решать такого рода проблемы.

Давайте используем его, чтобы исправить наш код:

```js run
let sayHi = function *!*func*/!*(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
*!*
    func("Guest"); // Теперь все в порядке
*/!*
  }
};

let welcome = sayHi;
sayHi = null;

welcome(); // Hello, Guest (вложенный вызов работает)
```

Теперь все работает, потому что имя `"func"` локальное и находится внутри функции. Теперь оно взято не снаружи (и недоступно оттуда). Спецификация гарантирует, что оно всегда будет ссылаться на текущую функцию.

Внешний код все еще содержит переменные `sayHi` и `welcome`, но теперь `func` -- это "внутреннее имя функции", таким образом она может вызвать себя изнутри.

```smart header="Это не работает с Function Declaration"
Трюк с "внутренним" именем, описанный выше, работает только для Function Expression, и *не* работает для Function Declaration. Для Function Declaration, синтаксис не предусматривает возможность объявить "дополнительное внутреннее" имя.

Зачастую, когда нам нужно надёжное "внутреннее" имя, стоит переписать Function Declaration на Named Function Expression.
```

## Итого

Функции -- это объекты.

Их свойства:

- `name` -- имя функции. Обычно берётся из объявления функции, но если там нет - JavaScript пытается понять его из контекста.
- `length` -- количество аргументов в объявлении функции. Троеточие ("остальные параметры") не считается.

Если функция объявлена как Function Expression (вне основного потока кода), и имеет имя, тогда это называется Именованным Функциональным Выражением. Это имя может быть использовано для ссылки на себя же, для рекурсивных вызовов и т.п.

Также функции могут содержать дополнительные свойства. Многие известные JavaScript-библиотеки искусно используют эту возможность.

Они создают "основную" функцию и добавляют множество "вспомогательных" функций внутрь первой. Например, библиотека [jquery](https://jquery.com) создаёт функцию с именем `$`. Библиотека [lodash](https://lodash.com) создаёт функцию `_`, а потом добавляет в неё  `_.clone`, `_.keyBy` и другие свойства (чтобы узнать о ней побольше см. [документацию](https://lodash.com/docs)). Они делают это, чтобы уменьшить засорение глобального пространства имен, таким образом одна библиотека предоставляет только одну глобальную переменную, уменьшая вероятность конфликта имен.

Таким образом, функция может не только делать что-то сама по себе, но также и предоставлять полезный функционал через свои свойства.
