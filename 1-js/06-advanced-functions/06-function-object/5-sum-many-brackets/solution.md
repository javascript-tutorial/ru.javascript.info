
1. В общем, чтобы это *хоть как-нибудь* заработало, результат, возвращаемый `sum`, должен быть функцией.
2. Между вызовами эта функция должна удерживать в памяти текущее значение счётчика.
3. Согласно заданию, функция должна преобразовываться в число, когда она используется с оператором `==`. Функции -- объекты, так что преобразование происходит, как описано в главе <info:object-toprimitive>, поэтому можно создать наш собственный метод, возвращающий число.

Код:

```js run
function sum(a) {

  let currentSum = a;

  function f(b) {
    currentSum += b;
    return f;
  }

  f.toString = function() {
    return currentSum;
  };

  return f;
}

alert( sum(1)(2) ); // 3
alert( sum(5)(-1)(2) ); // 6
alert( sum(6)(-1)(-2)(-3) ); // 0
alert( sum(0)(1)(2)(3)(4)(5) ); // 15
```

Пожалуйста, обратите внимание на то, что функция `sum` выполняется лишь однажды и просто возвращает функцию `f`.

Далее, при каждом последующем вызове, `f` суммирует свой аргумент со значением `currentSum` и возвращает себя же. 

**В последней строке `f` нет никакой рекурсии.**

Вот как выглядит рекурсия:

```js
function f(b) {
  currentSum += b;
  return f(); // <-- рекурсивный вызов
}
```

В нашем случае мы просто возвращаем функцию, не вызывая её:

```js
function f(b) {
  currentSum += b;
  return f; // <-- не вызывает себя. Просто возвращает 
}
```

Функция `f` будет использоваться в последующем вызове и снова возвращать себя столько раз, сколько будет необходимо. Затем, при использовании в качестве числа или строки, метод `toString` возвращает `currentSum` -- число. Также здесь мы можем использовать `Symbol.toPrimitive` или `valueOf` для преобразования.
