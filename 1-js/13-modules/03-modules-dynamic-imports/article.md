
# Динамические импорты

Инструкции экспорта и импорта, которые мы рассматривали в предыдущей главе, называются "статическими".

Это потому, что они на самом деле статические. Синтаксис у них весьма строг.

Во-первых, мы не можем динамически задавать никакие из параметров `import`.

Путь к модулю должен быть строковым примитивом и не может быть вызовом функции. Вот так работать не будет:

```js
import ... from *!*getModuleName()*/!*; // Ошибка, должна быть строка
```

Во-вторых, мы не можем делать импорт в зависимости от условий или в процессе выполнения.

```js
if(...) {
  import ...; // Ошибка, запрещено
}

{
  import ...; // Ошибка, мы не можем ставить импорт в блок
}
```

Всё это следствие того, что цель импорта/экспорта -- создать костяк структуры кода. Благодаря чему она может быть проанализирована, модули могут быть собраны и связаны друг с другом, а неиспользуемые экспорты удалены. Это возможно только благодаря тому, что всё статично.

Но как мы можем импортировать модуль динамически, по запросу?

## Функция import()

Функция `import(module)` может быть вызвана из любого места. Она вернёт промис, а он в свою очередь -- объект модуля.

Использовать её мы можем, например, вот так:

```js run
let modulePath = prompt("Путь к модулю?");

import(modulePath)
  .then(obj => <объект модуля>)
  .catch(err => <ошибка загрузки, нет такого модуля?>)
```

Или если внутри асинхронной функции, то можно вот так: `let module = await import(modulePath)`.

Как здесь:

[codetabs src="say" current="index.html"]

Так что использовать динамические импорты очень легко.

Кроме этого, динамические импорты работают в обычных скриптах, для них не требуется `script type="module"`.
