
# Преобразование объектов в примитивы

Что произойдёт если сложить два объекта `obj1 + obj2`, вычесть один из другого `obj1 - obj2` или вывести их на экран, воспользовавшись `alert(obj)`?

Существуют специальные методы, которые производят эти преобразования.

В главе <info:type-conversions> мы видели правила для численных, строковых и логических преобразований. Но мы обделили вниманием объекты. Теперь, поскольку мы уже знаем о методах объектов и символах, можно исправить это.

Для объектов нет логических преобразований, потому что все объекты являются `true` в логическом контексте. Поэтому мы будем рассматривать только преобразования к **строке** и **числу**.

Преобразование к числу происходит, когда мы вычитаем объекты или производим с ними математические операции. Например, Объект `Date` (рассматривался в статье <info:date>) можно вычитать, и результатом вычислений `date1 - date2` будет время между двумя датами.

Преобразования к строке происходят, когда мы хотим вывести объекты на экран с помощью `alert(obj)` или в других схожих случаях.

## Преобразование к примитивам

Когда объекты используются в ситуациях, где нужны примитивы, например, в вызове `alert` или математических операциях, происходит их преобразование к примитивным значениям, следуя алгоритму `ToPrimitive` ([спецификация](https://tc39.github.io/ecma262/#sec-toprimitive)).

Этот алгоритм позволяет нам настроить преобразование, используя специальные методы объектов.

В зависимости от ситуации, преобразование имеет так называемый "хинт"(hint).

Существует три варианта хинтов:

`"string"`
: Когда операцией ожидается строка. Например, для объектно-строковых преобразований, таких как `alert`:

    ```js
    // вывод
    alert(obj);

    // используем объект в качества имени свойства
    anotherObj[obj] = 123;
    ```

`"number"`
: Когда операцией ожидается число. Например, для объектно-численных преобразований, таких как математические операции:

    ```js
    // явное преобразование
    let num = Number(obj);

    // математическое (исключая бинарный оператор "+")
    let n = +obj; // унарный плюс
    let delta = date1 - date2;

    // больше/меньше сравнения
    let greater = user1 > user2;
    ```

`"default"`
: Происходит редко, когда оператор "не уверен" какой тип ожидать.

    Например, бинарный плюс `+` может работать с обоими типами: строками (конкатенировать их) и числами (складывать). Таким образом, и те и другие будут вычисляться. Или когда происходит сравнение объектов с помощью нестрогого равенства `==` со строкой, числом или символом.

    ```js
    // бинарный плюс
    let total = car1 + car2;

    // obj == string/number/symbol
    if (user == 1) { ... };
    ```

    Оператор больше/меньше `<>`, также может работать, как со строками, так и с числами. До тех пор, пока используется хинт со значением "number", но не "default". Так происходит по историческим причинам.

    На практике все встроенные объекты, исключая `Date`, (мы познакомимся с ним чуть позже) реализуют `"default"` преобразования тем же способом, что и `"number"`. Возможно, мы должны следовать той же практике.

Обратите внимание, что существуют лишь три варианта хинтов. Их очень просто запомнить. Не существует хинта со значением "boolean" (все объекты вычисляются в `true` в логическом контексте) или каких-либо ещё. И если мы считаем `"default"` и `"number"` одинаковыми, как большинство встроенных объектов, то остаются всего два варианта преобразований.

**В процессе преобразования, движок JavaScript пытается найти и вызвать три следующих метода объектов:**

1. Вызывает `obj[Symbol.toPrimitive](hint)` если метод существует,
2. Иначе если хинт равен `"string"`
    - пытается вызвать `obj.toString()`, если его нет, ищет `obj.valueOf()`, если он существует.
3. В случае если хинт равен `"number"` или `"default"`
    - вызывает `obj.valueOf()` и `obj.toString()`, аналогично ситуации со `"string"`, изменяется лишь порядок поиска и вызова методов.

## Метод Symbol.toPrimitive

Давайте рассмотрим первый метод. Существует встроенный символ с именем `Symbol.toPrimitive`, который должен использоваться в имени этого метода преобразования объектов, следующим образом:

```js
obj[Symbol.toPrimitive] = function(hint) {
  // возвращает значение примитива
  // hint = чему-то одному "string", "number", или "default"
}
```

Для примера, используем его в реализации объекта `user`:

```js run
let user = {
  name: "John",
  money: 1000,

  [Symbol.toPrimitive](hint) {
    alert(`hint: ${hint}`);
    return hint == "string" ? `{name: "${this.name}"}` : this.money;
  }
};

// демонстрация результатов преобразований:
alert(user); // hint: string -> {name: "John"}
alert(+user); // hint: number -> 1000
alert(user + 500); // hint: default -> 1500
```

Как мы можем видеть из кода, `user` преобразовался в информативную читаемую строку, и в денежный счёт, в зависимости от значения хинта. Единственный метод `user[Symbol.toPrimitive]` смог обработать все случаи преобразований.


## Методы toString/valueOf

Методы `toString` и `valueOf` берут своё начало с "древних" времён. Они не имеют ничего общего с символами (символы не так стары), это скорее рядовые методы объектов со строковыми именами. Они предоставляют "олд-скульный" способ реализации преобразований объектов.

Если нет метода `Symbol.toPrimitive` движок JavaScript пытается найти эти методы и вызвать следующим образом:

- `toString -> valueOf` для хинта со значением "string".
- `valueOf -> toString` -- в ином случае.

Для примера, используем их в реализации всё того же объекта `user`. Воспроизведём его поведение комбинацией методов `toString` и `valueOf`:

```js run
let user = {
  name: "John",
  money: 1000,

  // для хинта равного "string"
  toString() {
    return `{name: "${this.name}"}`;
  },

  // для хинта равного "number" или "default"
  valueOf() {
    return this.money;
  }

};

alert(user); // toString -> {name: "John"}
alert(+user); // valueOf -> 1000
alert(user + 500); // valueOf -> 1500
```

Довольно часто нам нужен единый "универсальный" способ обрабатывать все преобразования к примитивам. Для этого случая нам подходит только метод `toString`, давайте реализуем его:

```js run
let user = {
  name: "John",

  toString() {
    return this.name;
  }
};

alert(user); // toString -> John
alert(user + 500); // toString -> John500
```

В отсутствии `Symbol.toPrimitive` и `valueOf`, `toString` обработает все случаи преобразований к примитивам.


## Преобразование "к примитиву" и преобразование "к строке/числу"

Ещё одной важной особенностью всех методов преобразований объектов, является тот факт, что они не обязаны возвращать примитив в следствие преобразований с использованием хинта.

Нет чётких требований к тому, чтобы `toString()` возвращал строго строку, или к тому, чтобы метод `Symbol.toPrimitive` возвращал число для хинта равного "number".

**Единственное обязательное требование: методы должны возвращать примитивы.**

Операция инициализировавшая преобразование получает примитив, и затем продолжает работу с ним, производя дальнейшие преобразования, если это необходимо.

Например:

- Математические операции (исключая бинарный плюс) выполняют преобразование `к числу`:

    ```js run
    let obj = {
      toString() { // toString обрабатывает все преобразования в случае отсутствия других методов
        return "2";
      }
    };

    alert(obj * 2); // 4, метод преобразования к примитиву вернул строку "2", затем это значение стало числом 2
    ```

- Бинарный плюс `+` производит проверку примитивов -- если это строка, тогда производится конкатенация, иначе происходит преобразование `к числу` с дальнейшим вычислением.

    пример со строкой:
    ```js run
    let obj = {
      toString() {
        return "2";
      }
    };

    alert(obj + 2); // 22 (преобразование к примитиву вернуло строку => конкатенация)
    ```

    пример с числом:
    ```js run
    let obj = {
      toString() {
        return true;
      }
    };

    alert(obj + 2); // 3 (Преобразование к примитиву вернуло boolean, не строка => преобразование "к числу")
    ```

```smart header="Историческая справка"
По историческим причинам, методам `toString` или `valueOf` *желательно* возвращать примитивы: если любой из них вернёт объект -- ошибки не будет, но этот объект будет проигнорирован (как если бы метода вообще не существовало).

Метод `Symbol.toPrimitive`, напротив *обязан* возвращать примитив, иначе будет ошибка.
```

## Итого

Преобразование объектов в примитивы вызывается автоматически многими встроенными функциями и операторами, которые ожидают примитив в качестве значения.

Существует всего 3 типа хинтов:
- `"string"` (для `alert` и других строковых преобразований)
- `"number"` (для математических операций)
- `"default"` (для других немногих операторов)

В спецификации явно указано какой хинт должен использовать каждый оператор. И существует совсем немного операторов, которые "не знают что ожидать" и используют хинт со значением `"default"`. Обычно для встроенных объектов `"default"` обрабатывается так же, как `"number"`. Таким образом, последние два очень часто объединяют вместе.

Алгоритм преобразований к примитивам таков:

1. Сначала вызывается метод `obj[Symbol.toPrimitive](hint)`, если он существует.
2. Иначе, если хинт равен `"string"`
    - ищется и вызывается `obj.toString()`, затем `obj.valueOf()`, если первого не существует.
3. Иначе, если хинт равен `"number"` или `"default"`
    - ищется и вызывается `obj.valueOf()`, затем `obj.toString()`, если первого не существует.

На практике, довольно часто достаточно реализовать только `obj.toString()`, как "универсальный" метод для всех типов преобразований, возвращающий "читаемое" представление объекта, достаточное для логирования или отладки.
