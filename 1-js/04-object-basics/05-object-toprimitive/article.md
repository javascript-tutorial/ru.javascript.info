
# Преобразование объектов в примитивы

Что произойдёт если сложить объекты `obj1 + obj2`, вычесть `obj1 - obj2` или вывести, воспользовавшись `alert(obj)`?

Существуют специальные методы в объектах, которые производят эти преобразования.

В главе <info:type-conversions> мы видели правила для численных, строковых и логических преобразований. Но мы обделили вниманием объекты. Теперь, посокольку мы уже знаем о методах объектов и символах, стало возможным исправить это.

Для объектов нет логических преобразований, потому что все объекты являются `true` в логическом контексте. Поэтому важны только преобразования к строке и числу.

Преобразования к числу происходят, когда мы вычитаем объекты или применяем к ним математические функции. Например, Объект `Date` (рассматривался в статье <info:date>) можно вычитать, и результатом вычислений `date1 - date2` будет время между двумя датами.

Преобразования к строке же происходят, когда мы хотим вывести объекты с помощью `alert(obj)` или в похожих случаях.

## Преобразование к примитивам

Когда объекты используются в случаях, где нужны примитивы, например, в вызове `alert` или математических операциях, происходит их преобразование к примитивным значениям следуя алгоритму `ToPrimitive` ([спецификация](https://tc39.github.io/ecma262/#sec-toprimitive)).

Этот алгоритм позволяет нам настроить преобразование, используя специальные методы объектов.

В зависимости от ситуации, преобразование имеет так называемый "hint".

Существует три варианта:

`"string"`
: Когда в результате операции ожидается строка, для объектно-строковых преобразований, таких как `alert`:

    ```js
    // вывод
    alert(obj);

    // используем объект в качества имени свойства
    anotherObj[obj] = 123;
    ```

`"number"`
: Когда в результате операции ожидается число, для объектно-численных преобразований, таких как математические операции:

    ```js
    // явное преобразование
    let num = Number(obj);

    // математическое (исключая бинарный оператор "+")
    let n = +obj; // унарный плюс
    let delta = date1 - date2;

    // больше/меньше сравнения
    let greater = user1 > user2;
    ```

`"default"`
: Происходит редко, когда оператор "не уверен" какой тип ожидать.

    Например, бинарный плюс `+` может работать с обоими типами: строками (конкатинировать их) и числами (складывать), таким образом и те и другие будут вычисляться. Или когда происходит сравнение объектов с помощью нестрогого равенства `==` со строкой, числом или символом.

    ```js
    // бинарный плюс
    let total = car1 + car2;

    // obj == string/number/symbol
    if (user == 1) { ... };
    ```

    Оператор больше/меньше `<>` тоже может работать, как со строками, так и с числами. До тех пор, пока используется "number" `hint`, не "default". Так происходит по историческим причинам.

    На практике, все встроенные объекты исключая (`Date`, мы познакомимся с ним чуть позже) реализуют `"default"` преобразования тем же способом, что и `"number"`. И возможно, мы должны следовать той же практике.

Обратите внимание, что существуют лишь три варианта "hint". Это очень просто. Не существует "boolean" "hint" (все объекты вычисляются в `true` в логическом контексте) или каких-либо ещё. И если мы считаем `"default"` и `"number"` одинаковыми, как большинство встроенных объектов, то остаются всего два варианта преобразованиий.

**В процессе преобразований, движок JavaScript пытается найти и вызвать три следующих метода объектов:**

1. Вызывает `obj[Symbol.toPrimitive](hint)` если метод существует,
2. Иначе если "hint" -- `"string"`
    - пытается вызвать сначала `obj.toString()`, если его нет, -- `obj.valueOf()`, если он существует.
3. В случае если "hint" является `"number"` или `"default"`
    - вызывает `obj.valueOf()` и `obj.toString()`, аналогично ситуации со `"string"`, с той лишь разницей, что порядок вызова методов меняется местами.

## Метод Symbol.toPrimitive

Давайте разберём первый метод. Существует встроенный символ с именем `Symbol.toPrimitive`, который должен использоваться в имени этого метода преобразования объектов, следующим образом:

```js
obj[Symbol.toPrimitive] = function(hint) {
  // возвращает значение примитива
  // hint = чему-то одному "string", "number", или "default"
}
```

Для примера, используем это в реализации объекта `user`:

```js run
let user = {
  name: "John",
  money: 1000,

  [Symbol.toPrimitive](hint) {
    alert(`hint: ${hint}`);
    return hint == "string" ? `{name: "${this.name}"}` : this.money;
  }
};

// демонстрация результов преобразований:
alert(user); // hint: string -> {name: "John"}
alert(+user); // hint: number -> 1000
alert(user + 500); // hint: default -> 1500
```

Как мы могли увидеть из кода, `user` преобразовывался в информативную строку, либо в денежный счёт, в зависимости от значения "hint". Единственный метод `user[Symbol.toPrimitive]` смог обработать все случаи преобразований.


## Методы toString/valueOf

Методы `toString` и `valueOf` берут своё начало с "древних" времён. Они не имеют ничего общего с символами (символы не так стары), это скорее рядовые методы объектов со строковыми именами. Они предоставляют "олд-скульный" способ реализации преобразований объектов.

Если нет метода `Symbol.toPrimitive` движок JavaScript пытается найти эти методы и вызвать в следующем порядке:

- `toString -> valueOf` для "hint" со значением "string".
- `valueOf -> toString` -- в ином случае.

Для примера, используем это в реализации всё того же объекта `user`. Воспроизведём его поведение комбинацией методов `toString` и `valueOf`:

```js run
let user = {
  name: "John",
  money: 1000,

  // для hint="string"
  toString() {
    return `{name: "${this.name}"}`;
  },

  // для hint="number" или "default"
  valueOf() {
    return this.money;
  }

};

alert(user); // toString -> {name: "John"}
alert(+user); // valueOf -> 1000
alert(user + 500); // valueOf -> 1500
```

Довольно часто нам нужен единый "универсальный" способ обрабатывать все преобразования к примитивам. Для этого случая нам подходит только метод `toString`, давайте реализуем его:

```js run
let user = {
  name: "John",

  toString() {
    return this.name;
  }
};

alert(user); // toString -> John
alert(user + 500); // toString -> John500
```

В отсутствии `Symbol.toPrimitive` и `valueOf`, `toString` обработает все случаи преобразований к примитивам.


## Преобразования "к примитиву" и преобразования "к строке/числу"

Ещё одной важной особенностью всех методов преобразований объектов, является тот факт, что они не обязаны возвращать примитив в следствие преобразований с использованием "hint".

Нет чётких требований к тому, чтобы `toString()` возвращал строго строку, или к тому, чтобы метод `Symbol.toPrimitive` возвращал число для "hint" равного "number".

**Единственное обязательное требование: методы должны возвращать примитивы.**

Операция инициализировавшая преобразование получает примитив, и затем продолжает работу с ним, производя дальшейние преобразования, если это необходимо.

Например:

- Математические операции (исключая бинарный плюс) выполняют преобразования `к числу`:

    ```js run
    let obj = {
      toString() { // toString обрабатывает все преобразования в случае отсутствия других методов
        return "2";
      }
    };

    alert(obj * 2); // 4, метод преобразования к примитиву вернул "2", затем это значение стало 2
    ```

- Бинарный плюс производит проверку примитивов -- если это строка, тогда производится конкатенация, иначе происходит преобразование `к числу` с дальнейшим вычислением.

    пример со строкой:
    ```js run
    let obj = {
      toString() {
        return "2";
      }
    };

    alert(obj + 2); // 22 (преобразование к примитиву вернуло строку => конкатенация)
    ```

    пример с числом:
    ```js run
    let obj = {
      toString() {
        return true;
      }
    };

    alert(obj + 2); // 3 (Преобразование к примитиву вернуло boolean, не строка => преобразование "к числу")
    ```

```smart header="Историческая справка"
По историческим причинам, методы `toString` или `valueOf` *должны* возвращать примитивы: если любой из них вернёт объект, ошибки не будет, но этот объект будет проигнорирован (как если бы метода вообще не существовало).

Метод `Symbol.toPrimitive`, напротив *должен* возвращать примитив, иначе будет ошибка.
```

## Итого

Преобразования объектов в примитивы вызываются автоматически многими встроенными функциями и операторами, которые ожидают примитив в качестве значения.

Всего 3 типа "hint":
- `"string"` (для `alert` и других строковых преобразований)
- `"number"` (для математических операций)
- `"default"` (для других нескольких операторов)

В спецификации явно указано какой оператор какой "hint" использует. И существует совсем немного операторов, которые "не знают что ожидать" и используют "hint" `"default"`. Обычно для встроенных объектов `"default"` обрабатывается так же, как `"number"`, таким образом последние два очень часто объединяют вместе.

Алгоритм преобразований таков:

1. Сначала вызывается метод `obj[Symbol.toPrimitive](hint)` если он существует,
2. Иначе, если "hint" имеет значение `"string"`
    - вызывается `obj.toString()`, и затем `obj.valueOf()`, если первого не существует.
3. Иначе, если "hint" имеет значение `"number"` или `"default"`
    - вызывается `obj.valueOf()` и затем `obj.toString()`, если первого не существует.

На практике, довольно часто достаточно реализовать только `obj.toString()`, как "универсальный" метод для всех типов преобразований, возвращающий "читаемое" представление объекта, для логирования или отладки.
