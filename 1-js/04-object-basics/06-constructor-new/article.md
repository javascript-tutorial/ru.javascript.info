# Конструкторы, создание объектов через "new"

Обычный синтаксис `{...}` позволяет создать только один объект. Но зачастую нам нужно создать множество однотипных объектов, таких как пользователи, элементы меню и т.д.

Это можно сделать при помощи функции-конструктора и оператора `"new"`.

## Функция-конструктор

Функции-конструкторы являются обычными функциями. Но есть два соглашения:

1. Имя функции-конструктора должно начинаться с большой буквы.
2. Функция-конструктор должна вызываться при помощи оператора `"new"`.

Например:

```js run
function User(name) {
  this.name = name;
  this.isAdmin = false;
}

*!*
let user = new User("Вася");
*/!*

alert(user.name); // Вася
alert(user.isAdmin); // false
```

Когда функция вызывается как `new User(...)`, происходит следующее:

1. Создаётся новый пустой объект и присваивается `this`.
2. Выполняется код функции. Обычно он модифицирует `this`, добавляет туда новые свойства.
3. Возвращается значение `this`.

Другими словами, вызов `new User(...)` делает примерно вот что:

```js
function User(name) {
*!*
  // this = {};  (неявно)
*/!*

  // add properties to this
  this.name = name;
  this.isAdmin = false;

*!*
  // return this;  (неявно)
*/!*
}
```

То есть, результат вызова `new User("Вася")` - это тот же объект, что и:

```js
let user = {
  name: "Вася",
  isAdmin: false
};
```

Теперь, когда нам необходимо будет создать других пользователей, мы можем использовать `new User("Маша")`,
`new User("Даша")` и т.д. Данная конструкция гораздо удобнее и читабельнее, чем каждый раз создавать литерал объекта. Это и является основной целью конструкторов - удобное повторное создание однотипных объектов.

Еще раз заметим: технически, любая функция может быть использована как конструктор. Поэтому каждая функция может быть вызвана при помощи оператора `new` и выполнит алгоритм, указанный выше в примере. Заглавная буква в названии функции является всеобщим соглашением по именованию, она как бы подсказывает разработчику, что данная функция является функцией-конструктором и вызывается при помощи оператора `new`.

````smart header="new function() { ... }"
Если в нашем коде большое количество строк, создающих один сложный объект, мы можем обернуть их в функцию-конструктор следующим образом:

```js
let user = new function() {
  this.name = "Вася";
  this.isAdmin = false;

  // ...другой код для создания пользователя
  // возможна любая сложная логика и выражения
  // локальные переменные и т. д.
};
```
Такой конструктор не может быть вызван дважды, так как он нигде не сохраняется, просто создается и тут же вызывается. Таким образом, такой метод создания позволяет инкапсулировать код, который создаёт отдельный объект без дальнейшего пере использования. 
````

## Проверка вызова конструктора: new.target

```smart header="Проверка вызова конструктора: new.target"
Данный метод используется очень редко. Вы можете пропустить эту секцию, если не хотите углубляться в детали языка.
```

Используя специальное свойство `new.target` внутри функции, мы можем проверить, вызвана ли функция при помощи оператора `new` или без него.

В случае, если функция вызвана при помощи `new`, то в new.target будет сама функция, в противном случае вызов вернёт undefined.

```js run
function User() {
  alert(new.target);
}

// без "new":
*!*
User(); // undefined
*/!*

// с "new":
*!*
new User(); // function User { ... }
*/!*
```

Это можно использовать, чтобы отличить обычный вызов от вызова "в режиме конструктора". В частности, вот так можно сделать, чтобы функцию можно было вызывать как с, так и без `new`:

```js run
function User(name) {
  if (!new.target) { // в случае если вызов без оператора new
    return new User(name); // ...добавили оператор new за вас
  }
  
  this.name = name;
}

let vasya = User("Вася"); // переадресовываем вызовы на new User
alert(john.name); // Вася
```

Такой подход иногда используется в библиотеках для создания более гибкого синтаксиса, который позволяет разработчикам вызывать функции при помощи оператора `new` или без него.

Впрочем, это не очень хорошая практика, так как отсутствие new может ввести разработчика в заблуждение. С оператором `new`, мы точно знаем, что в итоге будет создан новый объект.


## Возврат значения из конструктора return

Обычно, конструкторы ничего не возвращают. Их задача, записать все необходимое в this, который в итоге станет результатом.

Но если явный вызов `return` всё же есть, то применяется простое правило:

- При вызове `return` с объектом, будет возвращён объект, а не `this`.
- При вызове `return` с примитивным значением, примитивное значение будет отброшено.

Другими словами, `return` с объектом возвращает объект, в любом другом случае конструктор вернёт `this`.

В примере ниже, `return` переопределяет `this` возвращая объект:

```js run
function BigUser() {

  this.name = "Вася";

  return { name: "Godzilla" };  // <-- возвращает объект
}

alert( new BigUser().name );  // Godzilla, получили этот объект ^^
```

А вот пример с пустым `return` (или мы могли бы поставить примитив после return, не важно)

```js run
function SmallUser() {

  this.name = "Вася";

  return; // завершает выполнение, возвращает this

  // ...

}

alert( new SmallUser().name );  // Вася
```

Обычно у конструкторов отсутствует `return`. В данном блоке мы упомянули особое поведение с возвращаемыми объектами, чтобы не оставлять пробелов в изучении языка.


````smart header="Отсутствие скобок"
Кстати, мы можем не ставить скобки после `new`, если вызов конструктора идёт без аргументов.

```js
let user = new User; // <-- без скобок
// same as
let user = new User();
```

Пропуск скобок считается Плохой практикой, но синтаксис языка этого не запрещает.
````

## Создание методов в конструкторе

Использование конструкторов для создания объектов даёт большую гибкость. Можно передавать конструктору параметры, определяющие, как создавать объект, и что в него записывать.

В `this` мы можем добавлять не только свойства, но и методы.

Например, в примере ниже, `new User(name)` создаёт объект с данным именем `name` и методом `sayHi`:

```js run
function User(name) {
  this.name = name;

  this.sayHi = function() {
    alert( "Меня зовут: " + this.name );
  };
}

*!*
let vasya = new User("Вася");

john.sayHi(); // Меня зовут: Вася
*/!*

/*
vasya = {
   name: "Вася",
   sayHi: function() { ... }
}
*/
```

## Итого

- Функции-конструкторы или просто конструкторы являются обычными функциями, именовать которые следует с заглавной буквы.
- Конструкторы необходимо вызывать при помощи оператора `new`. Такой вызов создает пустой `this` в начале выполнения и возвращает заполненный в конце.

Мы можем использовать конструкторы для создания множества похожих объектов.

JavaScript предоставляет функции-конструкторы для множества встроенных объектов языка: например, `Date`, `Set` и других, которые нам ещё предстоит изучить.

```smart header="Объекты, мы к ним еще вернемся!"
В этой главе мы рассмотрели базовые принципы объектов и конструкторов. Данная информация необходима нам для дальнейшего изучения типов данных и функций в следующих главах. Как только мы с ними разберемся, мы вернемся к объектам для более детального изучения в
главах <info:prototypes> и <info:classes>.
```
