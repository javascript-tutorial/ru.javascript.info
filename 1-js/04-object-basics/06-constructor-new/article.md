# Конструкторы, создание объектов через "new"

Обычный синтаксис `{...}` позволяет создать только один объект. Но чаще всего нам нужно создать множество однотипных объектов, таких как список пользователей, элементы меню и т.д.

Всё это возможно благодаря функциям-конструкторам и оператору `"new"`.

## Функция-конструктор

Функции-конструкторы являются обычными функциями. Существует два соглашения по определению функций-конструкторов:

1. Имя функции-конструктора должно начинаться с большой буквы.
2. Функция-конструктор должна вызываться при помощи оператора `"new"`.

Например:

```js run
function User(name) {
  this.name = name;
  this.isAdmin = false;
}

*!*
let user = new User("Вася");
*/!*

alert(user.name); // Вася
alert(user.isAdmin); // false
```

Когда функция вызывается как `new User(...)`, происходит следующее:

1. Создаётся новый пустой объект и присваивается `this`.
2. Создаётся тело функции. Обычно `this` изменяется, путем добавления в него новых свойств.
3. Возвращается значение `this`.

Другими словами, при вызове `new User(...)` происходит следующее:

```js
function User(name) {
*!*
  // this = {};  (неявно)
*/!*

  // add properties to this
  this.name = name;
  this.isAdmin = false;

*!*
  // return this;  (неявно)
*/!*
}
```

То есть, результат вызова `new User("Вася")` то же самое что:

```js
let user = {
  name: "Вася",
  isAdmin: false
};
```

Теперь, когда нам необходимо будет создать других пользователей, мы можем использовать `new User("Ann")`,
`new User("Alice")` и т.д. Данная конструкция гораздо удобнее и читабельнее, чем каждый раз создавать литерал объекта. Это и является основным преимуществом функций-конструкторов - написание переиспользуемого кода для создания объектов.

Давайте ещё раз, вернёмся к вышесказанному. Технически, любая функция, может быть функцией-конструктором. Поэтому каждая функция может быть вызвана при помощи оператора `new` и выполнит алгоритм, указанный выше в примере. Заглавная буква в названии функции является всеобщим соглашением по именованию, она как бы подсказывает разработчику, что данная функция является функцией-конструктором и вызывается при помощи оператора `new`.

````smart header="new function() { ... }"
Если в нашем коде большое количество строк, создающих один сложный объект их можно обернуть в функцию-конструктор следующим образом:

```js
let user = new function() {
  this.name = "Вася";
  this.isAdmin = false;

  // ...любой другой пользовательский код
  // возможна любая сложная логика и выражения
  // локальные переменные и т. д.
};
```
Функция-конструктор не может быть вызвана дважды, так как данные о ней нигде не сохраняются, просто создаются и вызываются. Таким образом, такой метод создания позволяет инкапсулировать код, который создаёт отдельный объект без дальнейшего использования.
````

## Проверка вызова конструктора

```smart header="Проверка вызова конструктора"
Данный метод используется очень редко. Вы можете пропустить данный блок, если не хотите углубляться в детали языка.
```

Используя специальное свойство `new.target` внутри функции, мы можем проверить, вызвана ли функция при помощи оператора `new` или без него.

В случае, если функция вызвана при помощи оператор `new`, то вернётся тело функции, в противном случае вызов вернёт undefined.

```js run
function User() {
  alert(new.target);
}

// без "new":
*!*
User(); // undefined
*/!*

// с "new":
*!*
new User(); // function User { ... }
*/!*
```

Ниже приведённый пример можно использовать для того чтобы вызов функции при помощи оператора `new` и без него работали одинаково.

```js run
function User(name) {
  if (!new.target) { // в случае если вызов без оператора new
    return new User(name); // ...добавили оператор new за вас
  }
  
  this.name = name;
}

let vasya = User("Вася"); // переадресовываем вызовы на new User
alert(john.name); // Вася
```

Такой подход иногда используется в библиотеках для создания более гибкого синтаксиса, который позволяет разработчикам вызывать функции при помощи оператора `new` или без него.

Вызов функции-конструктора без оператора new является «плохой практикой», так как отсутствие `new` может ввести разработчика в заблуждение. С оператором new, мы точно знаем, что в итоге будет создан новый объект.


## Правило обработки return

Обычно, конструкторы ничего не возвращают. Их задача, записать все необходимое в this, который в итоге станет результатом.

Но если явный вызов `return` всё же есть, то применяется простое правило:

- При вызове `return` с объектом, будет возвращён объект, а не this.
- При вызове `return` с примитивным значением, примитивное значение будет отброшено.

Другими словами, `return` с объектом возвращает объект, в других случаях возвратит `this`.

В примере ниже, `return` переопределяет `this` возвращая объект:

```js run
function BigUser() {

  this.name = "Вася";

  return { name: "Godzilla" };  // <-- возвращает объект
}

alert( new BigUser().name );  // Godzilla, получает объект переданный в return ^^
```

А вот пример с возвратом пустого объекта (так же может быть указан любой другой примитивный тип данных).

```js run
function SmallUser() {

  this.name = "Вася";

  return; // завершает выполнение, возвращает this

  // ...

}

alert( new SmallUser().name );  // Вася
```

Обычно у конструкторов отсутствует `return`. В данном блоке мы упомянули особое поведение с возвращаемыми объектами, чтобы не оставлять пробелов в изучении языка.


````smart header="Отсутствие скобок"
Кстати, в случае если у объекта отсутствуют аргументы, скобки после `new` можно не указывать:

```js
let user = new User; // <-- без скобок
// same as
let user = new User();
```

Пропуск скобок считается «Плохой практикой», но синтаксис языка этого не запрещает.
````

## Создание методов в конструкторе

Использование функций для создания объектов даёт большую гибкость. Можно передавать конструктору параметры, определяющие, как создавать объект, и он будет создавать объекты заданным образом.

В `this` мы можем добавлять не только свойства, но и методы.

Например, в примере ниже, `new User(name)` создаёт объект с переданным в него `name` и методом `sayHi`:

```js run
function User(name) {
  this.name = name;

  this.sayHi = function() {
    alert( "Меня зовут: " + this.name );
  };
}

*!*
let vasya = new User("Вася");

john.sayHi(); // Меня зовут: Вася
*/!*

/*
vasya = {
   name: "Вася",
   sayHi: function() { ... }
}
*/
```

## Итого

- Функции-конструкторы, или просто, конструкторы, являются обычными функциями, именовать которые следует с заглавной буквы.
- Конструкторы необходимо вызывать при помощи оператора `new`. Такой вызов создает пустой `this` в начале выполнения и возвращает заполненный в конце.

Использование функции-конструктора позволяет нам создавать множество похожих объектов.

JavaScript предоставляет функции-конструкторы для множества встроенных объектов языка: например, такие как `Date`, `Set` и многие другие, которые нам еще предстоит выучить.

```smart header="Объекты, мы к ним еще вернемся!"
В этой главе мы рассмотрели базовые принципы объектов и конструкторов. Данная информация необходима нам для дальнейшего изучения типов данных и функций. Как только мы с ними разберемся, мы вернемся к объектам для более детального изучения в
главах <info:prototypes> и <info:classes>.
```
