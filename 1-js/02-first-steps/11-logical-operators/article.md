# Логические операторы

В JavaScript есть три логических оператора: `||` (ИЛИ), `&&` (И) и `!` (НЕ).

Несмотря на своё название, данные операторы могут применяться к значениям любых типов. Полученные результаты также могут иметь различный тип.

Давайте рассмотрим их подробнее.

## || (ИЛИ)

Оператор "ИЛИ" выглядит как двойной символ вертикальной черты:

```js
result = a || b;
```

Традиционно в программировании оператор ИЛИ предназначен только для манипулирования булевыми значениями: в случае, если какой-либо из аргументов означает `true`, возвращается `true`, в противоположной ситуации возвращается `false`.

В JavaScript этот оператор сложнее и мощнее. Но давайте сперва посмотрим, что происходит с булевыми значениями.

Существует всего четыре возможные логические комбинации:

```js run
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false
```

Как мы можем наблюдать, результат операций всегда равен `true`, за исключением случая, когда оба аргумента `false`.

Если значение не логического типа, то оно к нему приводится в целях вычислений.

Например, число `1` будет воспринято как `true`, а `0` – как `false`:

```js run
if (1 || 0) { // работает как if( true || false )
  alert( 'истинно!' );
}
```

Обычно оператор `||` используется в инструкциях `if` для проверки истинности любого из заданных условий.

К примеру:

```js run
let hour = 9;

*!*
if (hour < 10 || hour > 18) {
*/!*
  alert( 'Офис закрыт.' );
}
```

Можно передать и больше условий:

```js run
let hour = 12;
let isWeekend = true;

if (hour < 10 || hour > 18 || isWeekend) {
  alert( 'Офис закрыт.' ); // это выходной
}
```

## ИЛИ "||" находит первое истинное значение

Описанная выше логика соответствует традиционной. Теперь давайте поработаем с "дополнительными" возможностями JavaScript.

Расширенный алгоритм работает следующим образом.

При выполнении ИЛИ `||` с несколькими значениями:

```js
result = value1 || value2 || value3;
```

Оператор `||` выполняет следующие действия:

- Вычисляет операнды слева направо.
- Каждый операнд конвертирует в логическое значение. Если результат `true`, останавливается и возвращает исходное значение этого операнда.
- Если все операнды являются ложными (`false`), возвращает последний из них.

Значение возвращается в исходном виде, без преобразования.

Другими словами, цепочка ИЛИ `||` возвращает первое истинное значение или последнее, если истинного значения не найдено.

Например:

```js run
alert( 1 || 0 ); // 1 (1 истинно)

alert( null || 1 ); // 1 (первое истинное значение)
alert( null || 0 || 1 ); // 1 (первое истинное значение)

alert( undefined || null || 0 ); // 0 (поскольку все ложно, возвращается последнее значение)
```

Это делает возможным более интересное применение оператора по сравнению с "чистым, традиционным, только булевым ИЛИ".

1. **Получение первого истинного значения из списка переменных или выражений.**

    Представим, что у нас имеется ряд переменных `firstName`, `lastName` и `nickName` и все они необязательные (т.е. могут быть неопределёнными или иметь ложные значения).

    Используем ИЛИ `||`, чтобы выбрать переменную с данными и показать её значение (или строку `"Аноним"`, если все переменные пусты):

    ```js run
    let firstName = "";
    let lastName = "";
    let nickName = "СуперКодер";

    *!*
    alert( firstName || lastName || nickName || "Аноним"); // СуперКодер
    */!*
    ```

    Если бы все переменные содержали неистинные значения, было бы показано `"Аноним"`.

2. **Сокращённое вычисление.**

    Ещё одной возможностью оператора ИЛИ `||` является сокращённое вычисление.

    Вот что это значит. Оператор `||` обрабатывает аргументы до первого истинного значения, после чего немедленно возвращает его, даже не приступая к вычислению дальнейших аргументов.

    Важность такого поведения становится понятной, когда дальнейшие выражения не просто являются значениями, но имеют побочный эффект, например, изменение переменной или вызов функции.

    В приведённом ниже примере будет выведено только второе сообщение:

    ```js run no-beautify
    *!*true*/!* || alert("не выведется");
    *!*false*/!* || alert("выведется");
    ```

    В первой строке оператор ИЛИ `||` прекращает вычисления сразу после того, как встретит `true`, так что `alert` не вызывается.

    Иногда такую конструкцию используют, чтобы выполнять команды только в случае ложности условия слева от оператора.

## && (И)

Оператор И пишется как два амперсанда `&&`:

```js
result = a && b;
```

В традиционном программировании И возвращает `true`, если оба аргумента истинны, а иначе – `false`:

```js run
alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false
```

Пример с `if`:

```js run
let hour = 12;
let minute = 30;

if (hour == 12 && minute == 30) {
  alert( 'Время: 12:30' );
}
```

Как и в случае с ИЛИ, любое значение допускается в качестве операнда И:

```js run
if (1 && 0) { // вычисляется как true && false
  alert( "не сработает, так как результат ложный" );
}
```


## И "&&" находит первое ложное значение

При нескольких подряд операторах И:

```js
result = value1 && value2 && value3;
```

Оператор `&&` выполняет следующие действия:

- Вычисляет операнды слева направо.
- Каждый операнд преобразует в логическое значение. Если результат `false`, останавливается и возвращает исходное значение этого операнда.
- Если все операнды были истинными, возвращается последний.

Другими словами, И возвращает первое ложное значение. Или последнее, если ни одного ложного не найдено.

Вышеуказанные правила схожи с поведением ИЛИ. Разница в том, что И возвращает первое *ложное* значение, а ИЛИ -- первое *истинное*.

Примеры:

```js run
// Если первый операнд истинный,
// И возвращает второй:
alert( 1 && 0 ); // 0
alert( 1 && 5 ); // 5

// Если первый операнд ложный,
// И возвращает его. Второй операнд игнорируется
alert( null && 5 ); // null
alert( 0 && "неважно, что тут" ); // 0
```

Можно передать несколько значений подряд. В таком случае возвратится первое "ложное" значение, на котором остановились вычисления.

```js run
alert( 1 && 2 && null && 3 ); // null
```

Когда все значения верны, возвращается последнее

```js run
alert( 1 && 2 && 3 ); // 3
```

````smart header="Приоритет оператора `&&` больше, чем у `||`"
Приоритет оператора И `&&` больше, чем ИЛИ `||`.

Таким образом, код `a && b || c && d` по существу такой же, как если бы выражения `&&` были в круглых скобках: `(a && b) || (c && d)`.
````

````warn header="Не заменяйте `if` операторами `||` или `&&`"
Иногда оператор И `&&` используют как "сокращённый вариант `if`".

Например:

```js run
let x = 1;

(x > 0) && alert( 'Больше нуля!' );
```

Действие справа от `&&` выполнится, только если вычисление до него дойдёт. То есть только если `(x > 0)` будет истинно.

Собственно, этот код аналогичен следующему:

```js run
let x = 1;

if (x > 0) alert( 'Больше нуля!' );
```

Хотя вариант с `&&` кажется более кратким, инструкция с `if` более очевидна и, как правило, более читабельна. Так что мы рекомендуем использовать каждую конструкцию по своему назначению: используйте `if`, если нужна инструкция с`if`, и используйте `&&`, если нужен оператор И.
````


## ! (НЕ)

Оператор НЕ представлен восклицательным знаком `!`.

Синтаксис довольно прост:

```js
result = !value;
```

Оператор принимает один аргумент и выполняет следующие действия:

1. Сначала приводит аргумент к логическому типу `true/false`.
2. Затем возвращает противоположное значение.

Например:

```js run
alert( !true ); // false
alert( !0 ); // true
```

В частности, двойное НЕ `!!` используют для преобразования значений к логическому типу:

```js run
alert( !!"непустая строка" ); // true
alert( !!null ); // false
```

То есть первое НЕ преобразует значение в логическое значение и возвращает обратное, а второе НЕ снова инвертирует его. В конце мы имеем простое преобразование значения в логическое.

Есть чуть более длинный способ сделать то же самое — встроенная функция `Boolean`:

```js run
alert( Boolean("непустая строка") ); // true
alert( Boolean(null) ); // false
```

Приоритет НЕ `!` является наивысшим из всех логических операторов, поэтому он всегда выполняется первым, перед `&&` или `||`.
