# Автоматическое тестирование c использованием mocha

В последующих заданиях будет используется автоматические тестирование.

Это часть образовательного минимума для разработчика.

## Зачем нам нужны тесты?

Обычно, когда мы пишем функцию, мы легко можем представить, что она должна делать и как она будет вести себя в зависимости от переданных параметров.

Во время разработки мы можем проверить правильность работы функции просто вызвав ее, например из консоли, и сравнив полученный результат с ожидаемым.

Если функция работает не так, как мы ожидаем, можно исправить код и запустить её еще раз. Так можно повторять до тех пор, пока функция не станет работать так, как нам нужно.

Однако такие ручные проверки -- не лучшее решение.

**При ручном тестировании кода можно легко упустить что-нибудь важное.**

Например, мы работаем над функцией `f`. Написали часть кода и решили протестировать. Выясняется, что `f(1)` работает правильно, когда как `f(2)` -- нет. Мы вносим в код исправления и теперь `f(2)` работает правильно. Вроде бы все хорошо, не так ли? Однако, мы забыли заново протестировать `f(1)`. Возможно после внесения правок `f(1)` стала работать неправильно.  

Это типичная ситуация. Во время разработки мы учитываем множество различных сценариев использования. Но сложно ожидать, что программист станет вручную проверять каждый них после каждого изменения кода. Поэтому легко исправить что-то одно и при этом сломать что-то другое.

**Автоматическое тестирование означает, что тесты пишутся по отдельности, в дополнение к коду. Их можно легко запускать и они проверяют все основные варианты использования.**

## Behavior Driven Development (BDD)

Давайте начнем с техники под названием [Behavior Driven Development](https://ru.wikipedia.org/wiki/BDD_(программирование)).

**BDD – это три в одном: И тесты, И документация, И примеры использования.**

Достаточно слов. Взглянем на пример.

## Разработка функции возведения в степень — "pow": спецификация

Скажем мы хотим написать функцию `pow(x, n)` которая возводит `x` в целочисленную степень `n`. Мы предпологаем что `n≥0`.

Эта задача взята в качестве примера. В JavaScript есть оператор `**`, который служит для возведения в степень. Мы сосредоточимся на процессе разработки который также можно применять и для более сложных задач.

Перед тем как начать пистаь код функции `pow` мы можем представить себе что она должна делать и описать ее.

Такое описание называется *спецификацией*, сокращенно *spec* (от анг. *specification*) и выглядит так:

```js
describe("pow", function() {

  it("возводит в степень n", function() {
    assert.equal(pow(2, 3), 8);
  });

});
```

Спецификация состоит из трех основных блоков:

`describe("название", function() { ... })`
: Название функционала который мы описываем. Исрльзуется для групировки "воркеров" -- блоков `it`. В нашем случае мы описываем функцию `pow`.

`it("название", function() { ... })`
: Первым аргуметном блока `it` мы *человеческим языком* описываем конкретный способ использования функции, а второмы аргументом пишем функцию которая тестирует данный случай.

`assert.equal(value1, value2)`
: В случае правильной реализации функции для тестируемого случая, код внитри блока `it` должен выполняться без ошибок.

    Функции `assert.*` используются для проверки того что функция `pow` работает так, как мы ожидаем. В этом примере мы используем одну их них -- `assert.equal`, которая сравнивает переданные значения и выбрасывает ошибку если они не равны друг другу.

    Существуют и другие типы сравнения и проверок. Их мы рассмотрим позднее.

## Процесс разработки

Процесс разработки обычно выглядит следующим образом:

1. Пишется начальна спецификация с тестами, проверяющими основную функциональность.
2. Создается начальная реализация.
3. Для запуска тестов мы используем тестирующий фреймворк [Mocha](http://mochajs.org/) (подробнее о нем чуть поздее). Получаем ошибки. Вносим изменения до тех пор пока все не начнет работать так, как нам нужно.
4. Теперь у нас есть правильно работающая начальная реализация и тесты.
5. Мы добавляем новые способы использования в спецификацию, возможно еще не реализованные в трестируемом коде. Тесты начинают *падать*.
6. Возвращаемся на шаг 3, дописываем реализацию до тех пор пока тесты не начнут завершаться без ошибок.
7. Повторяем шаги 3-6 пока требуемый функционал не будет готов.

Таким образом разработка проходит *итеративно*. Мы пишем спецификацию, реализуем её, проверяем что тесты выполняются без ошибок, пишем еще тесты, снова проверяем что они проходят и т.д.

В нашем случае первый шаг пройдет. У нас есть спецификация для функции `pow`. Двавайте напишем реализацию. Перед этим давайте выполним "нулевой" запуск тестов, просто что бы убедится что тесты работают (разумеется они завершаться ошибками).

## Спецификация в действии

В этой главе мы будем пользоваться сдедующими JavaScript библиотеками для тестов:

- [Mocha](http://mochajs.org/) -- основной фреймворк. Он предоставляет общие функции тестирования, такие как `describe` и `it`, а так же функцию запуска тестов.
- [Chai](http://chaijs.com) -- библиотека предоставляющая множество функций проверки утверждений. Пока мы будем исползовать только `assert.equal`.
- [Sinon](http://sinonjs.org/) -- библиотека позволяющая наблюдать за функциями, подражать поведению встроенных функций и многое другое. Нам она пригодится позднее.

Эти библиотеки подходят как для тестирования внутри браузера, так и на стороне сервера. Мы рассмотрим вариант с браузером.

Полная HTML страница с этим библиотеками и спецификайией функции `pow`:

```html src="index.html"

```

Условно страницу можно разделить на пять частей:

1. Тег `<head>` содержит сторонние библиотеки и стили для тестов.
2. Тег `<script>` содержет тестируемую функцию, в нашем случае -- `pow`.
3. Тесты -- в нашем случае внешний скрипт `test.js` который содержит спецификацию `describe("pow", ...)` представленю выше.
4. HTML элемент `<div id="mocha">` будет использован фреймворком Mocha для вывода результатов тестирования.
5. Запуск тестов производится командой `mocha.run()`.

Результаты:

[iframe height=250 src="pow-1" border=1 edit]

Пока что тест завершается ошибкой. Это логично, у нас пустая функция `pow`, так что `pow(2,3)` возвращает `undefined` вместо `8`.

For the future, let's note that there are advanced test-runners, like [karma](https://karma-runner.github.io/) and others. So it's generally not a problem to setup many different tests.
На будущее отметим что существуют более продвинутые фреймворки для тестирования, такие как [karma](https://karma-runner.github.io/) и другие. Так что в большинстве случаев не возникает проблем с настройкой разных тестов.

## Начальная реализация

Давайте напишем простую реализацию функции `pow` что бы пройти тесты.

```js
function pow(x, n) {
  return 8; // :) сжульничаем!
}
```

Опаники, теперь все работает

[iframe height=250 src="pow-min" border=1 edit]

## Улучшаем спецификацию

Определенно мы сжульничали. Функция не работает. Попытка посчитать `pow(3,4)` даст не корректный результат, однако тесты проходят.

...Такая ситуация вполне типична, она случается на практике. Тесты проходят но функция работает не правильно. Наша спецификация не совершенна. Мы должна дополнить ее тестами.

Давайте добавим еще один тест что бы посмотреть что `pow(3, 4) = 81`.

Есть два пути организации тестов:

1. Первый -- добавить еще один `assert` в существующий `it`:

    ```js
    describe("pow", function() {

      it("возводит число в степень n", function() {
        assert.equal(pow(2, 3), 8);
    *!*
        assert.equal(pow(3, 4), 81);
    */!*
      });

    });
    ```
2. Второй -- написать два теста:

    ```js
    describe("pow", function() {

      it("2 в степени 3 будет 8", function() {
        assert.equal(pow(2, 3), 8);
      });

      it("3 в степени 3 будет 27", function() {
        assert.equal(pow(3, 3), 27);
      });

    });
    ```

Приниципиальная разница в том что когда один из `assert` выбрасывает ошибку, выполнение `it` блока тут же прекращается. Таким образом, если первый `assert` выбросит ошибку, результат работы второго `assert` мы уже не узнаем.

Разделять тесты предпочтительнее так как мы получаем больше информации о том что конкретно пошло не так.

Помимо этого есть одно хорошее правило которому стоит следовать.

**Один тест проверяет одну вещь.**

Если вы посмотрите на тест и увидите в нем две независимые проверки, то такой тест лучше разделить на два более простых.

Давайте продолжем со вторым вариантом.

Результаты:

[iframe height=250 src="pow-2" edit border="1"]

Как мы и ожидали, второй тест провалился. Естественно, наша функция всегда возвращает `8`, в то время как `assert` ожидает `27`.

## Улучшаем реализацию

Давайте напишем что-то более похожее на функцию возведения в степень что бы заставить тесты проходить.

```js
function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
```

Что бы убедится что эта реализация работает нормально давайте протистируем ее на большем количестве значений. Что бы не писать вручную каждый блок `it`, мы можем генерировать их в цикле `for`:

```js
describe("pow", function() {

  function makeTest(x) {
    let expected = x * x * x;
    it(`${x} в степени 3 будет ${expected}`, function() {
      assert.equal(pow(x, 3), expected);
    });
  }

  for (let x = 1; x <= 5; x++) {
    makeTest(x);
  }

});
```

Результат:

[iframe height=250 src="pow-3" edit border="1"]

## Вложенные блоки describe

Мы собираемся добавить еще тестов. Однако перед этим стоит сгрупировать вспомогательную функцию `makeTest` и `for`. Нам не нужна функция `makeTest` в других тестах, она нужна только в цикле `for`. Её предназначение -- проверить что `pow` праильно возводит число в заданную степень.

Групирование производится вложенными блоками `describe`:

```js
describe("pow", function() {

*!*
  describe("возводит x в степень 3", function() {
*/!*

    function makeTest(x) {
      let expected = x * x * x;
      it(`${x} в степени 3 будет ${expected}`, function() {
        assert.equal(pow(x, 3), expected);
      });
    }

    for (let x = 1; x <= 5; x++) {
      makeTest(x);
    }

*!*
  });
*/!*

  // ... другие тесты. Можно писать и describe и it блоки.
});
```

Вложенные `describe` образуют новую подгруппы тестов. В результатах теста мы можем видеть из названия и дополнительные отступы.

[iframe height=250 src="pow-4" edit border="1"]

In the future we can add more `it` and `describe` on the top level with helper functions of their own, they won't see `makeTest`.
В будущем мы можем написать новые `it` и `describe` блоки на верхнем уровне со своими собственными вспомогательными функциями. Им не будет доступна функция `makeTest` из примера выше.

````smart header="`before/after` и `beforeEach/afterEach`"
Мы можем /after` функции которые будут выполняться до/после тестов, а так-же функции `beforeEach/afterEach` выполняемые до/после *каждого* `it`.

Например:

```js no-beautify
describe("тест", function() {

  before(() => alert("Тестирование началось – перед тестами"));
  after(() => alert("Тестирование закончилось – после всех тестов"));

  beforeEach(() => alert("Перед тестом – начинаем выпонять тест"));
  afterEach(() => alert("После теста – заначиваем выполнение теста"));

  it('тест 1', () => alert(1));
  it('тест 2', () => alert(2));

});
```

Порядок выполнения будет таким:

```
Тестирование началось – перед тестами (before)
Перед тестом – начинаем выпонять тест (beforeEach)
1
После теста – заначиваем выполнение теста (afterEach)
Перед тестом – начинаем выпонять тест (beforeEach)
2
После теста – заначиваем выполнение теста (afterEach)
Тестирование закончилось – после всех тестов (after)
```

[edit src="beforeafter" title="Откройте пример в песочнице."]

Обычно, `beforeEach/afterEach` (`before/after`) используются для инициализации, обнуления счетчиков, или чего нибудь еще между тестами (или группами тестов).
````

## Расширение спецификации

Основной функцианал `pow` реализован. Первая итерация разработки завершена. Когда мы закончим отмечать и пить шампанское, давайте продолжем работу и улучшем её.

Как было сказано, функция `pow(x, n)` предназначена для работы с целыми, положительными значаниями `n`.

Для обозначения математических ошибок, функции JavaScript обычно возвращают `NaN`. Давайте делать так-же для некоректных значений `n`.

Сначала давайте опишем это поведение в спецификации.

​```js
describe("pow", function() {

  // ...

  it("для отрицательных n возвращает NaN", function() {
*!*
    assert.isNaN(pow(2, -1));
*/!*
  });

  it("для дробных n возвращает NaN", function() {
*!*
    assert.isNaN(pow(2, 1.5));    
*/!*
  });

});
```

Результаты с новыми тестами

[iframe height=530 src="pow-nan" edit border="1"]

The newly added tests fail, because our implementation does not support them. That's how BDD is done: first we write failing tests, and then make an implementation for them.
Новые тесты падают потомы что наша реализация не поддержвает их. Так работает BDD. Сначала мы пишем тесты которые падают, а у же потом пишем под них реализацию.

```smart header="Другие функции сравнения"

Обратите внимание на `assert.isNaN`, это утверждение позволяет проверить что переданное в ней значение равно `NaN`.

Библиотека Chai содержит множество других подобных функций, например:

- `assert.equal(value1, value2)` -- проверяет равенство  `value1 == value2`.
- `assert.strictEqual(value1, value2)` -- проверяет срогое равенство `value1 === value2`.
- `assert.notEqual`, `assert.notStrictEqual` -- проверяет неравенство и строгое неравенство соответственно.
- `assert.isTrue(value)` -- проверяет истиность значения `value === true`
- `assert.isFalse(value)` -- проверяет ложность значения `value === false`
- ...с полным списком можно ознакомится в [документации](http://chaijs.com/api/assert/)
```

Итак, нам нужно добавить пару строчек в функцию `pow`:

```js
function pow(x, n) {
*!*
  if (n < 0) return NaN;
  if (Math.round(n) != n) return NaN;
*/!*

  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
```

Now it works, all tests pass:
Теперь работат, все тесты проходят:

[iframe height=300 src="pow-full" edit border="1"]

[edit src="pow-full" title="Открыть готорый пример в песочнице."]

## Итоги

В BDD сначала пишуь спецификацию, потом реализацию. В конце у нас есть и то и другое.

Спецификацию можно использовать тремя способами:

1. **Тесты** гарантирую что функция работает правильно.
2. **Документация** -- заголовки блоков `describe` и `it` описывают поведение функции.
3. **Примеры** -- тесты, по суте, являются готовыми примерами использования функции.

Имея спецификацию мы можем улучшить, изменить и даже переписать функцию с нуля, и при этом мы будем уверены что она продолжает работать правильно.

Это особенно важно в больших проектах когда одна функция может быть использована во множестве мест. Когда мы вносим в такую функцию изменения, у нас нет никакой возможности вручную проверить что она продолжает работать правильно во всех местах где её используют.

Не имея тестов людям приходится выбирать один их двух путей:

1. Внести изменения, неважно что будет. Потом у наших пользователей станут появляться баги о которых они станут сообщать. Если мы конечно можем себе это позволить.
2. Или же люди побоятся вносить изменения в такие функции если наказание за ошибки будет суровым. Потом такой код стареет, зарастает паутиной и никто не хочет в него лезть. Это не хорошо.

**Автоматическое тестирование кода против этого!**

Если проект покрыт тестами, то выше упомянуты проблемы не возникают. Мы можем запустить тесты и увидить результаты огромного количества проверок, сделанных за секунды.

**Кроме того, код, хорошо покрытый тестами, как правило имеет более лучшую архитектуру.**

Естественно, его легче менять и улучшать. Но не только из-за этого.

Для написания тестов нужно организовать код таким образом что бы у каждой функции была ясно поставленная задача и точно определены её аргументы и возвращаемое значение. А это означает что мы получаем хорошую архетектуру с самого начала.

В реальносте это невсегда так просто. Иногда сложно написать спецификацию до того как будет написана реализация потому что не всегда чётко понятно как та или иная функция должна себя вести.

## Что теперь?

Далее по книге мы встретим много задач со тестами, так что вы увидите много практических примеров.

Написание тестов требует хорошего знания JavaScript. Но мы только начали учить его. Не волнуйтесь. Пока вам не нужно писать тесты, но вы уже умеете их читать и поймете даже более сложные чем те что были представлены в этой главе.
