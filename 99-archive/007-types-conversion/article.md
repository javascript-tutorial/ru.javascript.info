archive:
  ref: type-conversions

---

# Преобразование типов для примитивов

Система преобразования типов в JavaScript очень проста, но отличается от других языков. Поэтому она часто служит "камнем преткновения" для приходящих из других языков программистов.

Всего есть три преобразования:

1. Строковое преобразование.
2. Численное преобразование.
3. Преобразование к логическому значению.

**Эта глава описывает преобразование только примитивных значений, объекты разбираются далее.**

## Строковое преобразование

Строковое преобразование происходит, когда требуется представление чего-либо в виде строки. Например, его производит функция `alert`.

```js run
var a = true;

alert( a ); // "true"
```

Можно также осуществить преобразование явным вызовом `String(val)`:

```js run
alert( String(null) === "null" ); // true
```

Как видно из примеров выше, преобразование происходит наиболее очевидным способом, "как есть": `false` становится `"false"`, `null` -- `"null"`, `undefined` -- `"undefined"` и т.п.

Также для явного преобразования применяется оператор `"+"`, у которого один из аргументов строка. В этом случае он приводит к строке и другой аргумент, например:

```js run
alert( true + "test" ); // "truetest"
alert( "123" + undefined ); // "123undefined"
```

## Численное преобразование

Численное преобразование происходит в математических функциях и выражениях, а также при сравнении данных различных типов (кроме сравнений `===`, `!==`).

Для преобразования к числу в явном виде можно вызвать `Number(val)`, либо, что короче, поставить перед выражением унарный плюс `"+"`:

```js
var a = +"123"; // 123
var a = Number("123"); // 123, тот же эффект
```

<table>
<thead>
<tr><th>Значение</th><th>Преобразуется в...</th></tr>
</thead>
<tbody>
<tr><td><code>undefined</code></td><td><code>NaN</code></td></tr>
<tr><td><code>null</code></td><td><code>0</code></td></tr>
<tr><td><code>true / false</code></td><td><code>1 / 0</code></td></tr>
<tr><td>Строка</td><td>Пробельные символы по краям обрезаются.<br>Далее, если остаётся пустая строка, то <code>0</code>, иначе из непустой строки "считывается" число, при ошибке результат <code>NaN</code>.</td></tr>
</tbody>
</table>

Например:

```js run
// после обрезания пробельных символов останется "123"
alert( +"   \n  123   \n  \n" ); // 123
```

Ещё примеры:

- Логические значения:

    ```js run
    alert( +true ); // 1
    alert( +false ); // 0
    ```
- Сравнение разных типов -- значит численное преобразование:

    ```js run
    alert( "\n0 " == 0 ); // true
    ```

    При этом строка `"\n0"` преобразуется к числу, как указано выше: начальные и конечные пробелы обрезаются, получается  строка `"0"`, которая равна `0`.

- С логическими значениями:

    ```js run
    alert( "\n" == false );
    alert( "1" == true );
    ```

    Здесь сравнение `"=="` снова приводит обе части к числу. В первой строке слева и справа получается `0`, во второй `1`.

### Специальные значения

Посмотрим на поведение специальных значений более внимательно.

**Интуитивно, значения `null/undefined` ассоциируются с нулём, но при преобразованиях ведут себя иначе.**

Специальные значения преобразуются к числу так:
<table class="bordered">
<tr><th>Значение</th><th>Преобразуется в...</th></tr>
<tr><td><code>undefined</code></td><td><code>NaN</code></td></tr>
<tr><td><code>null</code></td><td><code>0</code></td></tr>
</table>

Это преобразование осуществляется при арифметических операциях и сравнениях `> >= < <=`, но не при проверке равенства `==`. Алгоритм проверки равенства для этих значений в спецификации прописан отдельно (пункт [11.9.3](https://es5.github.io/x11.html#x11.9.3)). В нём считается, что `null` и `undefined` равны `"=="` между собой, но эти значения не равны никакому другому значению.

Это ведёт к забавным последствиям.

Например, `null` не подчиняется законам математики -- он "больше либо равен нулю": `null>=0`, но не больше и не равен:

```js run
alert( null >= 0 ); // true, т.к. null преобразуется к 0
alert( null > 0 ); // false (не больше), т.к. null преобразуется к 0
alert( null == 0 ); // false (и не равен!), т.к. == рассматривает null особо.
```

Значение `undefined` вообще "несравнимо":

```js run
alert( undefined > 0 ); // false, т.к. undefined -> NaN
alert( undefined == 0 ); // false, т.к. это undefined (без преобразования)
alert( undefined < 0 ); // false, т.к. undefined -> NaN
```

**Для более очевидной работы кода и во избежание ошибок лучше не давать специальным значениям участвовать в сравнениях `> >= < <=`.**

Используйте в таких случаях переменные-числа или приводите к числу явно.

## Логическое преобразование

Преобразование к `true/false` происходит в логическом контексте, таком как `if(value)`, и при применении логических операторов.

Все значения, которые интуитивно "пусты", становятся `false`. Их несколько: `0`, пустая строка, `null`, `undefined` и `NaN`.

Остальное, в том числе и любые объекты -- `true`.

Полная таблица преобразований:

<table class="bordered">
<tr><th>Значение</th><th>Преобразуется в...</th></tr>
<tr><td><code>undefined</code>, <code>null</code></td><td><code>false</code></td></tr>
<tr><td>Числа</td><td>Все <code>true</code>, кроме <code>0</code>, <code>NaN</code> -- <code>false</code>.</td></tr>
<tr><td>Строки</td><td>Все <code>true</code>, кроме пустой строки <code>""</code> -- <code>false</code></td></tr>
<tr><td>Объекты</td><td>Всегда <code>true</code></td></tr>
</table>

**Для явного преобразования используется двойное логическое отрицание `!!value` или вызов `Boolean(value)`.**

````warn header="Обратите внимание: строка `\"0\"` становится `true`"
В отличие от многих языков программирования (например PHP), `"0"` в JavaScript является `true`, как и строка из пробелов:

```js run
alert( !!"0" ); // true
alert( !!" " ); // любые непустые строки, даже из пробелов - true!
```
````

Логическое преобразование интересно тем, как оно сочетается с численным.

**Два значения могут быть равны, но одно из них в логическом контексте `true`, другое -- `false`**.

Например, равенство в следующем примере верно, так как происходит численное преобразование:

```js run
alert( 0 == "\n0\n" ); // true
```

... А в логическом контексте левая часть (0) даст `false`, правая ("\n0\n") -- `true`, так как любая не пустая строка в логическом контексте равна `true`:

```js run
if ("\n0\n") {
  alert( "true, совсем не как 0!" );
}
```

С точки зрения преобразования типов в JavaScript это совершенно нормально. При сравнении с помощью "==" -- численное преобразование, а в `if` -- логическое, только и всего.

## Итого

В JavaScript есть три преобразования:

1. Строковое: `String(value)` -- в строковом контексте или при сложении со строкой. Работает очевидным образом.
2. Численное: `Number(value)` -- в численном контексте, включая унарный плюс `+value`. Происходит при сравнении разных типов, кроме строгого равенства.
3. Логическое: `Boolean(value)` -- в логическом контексте, можно также сделать двойным НЕ: `!!value`.

Точные таблицы преобразований даны выше в этой главе.

Особым случаем является проверка равенства с `null` и `undefined`. Они равны друг другу, но не равны чему бы то ни было ещё, этот случай прописан особо в спецификации.

