archive:
  ref: types

---

# Восемь типов данных, typeof

В JavaScript существует несколько основных типов данных.

В этой главе мы получим о них общее представление, а позже, в соответствующих главах подробно познакомимся с использованием каждого типа в отдельности.

## Число "number"

```js
var n = 123;
n = 12.345;
```

Единый тип *число* используется как для целых, так и для дробных чисел.

Существуют специальные числовые значения `Infinity` (бесконечность) и `NaN` (ошибка вычислений).

Например, бесконечность `Infinity` получается при делении на ноль:

```js run
alert( 1 / 0 ); // Infinity
```

Ошибка вычислений `NaN` будет результатом некорректной математической операции, например:

```js run
alert( "нечисло" * 2 ); // NaN, ошибка
```

Эти значения формально принадлежат типу "число", хотя, конечно, числами в их обычном понимании не являются.

Особенности работы с числами в JavaScript разобраны в главе <info:number>.

## Число "bigint"

В JavaScript тип "number" не может содержать числа больше, чем <code>2<sup>53</sup></code> (или меньше, чем <code>-2<sup>53</sup></code> для отрицательных). Это техническое ограничение вызвано их внутренним представлением. <code>2<sup>53</sup></code> - это достаточно большое число, состоящее из 16 цифр, поэтому чаще всего проблем не возникает. Но иногда нам нужны действительно гигантские числа, например в криптографии или при использовании метки времени ("timestamp") с микросекундами.

Тип `BigInt` был добавлен в JavaScript, чтобы дать возможность работать с целыми числами произвольной длины.

Чтобы создать значение типа `BigInt`, необходимо добавить `n` в конец числового литерала:

```js
// символ "n" в конце означает, что это BigInt
const bigInt = 1234567890123456789012345678901234567890n;
```

Более подробно тип данных `BigInt` мы рассмотрим в отдельной главе <info:bigint>.

## Строка "string"

```js
var str = "Мама мыла раму";
str = 'Одинарные кавычки тоже подойдут';
```

**В JavaScript одинарные и двойные кавычки равноправны.** Можно использовать или те или другие.

```smart header="Тип *символ* не существует, есть только *строка*."
В некоторых языках программирования есть специальный тип данных для одного символа. Например, в языке С это `char`. В JavaScript есть только тип "строка" `string`. Что, надо сказать, вполне удобно.
```

Более подробно со строками мы познакомимся в главе <info:string>.

## Булевый (логический) тип "boolean"

У него всего два значения: `true` (истина) и `false` (ложь).

Как правило, такой тип используется для хранения значения типа да/нет, например:

```js no-beautify
var checked = true; // поле формы помечено галочкой
checked = false;    // поле формы не содержит галочки
```

О нём мы поговорим более подробно, когда будем обсуждать логические вычисления и условные операторы.

## Специальное значение "null"

Значение `null` не относится ни к одному из типов выше, а образует свой отдельный тип, состоящий из единственного значения `null`:

```js
var age = null;
```

В JavaScript `null` не является "ссылкой на несуществующий объект" или "нулевым указателем", как в некоторых других языках. Это просто специальное значение, которое имеет смысл "ничего" или "значение неизвестно".

В частности, код выше говорит о том, что возраст `age` неизвестен.

## Специальное значение "undefined"

Значение `undefined`, как и `null`, образует свой собственный тип, состоящий из одного этого значения. Оно имеет смысл "значение не присвоено".

Если переменная объявлена, но в неё ничего не записано, то её значение как раз и есть `undefined`:

```js run
var x;
alert( x ); // выведет "undefined"
```

Можно присвоить `undefined` и в явном виде, хотя это делается редко:

```js run
var x = 123;
x = undefined;

alert( x ); // "undefined"
```

В явном виде `undefined` обычно не присваивают, так как это противоречит его смыслу. Для записи в переменную "пустого" или "неизвестного" значения используется `null`.

## Символы "symbol"

"Символ" представляет собой уникальный идентификатор.

Создаются новые символы с помощью функции `Symbol()`:

```js
// Создаём новый символ - id  
let id = Symbol();
```

При создании символу можно дать описание (также называемое имя), в основном использующееся для отладки кода:

```js run
// Создаём символ id с описанием (именем) "id"
let id = Symbol("id");
```

Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы. Описание -- это просто метка, которая ни на что не влияет.

Например, вот два символа с одинаковым описанием -- но они не равны:

```js run
let id1 = Symbol("id");
let id2 = Symbol("id");

*!*
alert(id1 == id2); // false
*/!*
```

Более подробно c символами мы познакомимся в главе <info:symbol>.

## Объекты "object"

Первые 7 типов называют *"примитивными"*.

Особняком стоит восьмой тип: *"объекты"*.

Он используется для коллекций данных и для объявления более сложных сущностей.

Объявляются объекты при помощи фигурных скобок `{...}`, например:

```js
var user = { name: "Вася" };
```

Мы подробно разберём способы объявления объектов и, вообще, работу с объектами, позже, в главе <info:object>.

## Оператор typeof [#type-typeof]

Оператор `typeof` возвращает тип аргумента.

У него есть два синтаксиса: со скобками и без:

1. Синтаксис оператора: `typeof x`.
2. Синтаксис функции: `typeof(x)`.

Работают они одинаково, но первый синтаксис короче.

**Результатом `typeof` является строка, содержащая тип:**

```js
typeof undefined // "undefined"

typeof 0 // "number"

typeof 1n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol() // "symbol"

typeof {} // "object"

*!*
typeof null // "object"  (1)
*/!*

*!*
typeof function(){} // "function"  (2)
*/!*
```

Последние две строки помечены, потому что `typeof` ведёт себя в них по-особому.

1. Результат `typeof null == "object"` -- это официально признанная ошибка в языке, которая сохраняется для совместимости. На самом деле `null` -- это не объект, а отдельный тип данных.
2. Функции мы пройдём чуть позже. Пока лишь заметим, что функции не являются отдельным базовым типом в JavaScript, а подвидом объектов. Но `typeof` выделяет функции отдельно, возвращая для них `"function"`. На практике это весьма удобно, так как позволяет легко определить функцию.

К работе с типами мы также вернёмся более подробно в будущем, после изучения основных структур данных.

## Итого

Есть 5 "примитивных" типов: `number`, `string`, `boolean`, `null`, `undefined` и 6-й тип -- объекты `object`.

Очень скоро мы изучим их во всех деталях.

Оператор `typeof x` позволяет выяснить, какой тип находится в `x`, возвращая его в виде строки.
