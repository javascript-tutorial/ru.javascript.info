
# Наблюдатель за изменениями 

`MutationObserver` - это встроенный объект, который наблюдает за DOM-элементом и в случае каких-либо изменений запускает callback.

Сначала мы видим синтаксис, и только потом раскрываем для себя реальный сценарий использования.

## Синтаксис

`MutationObserver` лёгок в использовании.

Сначала мы создаём наблюдатель с помощью callback-функции:

```js
let observer = new MutationObserver(callback);
```

Потом вставляем его в DOM-узел:

```js
observer.observe(node, config);
```

`config` - это объект с дополнительным булевыми параметрами "на какие изменения реагировать":
- `childList` -- изменения в непосредственных дочерних элементах `node`,
- `subtree` -- во всех потомках `node`,
- `attributes` -- атрибуты `node`,
- `attributeOldValue` -- записать старое значение атрибута  (логически выводит `attributes`),
- `characterData` -- наблюдать ли за `node.data` (содержимое текста),
- `characterDataOldValue` -- записать старое значение `node.data` (логически выводит `characterData`),
- `attributeFilter` -- массив имён атрибутов, чтобы наблюдать только за выбранными.

Затем, после изменений, выполняется  `callback`  со списком объектов [MutationRecord](https://dom.spec.whatwg.org/#mutationrecord) в качестве первого аргумента, а сам наблюдатель вторым аргументом.

[MutationRecord](https://dom.spec.whatwg.org/#mutationrecord) объекты имеют следующие свойства:

- `type` -- тип изменения, один из
   - `"attributes"` (измененный атрибут)
   - `"characterData"` (измененные данные)
   - `"childList"` (добавленные/удаленные элементы),
- `target` -- где произошло изменение: элемент для "attributes", текстовый узел для "characterData", или элемент для "childList" изменения,
- `addedNodes/removedNodes`  -- узлы, которые были добавлены/удалены,
- `previousSibling/nextSibling` -- предыдущий или следующий одноуровневый элемент для добавленных/удаленных элементов,
- `attributeName/attributeNamespace` -- имя/пространство имен (для XML) измененного атрибута,
- `oldValue` -- предыдущее значение, только для изменений атрибута или текста.


Например, возьмём `<div>` с атрибутом `contentEditable`. Этот атрибут позволяет нам сосредоточится на нём и редактировать его.

```html run
<div contentEditable id="elem">Отредактируй <b>меня</b>, пожалуйста</div>

<script>
let observer = new MutationObserver(mutationRecords => {
  console.log(mutationRecords); // console.log(изменения)
});
observer.observe(elem, {
  // наблюдать за всем кроме атрибутов
  childList: true,
  subtree: true,
  characterDataOldValue: true
});
</script>
```

Если мы изменим текст внутри`<b>меня</b>`, мы получим единичное изменение:

```js
mutationRecords = [{
  type: "characterData",
  oldValue: "меня",
  target: <text node>,
  // другие свойства пусты
}];
```

Если мы выбираем или удаляем `<b>меня</b>` полностью, мы получим множественные изменения:

```js
mutationRecords = [{
  type: "childList",
  target: <div#elem>,
  removedNodes: [<b>],
  nextSibling: <text node>,
  previousSibling: <text node>
  // другие свойства пусты
}, {
  type: "characterData"
  target: <text node>
  // ...одетали зависят от того, как браузер обрабатывает изменения
  // он может соединить два соседних текстовых узла "Отредактируй " и ", пожалуйста" в один узел
  // или он может просто удалить дополнительный пробел после "Edit".
  // может быть одна мутация или несколько
}];
```

## Пример использования наблюдателя

Когда необходим `MutationObserver` ? Существуют ли случаи когда он может быть полезен?

Конечно, мы можем отслеживать что-то вроде `contentEditable` и создавать стэк "undo/redo", но вот пример, где `MutationObserver` хорошо подходит с архитектурной точки зрения.

Представим, что мы создаём вебсайт о программировании вроде этого. Естественно, статьи и другие материалы могут содержать сниппеты с исходным кодом.

Сниппет с HTML-кодом выглядит так:
```html
...
<pre class="language-javascript"><code>
  // вот код
  let hello = "world";
</code></pre>
...
```

Также существует JavaScript-библиотека подсветки синтаксиса, например [Prism.js](https://prismjs.com/). Обращение к `Prism.highlightElem(pre)` проверяет содержание таких элементов `pre` и добавляет цветное добавление синтаксиса, похожее на то, что вы видите в примерах здесь, на этой странице.

В целом, когда загружается страница, в конце страницы, например, мы можем искать элементы `pre[class*="language"]` и на них обращаться к `Prism.highlightElem`:

```js
// выделять все сниппеты кода  на странице
document.querySelectorAll('pre[class*="language"]').forEach(Prism.highlightElem);
```

Теперь сниппет `<pre>` выглядит так (без указания номеров строк по умолчанию):

```js
// вот код
let hello = "world";
```

Пока всё просто, правда? В HTML есть сниппеты кода `<pre>`, мы их выделяем.

Идём дальше. Представим, что мы собираемся динамически получать материалы с сервера. Позже в учебнике мы выучим для этого [способы](info:fetch-basics). На данный момент имеет значение только то, что мы получаем HTML статьи с веб-сервера и показываем её по запросу:

```js
let article = /* получить новое содержание с сервера */
articleElem.innerHTML = article;
```

Новая `статья` HTML может содержать сниппеты кода. Нам необходимо обратиться к  `Prism.highlightElem` на них, иначе они не выделятся цветом.

**Кто должен обращаться к `Prism.highlightElem`, чтобы динамически загрузить статью?**

Мы можем добавить этот вызов к коду, который загружает статью, например, так:

```js
let article = /* получить новое содержание с сервера */
articleElem.innerHTML = article;

*!*
let snippets = articleElem.querySelectorAll('pre[class*="language-"]');
snippets.forEach(Prism.highlightElem);
*/!*
```

...Но представьте, что у нас есть много мест где мы загружаем содержание с помощью кода: статьи, опросы, посты форумов. Нужно ли нам выделять каждый запрос? В таком случае нам необходимо быть внимательными, чтобы об этом не забыть.

И что если мы загрузим содержимое в сторонний модуль? Например, у нас есть форум, написанный другим человеком, который загружает содержимое динамически, и нам бы хотелось добавить к нему выделение синтаксиса. Никто не любит править чужие скрипты.

К счастью, есть другой вариант.

Мы можем использовать `MutationObserver`, чтобы автоматически определять сниппеты кода, вставленные в страницу и выделять их.

Поэтому мы реализуем функциональность выделения в одном месте, избавляя себя от необходимости интегрировать её.

## Демо динамического выделения

Вот работающий пример.

Если вы запустите этот код, он начнёт наблюдать за элементом ниже, выделяя любой сниппет кода, который появляется там:

```js run
let observer = new MutationObserver(mutations => {

  for(let mutation of mutations) {
    // проверка новых узлов

    for(let node of mutation.addedNodes) {
      // пропустить вновь созданные текстовые ноды
      if (!(node instanceof HTMLElement)) continue;

      // проверить не является ли вставленный элемент сниппетом кода
      if (node.matches('pre[class*="language-"]')) {
        Prism.highlightElement(node);
      }

      // искать сниппеты кода в его поддереве
      for(let elem of node.querySelectorAll('pre[class*="language-"]')) {
        Prism.highlightElement(elem);
      }
    }
  }

});

let demoElem = document.getElementById('highlight-demo');

observer.observe(demoElem, {childList: true, subtree: true});
```

<p id="highlight-demo" style="border: 1px solid #ddd">В примере выше рассматривался демо элемент с <code>id="highlight-demo"</code>.</p>

Код ниже включает `innerHTML`. Если вы запустите код выше, сниппеты выделятся.

```js run
let demoElem = document.getElementById('highlight-demo');

// динамически вставить содержимое сниппетами кода
demoElem.innerHTML = `Сниппет кода ниже:
  <pre class="language-javascript"><code> let hello = "world!"; </code></pre>
  <div>Еще один:</div>
  <div>
    <pre class="language-css"><code>.class { margin: 5px; } </code></pre>
  </div>
`;
```

Теперь у нас есть `MutationObserver`, который может отслеживать все выделения в наблюдаемых элементах или во всём документе``. Мы можем добавлять/удалять сниппеты кода в HTML не задумываясь об этом.


## Сбор мусора

Внутри наблюдателей используются слабые ссылки на узлы. То есть: если узел изымается из DOM, и становится недоступным, его убирает сборщик мусора, наблюдатель не может это предотвратить.

Однако, мы можем запускать наблюдателей в любое время:

- `observer.disconnect()` -- останавливает наблюдение.

К тому же:

- `mutationRecords = observer.takeRecords()` -- получает список необработанных записей изменений, которые произошли но callback не выполняет их.

```js
// мы собираемся отсоединить наблюдатель 
// он ещё мог не выполнить некоторые изменения
let mutationRecords = observer.takeRecords();
// обработать mutationRecords

// теперь всё выполнилось, отсоединить
observer.disconnect();
```

## Выводы

`MutationObserver` может реагировать на изменения в DOM: аттрибуты, добавленные/удаленные элементы, содержание текста.

Мы можем использовать его, чтобы отслеживать изменения, внедренные другими частями нашего собственного или чужого кода.

Например, чтобы осуществить последующую обработку динамически вставленного  содержимого, такого как  демо `innerHTML`, выделенного на примере выше.
